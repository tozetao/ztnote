### fork()

```c
#include <unistd.h>

pid_t fork(void);
// In parent: returns process ID of child on success, or -1 on error.
```

fork()系统调用允许进程创建一新进程，新进程是子进程，原进程为父进程。在fork()成功后，父子进程都是从fork()的返回处进行执行代码。

在父进程中fork()执行成功返回的是子进程的进程ID，在子进程中fork()执行成功会返回0；如果返回-1一般是真实用户超出系统允许创建的进程数量或者超出系统允许创建的进程数量。

- 父子进程的区别

  父子进程会指向相同的程序文本段，但却拥有不同的数据段、栈段和堆段。子进程的数据段、栈段和堆段在开始时是对父进程的完全复制，执行fork()后，每个进程均可修改各自的栈数据和堆中的变量，且互不影响。

- 进程的调用顺序

  要明确的是，父子进程的调用顺序是未知且不可靠的，因为进程的调度分配工作是由内核来决定的， 对于程序是不可知的。



### fork的文件共享

执行fork()时，子进程会获得父进程所有文件描述符的副本。

这些副本的创建方式相当于dup()，这意味父子进程的文件描述符都指向相同的打开文件句柄，而打开文件句柄包含当前偏移量与文件状态标志，所以父子进程共享同一个文件句柄，父子之间对文件描述符的操作都会影响对方。



### fork的内存语义

从概念上可以将fork()当做是对父进程的程序段、数据段、堆段和栈段的创建拷贝，然而这种实现太浪费内存空间了，因此大部分unix实现采用俩种技术来避免这种浪费。

- 共享代码段

  内核对每一进程的代码段标记为只读，从而使进程无法修改自身代码，这样父子进程会共享同一代码段。

  fork()在为子进程创建代码段时，其构建的进程级页表项都指向与父进程相同的物理内存页帧。

- 对于数据段、堆栈和栈段采用写时复制技术

  内核会先让子进程这些段的页表项指向与父进程相同的物理内存页帧，并将这些页标记为只读。

  调用fork()之后内核会捕获所有父进程和子进程针对这些页帧的修改企图，并为将要修改的页帧创建拷贝，系统会将新的页帧拷贝分配给遭到内核捕获的进程，还会对子进程的相应页表项做适当调整，这时父子进程可修改各自的也拷贝，且互不影响。



### 进程的终止

进程的终止方式有俩种，一种是异常（abnormal）终止，比如接收了某一信号，该信号的默认动作为终止当前进程，可能产生核心转储（core dump）；另一种是使用_exit()系统调用正常（normally）终止。



```c
#include <unistd.h>
void _exit(int status);
```

\_exit()的status参数定义了进程的终止状态，父进程可调用wait()以获取该状态，status虽然是int型，但是只有低8位可为父进程使用。一般status等于0表示程序正常退出，非0值表示异常退出。



```CQL
#include <unistd.h>
void exit(int status);
```

一般不会执行_exit()系统调用，而是执行exit()库函数，它做了些封装，在\_exic()执行之前做如下处理：

- 调用退出处理程序，通过atexit()和on_exit()注册的函数，其执行顺序与注册顺序相反
- 刷新stdio流缓冲区
- 使用有status提供的值执行_exit()系统调用

程序的另一种终止方法，在main()函数中return返回值等同于exit()调用



无论进程是否正常终止，都会发生以下操作：

- 关闭所有打开文件描述符、目录流、信息目录描述符。
- 关闭文件描述符后，将释放该进程所持有的任何文件锁。
- 分离（detach）任何已连接的System V共享内存段，且对应于各段的shm_nattch计数器的值将减1
- 进程为每个System V信号量所设置的semadj值将会被加到信号量值中
- 将关闭该进程打开的任何POSIX有名信号量，类似调用sem_close()
- 将关闭进程打开的任何POSIX消息队列，类似调用mq_close()
- 移除该进程通过mlock()或mlockall()所建立的任何内存锁。
- 取消该进程调用mmap()所创建的任何内存映射
- 如果该进程是一个管理终端的管理进程，那么系统会向该终端前台进程进程组中的每个进程发送SIGHUP信号，接着终端与会话脱离。
- 如果某进程组成为孤儿，且该组中存在任何已停止进程，则组中所有进程都将收到SIGHUP信号，随之为SIGCONT信号。





### 退出处理程序

退出处理程序指的是在进程终止时会自动的执行某些操作。

退出处理器程序其实就是一个自定义的处理函数，可在进程生命周期的任何时间点进行注册，并会在该进程调用exit()正常终止时自动执行。如果程序调用_exit()或因信号而异常终止，是不会调用退出处理程序的。

要注意的是，当进程收到信号而终止时，将不会调用退出处理程序，这时最好的方式是针对可能会发送给进程的信号注册处理程序，并在其中设置标记位，由主程序来执行exit()函数，因为exit()不属于异步安全函数。即使如此仍然不能解决SIGKILL信号，因此建议使用SIGTERM信号。



```c
#include <stdlib.h>

int atexit(void (*func)(void));
// reutrns 0 on success, or nonzero on error
```

函数atexit()会将func注册到一个函数列表中，进程终止时会调用该函数列表的所有函数。func参数是一个函数指针，无参数也无返回值。

- 执行顺序

  可以注册多个处理程序，这些程序的执行顺序与注册顺序相反。

- 注册退出程序的数量上限

  SUSV3要求系统实现允许一个进程能够注册最少32个退出处理程序，通过系统调用sysconf(\_SC_ATEXIT_MAX)可以查看系统可注册退出处理程序的数量上限。





















