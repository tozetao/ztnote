### fork()

```c
#include <unistd.h>

pid_t fork(void);
// In parent: returns process ID of child on success, or -1 on error.
```

fork()系统调用允许进程创建一新进程，新进程是子进程，原进程为父进程。父子进程都是从fork()的返回处进行执行代码。



父进程与子进程将执行相同的程序文本段，但却拥有不同的栈段、数据段和堆段拷贝。子进程的栈、数据以及堆段在开始时是对父内存内存相应各部分的完全复制。执行fork()之后，每个进程均可修改各自的栈数据、以及堆段中的变量，而互不影响。



在父进程中，fork()执行成功时将返回子进程的进程id；而在子进程执行成功时会返回0；如果返回-1一般是真实用户超出系统允许创建的进程数量或超出系统允许创建最大的进程数量上限。



### 文件共享

执行fork()时，子进程会获得父进程所有文件描述符的副本。

这些副本的创建方式相当于dup()，这意味父子进程的文件描述符都指向相同的打开文件句柄，而打开文件句柄包含当前偏移量与文件状态标志，所以父子进程共享同一个文件句柄，父子之间对文件描述符的操作都会影响对方。



测试0：

改变文件偏移量和文件状态标记，测试倆者之间的互相影响。



测试1：

共享文件偏移量会确保二者不会覆盖彼此之间的输出内容，但是父子进程的输出会随意混杂在一起。



要规避这一现象需要进行进程间的同步，例如父进程使用wait()来暂停运行并等待子进程输出，当子进程结束输出时父进程再执行。

shell便是这样处理的，只有当执行命令的子进程退出后，shell才会打印出提示符（除非用户在命令行加上&显示在后台执行命令）。



### fork的内存语义

对于代码段，内核会将其标记为只读，从而使进程无法修改自身代码。

这样父子进程可共享同一代码段，系统调用fork()在为子进程创建代码段时，其所构建的一系列进程级页表项（page-table entries）均指向与父进程相同的物理内存页帧。



对于父进程数据段、堆段和栈段中的各页，内核采用写时复制技术来处理。

最初内核做了一些设置，令这些段的页表项指向与父进程相同的物理内存页，并将这些页面标记为只读。调用了fork()之后，内核会捕获所有父进程和子进程针对这些页面的修改企图，并为将要修改的页面创建拷贝。

系统将新的页面拷贝分配给遭内核捕获的进程，还会对子进程的相应页表项做适当调整，从这一刻起，父子进程可以分别修改各自的页拷贝，不再相互影响。



控制进程的内存需求

通过将fork()与wait()组合使用，可以控制一个进程的内存需求。进程的内存需求量，亦即进程所使用的虚拟内存页范围，它会受多种因素影响。例如调用函数或函数返回时栈的变化情况、调用malloc()或free()而对堆做的修改。

```c
int main()
{
    pid_t childId;
    int status;
    
    childId = fork();
    if (childId == -1) {
        perror("fork error");
        exit(-1);
    }
    
    if (childId == 0) {
        exit(func(arg));
    }
    
    if (wait(&status) == -1) {
        exit(-1);
    }
}
```



### fork的竞争条件

在调用fork()之后是无法确定父子进程的执行顺序的，如果程序依赖于父子进程的执行顺序而产生结果，那么会因为竞争条件而导致失败，因为无法确定哪个进程会先被内核调度。



如果程序依赖于进程的执行顺序来产生结果，可以通过同步信号来避免竞争条件。

调用fork()之后，如果进程A需要等待进程B完成某个动作，那么进程B可以在完成指定动作后向进程A发送信号，而进程A只需要等待即可。



进程的终止

进程的终止有俩种方式，其一为异常（abnormal）终止，例如对一信号的接受而引发，该信号的默认动作为终止当前进程，可能产生核心转储（core dump）。另一种是使用_exit()系统调用正常（normally）终止。



```c
#include <unistd.h>
void _exit(int status);
```

_exit()的status参数定义了进程的终止状态，父进程可调用wait()以获取该状态，status虽然是int型，但是只有低8位可为父进程使用。一般status等于0表示程序正常退出，非0值表示异常退出。

```CQL
#include <unistd.h>
void exit(int status);
```

一般不会执行_exit()系统调用，而是执行exit()库函数，它会在执行之前做如下动作：

- 调用退出处理程序，通过atexit()和on_exit()注册的函数，其执行顺序与注册顺序相反
- 刷新stdio流缓冲区
- 使用有status提供的值执行_exit()系统调用

注：在main()函数中return返回值等同于exit()调用



无论进程是否正常终止，都会发生以下操作：

- 关闭所有打开文件描述符、目录流、信息目录描述符。

- 关闭文件描述符后，将释放该进程所持有的任何文件锁。
- 分离（detach）任何已连接的System V共享内存段，且对应于各段的shm_nattch计数器的值将减1
- 进程为每个System V信号量所设置的semadj值将会被加到信号量值中
- 将关闭该进程打开的任何POSIX有名信号量，类似调用sem_close()
- 将关闭进程打开的任何POSIX消息队列，类似调用mq_close()
- 移除该进程通过mlock()或mlockall()所建立的任何内存锁。
- 取消该进程调用mmap()所创建的任何内存映射
- 如果某进程组称为孤儿...
- 如果该进程是一个管理终端的管理进程...



退出处理程序

退出处理程序指的是在进程终止时会自动的执行某些操作。

退出处理器程序其实就是一个自定义的处理函数，可在进程生命周期的任何时间点进行注册，并会在该进程调用exit()正常终止时自动执行。如果程序调用_exit()或因信号而异常终止，是不会调用退出处理程序的。

```c
#include <stdlib.h>

int atexit(void (*func)(void));
// reutrns 0 on success, or noezero on error
```

函数atexit()会将func注册到一个函数列表中，进程终止时会调用该函数列表的所有函数。func参数是一个函数指针，无参数也无返回值。







