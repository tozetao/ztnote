### fork()

```c
#include <unistd.h>

pid_t fork(void);
// In parent: returns process ID of child on success, or -1 on error.
```

fork()系统调用允许进程创建一新进程，新进程是子进程，原进程为父进程。父子进程都是从fork()的返回处进行执行代码。



父进程与子进程将执行相同的程序文本段，但却拥有不同的栈段、数据段和堆段拷贝。子进程的栈、数据以及堆段在开始时是对父内存内存相应各部分的完全复制。执行fork()之后，每个进程均可修改各自的栈数据、以及堆段中的变量，而互不影响。



在父进程中，fork()执行成功时将返回子进程的进程id；而在子进程执行成功时会返回0；如果返回-1一般是真实用户超出系统允许创建的进程数量或超出系统允许创建最大的进程数量上限。



### 文件共享

执行fork()时，子进程会获得父进程所有文件描述符的副本。

这些副本的创建方式相当于dup()，这意味父子进程的文件描述符都指向相同的打开文件句柄，而打开文件句柄包含当前偏移量与文件状态标志，所以父子进程共享同一个文件句柄，父子之间对文件描述符的操作都会影响对方。



测试0：

文件偏移量与文件状态标记的互相影响。



测试1：

共享文件偏移量会确保二者不会覆盖彼此之间的输出内容，但是父子进程的输出会随意混杂在一起。



要规避这一现象需要进行进程间的同步，例如父进程使用wait()来暂停运行并等待子进程输出，当子进程结束输出时父进程再执行。

shell便是这样处理的，只有当执行命令的子进程退出后，shell才会打印出提示符（除非用户在命令行加上&显示在后台执行命令）。



### fork的内存语义



### 进程与同步信号

