### fork()

```c
#include <unistd.h>

pid_t fork(void);
// In parent: returns process ID of child on success, or -1 on error.
```

fork()系统调用允许进程创建一新进程，新进程是子进程，原进程为父进程。父子进程都是从fork()的返回处进行执行代码。



父进程与子进程将执行相同的程序文本段，但却拥有不同的栈段、数据段和堆段拷贝。子进程的栈、数据以及堆段在开始时是对父内存内存相应各部分的完全复制。执行fork()之后，每个进程均可修改各自的栈数据、以及堆段中的变量，而互不影响。



在父进程中，fork()执行成功时将返回子进程的进程id；而在子进程执行成功时会返回0；如果返回-1一般是真实用户超出系统允许创建的进程数量或超出系统允许创建最大的进程数量上限。



### 文件共享

执行fork()时，子进程会获得父进程所有文件描述符的副本。

这些副本的创建方式相当于dup()，这意味父子进程的文件描述符都指向相同的打开文件句柄，而打开文件句柄包含当前偏移量与文件状态标志，所以父子进程共享同一个文件句柄，父子之间对文件描述符的操作都会影响对方。



测试0：

文件偏移量与文件状态标记的互相影响。



测试1：

共享文件偏移量会确保二者不会覆盖彼此之间的输出内容，但是父子进程的输出会随意混杂在一起。



要规避这一现象需要进行进程间的同步，例如父进程使用wait()来暂停运行并等待子进程输出，当子进程结束输出时父进程再执行。

shell便是这样处理的，只有当执行命令的子进程退出后，shell才会打印出提示符（除非用户在命令行加上&显示在后台执行命令）。



### fork的内存语义

对于代码段，内核会将其标记为只读，从而使进程无法修改自身代码。

这样父子进程可共享同一代码段，系统调用fork()在为子进程创建代码段时，其所构建的一系列进程级页表项（page-table entries）均指向与父进程相同的物理内存页帧。



对于父进程数据段、堆段和栈段中的各页，内核采用写时复制技术来处理。

最初内核做了一些设置，令这些段的页表项指向与父进程相同的物理内存页，并将这些页面标记为只读。调用了fork()之后，内核会捕获所有父进程和子进程针对这些页面的修改企图，并为将要修改的页面创建拷贝。

系统将新的页面拷贝分配给遭内核捕获的进程，还会对子进程的相应页表项做适当调整，从这一刻起，父子进程可以分别修改各自的页拷贝，不再相互影响。



控制进程的内存需求

通过将fork()与wait()组合使用，可以控制一个进程的内存需求。进程的内存需求量，亦即进程所使用的虚拟内存页范围，它会受多种因素影响。例如调用函数或函数返回时栈的变化情况、调用malloc()或free()而对堆做的修改。

```c
int main()
{
    pid_t childId;
    int status;
    
    childId = fork();
    if (childId == -1) {
        perror("fork error");
        exit(-1);
    }
    
    if (childId == 0) {
        exit(func(arg));
    }
    
    if (wait(&status) == -1) {
        exit(-1);
    }
}
```



### fork的竞争条件

