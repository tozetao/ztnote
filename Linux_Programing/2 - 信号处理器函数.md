### handler设计

处理器函数的俩种设计

- 设置全局标志变量

  信号处理器函数设置全局性标志变量并退出。主程序对次标志进行定期检查，一旦置位就采取相应动作。

  主程序若因监控一个或多个文件描述符的I/O而无法进程周期性检查，可以让信号处理器函数向一专用管道写入一个字节的数据，同时将该管道的读取端置于主程序所监控的文件范围之内。

- 信号处理器函数执行某种类型的清理动作，接着进程终止或者使用某种非本地跳转将栈解开并控制返回主程序的预定位置。

一般而言，信号处理函数设计越简单越好，这会降低引发竞争条件的风险。



### 可重入函数（reentrant）

在信号处理器函数中，并非所有系统调用和库函数调用是安全调用的，对于系统调用与库函数可以分为可重入与不可重入俩种类型。



可重入这个概念涉及到多线程，典型的unix程序中都具有一条执行线程，它贯穿程序始终，CPU会围绕着单条执行逻辑来处理指令。而多线程程序中，同一个进程却存在着多条独立、并发的执行逻辑流。

如果同一个进程中的多条线程可以同时安全的调用某一函数，那么该函数就是可重载入的。安全是指多条线程无论如何调用，即使交叉执行，函数都会产生预期结果。



执行逻辑流：我的理解是包含着多条程序指令。



多线程与信号处理器程序有关，对于信号处理器程序，在调用时它会在任一地点异步中断程序的执行，从而形成俩条独立的执行线程，即主程序与信号处理器程序，虽然不是并发的。



### 不可重入函数

使用或者更新全局变量一级静态数据结构的函数是不可重入的，只用到本地变量的函数是可重入的。例如对函数的俩个调用同时视图更新同一个数据结构，俩者可能会互相干扰产生不确定结果。



在C语言标准库函数中，不可重入的可能性很普遍。

像涉及内存分配的malloc()函数族，如果malloc()和free()维护一个已释放内存的链表，如果主程序在调用malloc()期间被一个同样调用malloc()函数的信号处理器程序中断，那么该链表可能会遭到破坏。

还有使用静态分配变量（内存）来返回的函数库也不能使用，例如crypt()、getpwnam()、gethostbyname()以及getservbyname()。如果信号处理程序使用了这些函数，会覆盖主程序调用同一函数的结果。

将静态数据结构用于函数内部的函数库也是不可重入的，最典型的stdio.h库的成员函数，他们会为缓冲区I/O更新数据，如果在信号处理程序中使用printf()，而主程序在调用printf()函数期间被中断，那么有时会看到其他的输出。

不可重入的案例参考nonreentrant.c文件。



### async-signal-safe

异步信号安全的函数是指信号处理器函数在使用这些函数时，可以保证其实现时安全的。如果某一函数是可重入的，又或者信号处理器函数无法将其中断时，那么该函数就是异步安全的。



对于不可重入函数，当信号处理器函数中断了主程序的不可重入函数的执行，且信号处理器成业也使用了改不可重入函数，那么该函数才是不安全的，因此在设计信号处理器程序时有俩种选择：

- 不使用不可重入的函数
- 主程序在使用不可重入函数时或者去操作信号处理器也可能更新的静态数据结构时，阻塞该信号的传递

在一个复杂的程序中第二种实现不叫复杂，因此设计原则是不使用不安全函数的。



### errno

即使在信号处理器程序中使用安全的函数，由于可能会跟新errno，因此也会产生竞争情况。变通的方法时将errno存储起来，在处理器函数代码结尾将其重置回来。

```c
void signal_handler(int sig)
{
    int saved_errno = errno;
    
    // do something
    
    errno = saved_errno;
}
```



### 全局变量

尽管存在可重入问题，然后有时候需要主程序和处理器程序共享全局变量。处理器程序可能会随时修改全局变量，只要主程序能够正确处理全局变量，共享变量就是安全的。

一种常见的设计是：信号处理器只设置全局标志，而主程序周期性的检查该标志，采取相应的动作并清理该全局标志。对于全局标志（变量），需要注意原子性操作方面的问题。

- volatile

  volatile意为易变的，在变量前加上该关键字修饰是告诉编译器，该变量是一个容易改变的变量，不要对它进行优化，每次都到变量的内存地址去读取变量的数据，它可以防止编译器将变量优化到寄存器中。

- sig_atomic_t

  对全局变量的读写可能不止一条机器指令，而信号处理器程序会在这些指令之间将主程序中断，这种现象的操作就叫做非原子性操作，因此C标准定义了一种整型数据类型，可以保证读写操作的原子性。

  注：递增++与递减--操作不在sig_atomic_t的保证范围中，可以做的是在信号处理器进行设置，在主程序中进行检查。



终止信号处理器函数的其他办法

- 使用_exit()进程，处理器函数可以事先做一些清理工作，不要使用exit()来结束进程，它是不可重入函数，执行时会在调用\_exit()之前刷新stdio的缓冲区。
- 使用kill()发送信号杀死进程
- 从信号处理器函数中执行非本地跳转
- 使用abort()函数终止进程，并产生核心存储



### 非本地跳转

从一个函数跳转到该函数的某个调用者，称为非本地跳转。在信处理器程序中使用非本地跳转，不仅可以捕获信号同时可以将控制返回到程序中某个特定位置。

例如shell对Ctrl+C的处理，触发SIGINT信号时会执行非本地跳转将控制返回到主输出循环中。

```c
#include <setjmp.h>

int sigsetjmp(sigjmp_buf env, int savesigs);
void siglongjmp(sigjmp_buf env, int val);
```

sigsetjmp()会保存目前的堆栈环境，然后将目前代码的地址做一个标记，当在其他程序调用siglongjmp()时便会直接跳转到该标记位置，然后还远堆栈继续程序的执行。

env是环境变量，一般是全局变量，如果savesigs不为0，调用sigsetjmp()的进程的当前信号掩码会保存在env参数中，之后通过相同参数的env调用siglongjmp()来恢复；如果savesigs为0则不会保存和恢复进程的信号掩码。



siglongjmp()恢复进程的信号掩码分析：

sigaction()注册一个信号处理器后执行处理器程序时会将触发的信号加入到进行的信号掩码中，而这里的恢复进程信号掩码是指：假定先存储当前进程的信号掩码，且当前进程的信号掩码没有SIGINT，在执行sigaction()注册SIGINT信号处理器后，SIGINT就被阻塞了（添加到进程掩码中），那么siglongjmp()恢复后进程掩码后，SIGINT就相当于解除阻塞了。



### abort()

```c
#include <stdlib.h>

void abort(void);
```

函数abort()终止其调用进程，并生成核心转储。它是通过产生SIGABRT信号来终止调用进程，对SIGABRT的默认动作是产生核心转储文件并终止进程，转储文件可用于调试检查调用abort()时的程序状态。



SUSv3要求，无论阻塞或忽略SIGABRT信号，abort()调用都不会受到影响。除非捕获信号后处理器程序并未返回，否则abort()必定终止进程。这句话意思是处理器程序中执行了非本地跳转，它会抵消abort()的效果。

abort()终止时，如果进程在发出一次SIGABRT信号后仍未终止，则abort()会对SIGABRT信号的处理重置为SIG_DEL，并再次发出SIGABRT信号，确保杀死进程。终止进程后会刷新stdio流并将其关闭。







