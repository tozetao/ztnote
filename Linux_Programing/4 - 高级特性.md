### 特定信号的处理与传递

- SIGKILL和SIGSTOP

  SIGKILL信号默认行为是终止一个进程，SIGSTOP信号的默认行为是停止一个进程。俩者的默认行为是无法改变的，试图使用signal()或signaction()来注册信号处理器程序会一直返回错误。

  不允许改变这些信号的行为是为了能够杀死或停止一个失控进程。

- SIGCONT

  不是很懂，后续再看。



### 进程睡眠状态

内核会经常令进程进入休眠，而休眠状态分为俩种：

- TASK_INTERRUPTIBLE

  可中断的进程睡眠状态，进程正在等待某一事件。

  例如在等待终端输入，等待数据写入当前的空管道，进程在该状态下耗费的时间可长可短，如果为这种状态下的进程产生一个信号，那么操作将中断，而传递来的信号将唤醒进程。

  ps命令在显示处于TASK_INTERRUPTIBLE状态的进程，会将STAT字段标记为S

- TASK_UNINTERRUPTIBLE

  不可中断的睡眠状态，进程正在等待某些特定类型的事件。

  比如磁盘I/O的完成，如果为这种状态下的进程产生一个信号，那么在进程摆脱这种状态之前，系统将不会把信号传递给进程。

  ps命令显示这类进程的STAT字段是标记为D。

- TASK_KILLABLE

  内核在2.6.25新增的状态，用于解决因硬件故障或内核缺陷挂起的进程而SIGKILL信号无法杀死该进程的情况。



### 信号的生成方式





### 信号的传递时机

一个未阻塞信号是在什么时候传递的？

同步产生的信号会立即传递。例如硬件异常触发的一个即时信号，或者进程例如raise()向自身发送信号时，信号会在raise()调用返回之前就已经发出。

异步产生一个信号时，即使该信号未将其阻塞，在信号的产生和传递之间仍然可能会有一个瞬间的延迟，在延迟期间，信号处于等待状态。

这是因为内核将等待信号传递给进程的时机是该进程正在执行，且发生在由内核状态向用户状态的下一次切换时，意思是：

- 进程在前一次调度超时后，再次获得调度时，即获得一次时间片段的执行

- 系统（函数）调用完成时；信号的传递可能会引起正在阻塞的系统调用提前结束。

  内核状态转换成用户状态？？



解除对多个信号的阻塞时，信号的传递顺序是怎样的？

当进程调用sigprocmask()解除对多个等待信号的阻塞时，这些信号会立刻传递给该进程。多个信号的传递顺序由系统实现，例如linux系统实现是按照信号编号按照升序来传递信号。

而当多个解除了阻塞的信号正在等待传递时，如果在信号处理器函数执行期间发生了内核态与用户态的切换，那么将中断此处理器函数的执行，转而去调用第二个信号处理器函数，以此递进。

例如：

- 某个进程产生了SIGINT、SIGQUIT信号，而进程解除对SIGINT、SIGQUIT信号的阻塞
- 内核调用SIGINT信号的处理器函数
- SIGINT信号的处理器函数发起了一个系统调用
- 内核调用SIGQUIT处理器函数
- 结束SIGQUIT信号处理程序、结束SIGINT信号处理器程序，回到进程处理程序。

