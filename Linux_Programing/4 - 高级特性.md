### 特定信号的处理与传递

- SIGKILL和SIGSTOP

  SIGKILL信号默认行为是终止一个进程，SIGSTOP信号的默认行为是停止一个进程。俩者的默认行为是无法改变的，试图使用signal()或signaction()来注册信号处理器程序会一直返回错误。

  不允许改变这些信号的行为是为了能够杀死或停止一个失控进程。

- SIGCONT

  不是很懂，后续再看。



### 进程睡眠状态

内核会经常令进程进入休眠，而休眠状态分为俩种：

- TASK_INTERRUPTIBLE

  可中断的进程睡眠状态，进程正在等待某一事件。

  例如在等待终端输入，等待数据写入当前的空管道，进程在该状态下耗费的时间可长可短，如果为这种状态下的进程产生一个信号，那么操作将中断，而传递来的信号将唤醒进程。

  ps命令在显示处于TASK_INTERRUPTIBLE状态的进程，会将STAT字段标记为S

- TASK_UNINTERRUPTIBLE

  不可中断的睡眠状态，进程正在等待某些特定类型的事件。

  比如磁盘I/O的完成，如果为这种状态下的进程产生一个信号，那么在进程摆脱这种状态之前，系统将不会把信号传递给进程。

  ps命令显示这类进程的STAT字段是标记为D。

- TASK_KILLABLE

  内核在2.6.25新增的状态，用于解决因硬件故障或内核缺陷挂起的进程而SIGKILL信号无法杀死该进程的情况。



### 信号的生成方式

按照信号的产生方式，可以分为同步生成与异步生成。

- 异步生成

  引发信号产生的事件，无论信号发送者是内核还是另一进程，其发生与进程的执行无关，这种方式产生的信号就是异步生成的。

  例如用户输入中断字符，或者子进程终止。

- 同步生成

  信号的产生是由进程本身的执行造成的就叫同步生成。

  例如指向特定的机器语言导致的硬件异常而产生的信号；进程使用raise()、kill()、killkg()向自身发送的信号，这种情况下信号的产生就是同步的，会立即传递信号，除非该信号遭到阻塞。

要记住同步与异步指描述信号的产生方式，而不是针对信号本身，所有信号即可以同步产生也可以异步产生。





### 信号的传递时机

一个未阻塞信号是在什么时候传递的？

同步产生的信号会立即传递。例如硬件异常触发的一个即时信号，或者进程例如raise()向自身发送信号时，信号会在raise()调用返回之前就已经发出。

异步产生一个信号时，即使该信号未将其阻塞，在信号的产生和传递之间仍然可能会有一个瞬间的延迟，在延迟期间，信号处于等待状态。

这是因为内核将等待信号传递给进程的时机是该进程正在执行，且发生在由内核态向用户态的下一次切换时，意思是：

- 进程在前一次调度超时后，再次获得调度时，即获得一次时间片段的执行

- 系统（函数）调用完成时。

  要注意的是，信号的传递可能会引起正在阻塞的系统调用提前结束。



解除对多个信号的阻塞时，信号的传递顺序是怎样的？

当进程调用sigprocmask()解除对多个等待信号的阻塞时，这些信号会立刻传递给该进程。多个信号的传递顺序由系统实现，例如linux系统实现是按照信号编号按照升序来传递信号。

而当多个解除了阻塞的信号正在等待传递时，如果在信号处理器函数执行期间发生了内核态与用户态的切换，那么将中断此处理器函数的执行，转而去调用第二个信号处理器函数，以此递进。

例如：

- 某个进程产生了SIGINT、SIGQUIT信号，而进程解除对SIGINT、SIGQUIT信号的阻塞
- 内核调用SIGINT信号的处理器函数
- SIGINT信号的处理器函数发起了一个系统调用
- 内核调用SIGQUIT处理器函数
- 结束SIGQUIT信号处理程序、结束SIGINT信号处理器程序，回到进程处理程序。



## 实时信号

实时信号定义在POSIX.1b文件中，它有以下特点：

- 范围

  实时信号的信号范围比标准信号的范围要大，标准信号可随意使用的信号只有SIGUSR1和SIGUSR2。

- 队列管理

  如果将某个实时信号的实例发送多次给某一进程，那么将会多次传递该信号；相反某一标准信号已经在等待某一进程，即使向该进程多次发送此信号的实例，信号也只会传递一次。

- 可携带数据

  当发送一个实时信号时，可为该信号指定携带数据，供接收进程的信号处理器函数处理，携带的数据只能是一个整形数或指针值。

- 传递顺序的保证

  不同实时信号的传递顺序可得到保障，如果有多个不同的实时信号处于等待状态，那么最先传递最小编号的信号，信号的编号越小则优先级越高。

  如果同一类型的多个信号在排队，那么信号的传递顺序与信号发送来的顺序是一致的。

SUSv3要求实现所提供的各种实时信号不得少于\_POSIX\_RTSIG_MAX（定义为8）个，linux内核定义了32个不同的实时信号，编号范围32-63。

在<signal.h>头文件，定义了实时信号的相关常量，RTSIG_MAX表示实时信号的可用数量；SIGRTMIN表示可用实时信号的最小值；SIGTRMAX表示可用实时信号的最大值。

在使用实时信号时，不要将实时信号编号的整型值在代码中写死，因为不同的unix系统有不同的实现。指定实时信号的编号可用SIGTRMIN+x的形式。

同时SIGTRMIN与SIGTRMAX不一定是整型值，也可能是函数实现，因此不能编码代码给预处理器处理：

```c
#if SIGTRMIN + 100 > SIGTRMAX
#error "wot enough relatime signals"
#endif
```



### 排队的限制

排队的实时信号及其携带数据需要内核维护相应的数据结构，用于罗列每个进程的排队信号。由于这些数据结构会消耗内存，因此内核对排队的实时信号的数量作了限制。

SUSv3允许实现为每个进程可排队的各类实时信号数量设置上限，并要求不得少于\_POXIS_SIGQUEUE\_MAX（定义为32）。

```c
int limit = sysconf(_SC_SIGQUEUE_MAX);
// 查看内核允许的排队实时信号的最大数量
```



### 使用实时信号

为了能让一对进程收发实时信号，SUSv3要求：

- 收发进程使用sigqueue()系统调用来发送信号及携带数据

  因为使用kill()、raise()调用发送的实时信号，收发信号的排队处理时依赖于系统实现的，有些unix系统并未实现信号的排队处理。

- 要为该信号建立一个处理器函数，接收进程应以SA_SIGINFO标志发起对sigaction()的调用，这样调用处理器函数就会附带额外参数，其中就包括实时信号携带的数据。

```c
#define _POSIX_C_SOURCE 199309
#include <signal.h>

int sigqueue(pid_t pid, int sig, const union sigval value);
// returns 0 on success, or -1 on error. 

union sigval {
    int sival_int;
    void *siva_ptr;
}
```

使用sigqueue()发送信号的权限与kill()的要求相同，也可以发送空信号（即信号0），但是不能讲pid指定为负值向整个进程组发送信号。

参数value是sigval联合体，指定携带的数据，sival_ptr属性比较少使用，因为指针的作用范围是在进程内部，对另一进程是没有意义的。

如果超出排队信号的数量限制，sigqueue()调用会失败，并将errno置为EAGAIN。





### 处理实时信号

```c
struct sigaction act;

sigemptyset(&act.sa_mask);
act.sa_sigaction = handler;
act.sa_flags = SA_RESTART | SA_SIGINFO;
```

在使用SA_SIGINFO标志后，传递给处理器函数的第二个参数将会是一个siginfo_t结构体，包含实时信号的附加信息。

对于一个实时信号，会在siginfo_t结构中设置以下字段：

- si_signo字段，实时信号的值
- si_code，表示信号来源，对于通过sigqueue()发送的实时信号，值总是为SI_QUEUE。
- si_value，发送方进程发送信号携带的数据，即sigval union联合体。
- si_pid和si_uid分别表示发送方的进程id和实际用户id

