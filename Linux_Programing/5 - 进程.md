进程是一个可执行程序的实例。



### 程序

程序是一系列信息的文件，这些信息描述了如何在运行时创建一个进程，具体内容包括：

- 二进制格式标识

  每个程序文件都包含用于描述可执行格式的元信息，内核利用此信息来解释文件中的其他信息。

- 机器语言指令

  对程序算法进行编码

- 程序入口地址

  标识程序开始执行时的起始指令位置

- 数据

  程序文件包含的变量初始值和字面常量（literal constant）

- 符号表和重定向表

   描述程序中函数和变量的位置及名称。这些表格有多种用途，其中包括调试和运行时的符号解析（动态链接）

- 共享库和动态链接信息

  程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态链接器的路径。

- 其他略

进程就是内核抽象的一个实体，并且会为该实体分配用以执行程序的各种资源。可以用一个程序来创建许多进程，或者说许多进程运行的是同一程序。



### 进程

进程是由内核定义的抽象的实体，并未该实体分配用以执行程序的各项系统资源。

在内核角度来看，进程由用户内存空间（user-space memory）和一系列内核数据结构组成。用户内存空间包含程序代码和代码使用的变量，而内核数据结构用以维持进程状态信息。

记录在内核数据结构的信息有：进程相关标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递以及处理的有关信息、进程资源使用限制等大量信息。



### 进程ID

```c
#include <unistd.h>

pid_t getpid(void);
```

获取一个进程的pid。

每个进程都有一个进程号，它是一个正数。linux内核创建一个进程时，会分配下一个可用的进程号给其使用，在linux2.4之前的版本32位平台的进程号是小于等于32767，linux2.6版本的64位平台的进程号最大值可达$2^{22}$，如果进程号超过最大值，那么将会重置到300再循环使用。

除了少数系统进程外，程序与运行该程序的进程号无任何关系，一般的分配1-300给系统进程和守护进程使用。



```c
#include <unistd.h>

pid_t getppid(void);
```

返回一个进程的父进程id。

每个进程的父进程号属性反应了系统上所有进程间的树状关系，进程的始祖进程是init进程。如果父进程终止则子进程会变成孤儿进程，init进程随后会接管该子进程。



### 进程内存布局

每个进程所分配的内存由很多部分组成，一般称为段（segment），具体有：

- 文本段

  包含进程运行的程序机器语言指令，文本段具有只读的，这是为了防止进程错误的指针修改到指令；因为多个进程可同时运行同一程序，所以文本段是共享的，这样一份程序代码的拷贝就可以映射在多个进程的虚拟内存空间。

- 初始化数据段

  包含程序显式初始化的静态变量和全局变量，程序在加载到内存时就会从可执行文件中读取这些变量的值。

- 未初始化数据段

  包含未进行显式初始化的静态变量与全局变量，程序启动之前系统会将本段全部初始化为0，该段也被称为BSS。

  将经过初始化的静态变量、全局变量和未初始化过的静态变量、全局变量分开，主要是因为程序存储在磁盘时没必要为未初始化的静态变量和全局变量分配空间，可执行文件只需要记录未初始化数据段的位置和所需大小，直到运行时再由程序加载器来分配这一空间。

- 栈

  栈是由栈帧组成，它是一个动态增长和收缩的段。

  系统会为每个当前调用的函数分配一个栈帧，栈帧中存储了函数的局部变量（自动变量）、实参和返回值。

- 堆

  堆是一块可在运行时动态的进行内存分配的区域，堆顶称为program break。

在x86-32体系结构中，各个段的布局从上到下粉笔是：

- argv、environ，顶部空间，用于存储程序命令行实参和进程环境列表。
- 栈，向下增长
- 堆，向上增长，栈与堆之间的是尚未分配的内存。
- 未初始化数据段
- 初始化数据段
- 文本数据（文本段）

注：对于频繁使用的变量，编译器优化时会将其分配到寄存器中。

```c
#include <stdio.h>
#include <stdlib.h>

char globBuf[65535];	//未初始化数据段
int ptimes[] = {1, 2, 3, 4, 5};	//已初始化数据段

static int square(int x)	//在栈中为square()函数分配
{
    int result;				//存储在square()函数栈帧中
    result = x * 2;
    return result;
}

int main()
{
    static int len = 900;	//已初始化数据段
    char *p;		//存储在main()函数栈帧中
    p = malloc(1024);	//指向堆中的内存空间
    return 0;
}
```







### 虚拟内存管理

虚拟内存管理技术的特点

- 略



虚拟内存的规划之一是将每个程序使用的内存划分成固定大小的页（page），相应的RAM也会被划分成与虚拟页尺寸大小相同的页帧。

为了使虚拟页与页帧相对应，内核会为每个进程维护一张页表（page table），该表描述每页虚拟页在进程虚拟地址空间（virtual address space）中位置；同时页表中的每个条目会指出虚拟页在RAM中的所在位置或者在磁盘上的位置。



在进程的生命周期中，虚拟地址范围是会发生变化的，这是因为内核能够为进程分配和释放页和页表条目，例如：

- 由于栈向下发展超出之前到达的位置
- 堆分配或释放内存时
- 调用mmap()创建内存映射，或者调用munmap()解除内存映射



进程的虚拟地址空间与RAM物理地址空间分隔会有以下优点：

- 进程与进程、进程与内核相互隔离，一个进程不能修改另一进程或内核的内存，这是因为进程各自的页表条目指向RAM中不同的物理页面集合。

- 实现内存保护机制

  针对页面的每个条目，可以标记每个条目的读写性质。多个进程共享RAM页面时，允许每个进程对内存采取不同的保护措施，例如同一个页面，一个进程可能以只读访问某页面，另一进程可能以读写方式访问该页面。

- 适当情况下可共享内存

  这是因为内核允许不同进程的页面指向相同的RAM页。

上述优点有空再补充吧，感觉理解概念没什么用。。。



### 栈帧

函数的调用和返回会使栈的增长和收缩成线性，在X86-32体系架构的系统中，栈位于内存的高端并向下增长。

每次调用函数时，会在栈上新分配一帧，每当函数返回时再从栈上将此帧移除掉。

每个栈帧包括如下信息：

- 函数实参和局部变量

  由于这些变量是在调用函数时自动创建的，因此C语言中称其未自动变量，函数返回时会自动销毁这些变量，因为栈帧会被释放。

  这些局部变量与静态变量的语义区别，静态变量与函数无关且长期存在。

- 函数调用的链接信息

  每个函数都会用到一些CPU寄存器，例如程序计数器，它指向下一条要执行的机器指令。

  每当一函数调用另一函数时，会在被调用函数的栈帧中保存寄存器的副本，以便函数返回时能够是调用者恢复寄存器状态。



### 环境列表

environment list，每个进程都有一个被称为环境列表的字符串数组，它是名称与值的成对集合。



新进程在创建时会继承其父进程的环境副本，环境提供了一种将信息从父进程传递给子进程的方法，由于子进程只有在创建之时才能获取父进程的环境变量副本，因此数据的传输是单向的且互不影响的，父子进程修改环境变量都不会影响到对方。



获取环境列表

全局变量char \*\*environ可用于访问环境列表，在C运行启动时便会定义该变量并以环境列表为其赋值。environ与argv参数类似，指向一个以NULL结尾的指针列表，而每个字符指针又以空字节终止。



```c
#include <stdlib.h>
char *getenv(const char *name);
```

getenv()能够从进程环境中检索某个值，name参数是环境变量名称，成功会返回相应的字符串指针，如果没有该环境变量会返回NULL。

注：该函数是用静态分配的缓冲区返回结果，后续对getenv()、setenv()、putenv()或者unsetenv()的函数调用可以重写该缓冲区，如果要使用返回的结果，建议进行复制使用。



```c
#include <stdlib.h>

int putenv(char *string);
//Returns 0 on success, or -1 on error.
```

修改一个进程的环境列表对其后续创建的所有子进程都是可见的。

putenv()会向调用进程的环境中添加一个新变量，或者修改一个已经存在的变量值。

string参数是name=value形式的字符串指针，函数调用会将环境变量中某个元素的指针与string参数的指针相同，因此string参数必须是全局变量。



```c
int setenv(const char *name, const char *value, int overwrite);
```

setenv函数会分配一块内存缓冲区，并将name与value所指向的字符串复制到该缓冲区，以此来创建一个新的环境变量，缓冲区的值是name=value形式的字符串。

若name标识的变量已在环境中存在，且overwrite参数的值为0，则setenv()将不改变环境，如果非0总是改变环境。



```c
int unsetenv(char *name);
```

清除某个环境列表中某个元素。







### 命令行参数









