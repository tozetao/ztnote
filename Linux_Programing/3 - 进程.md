进程是一个可执行程序的实例。



### 程序

程序是一系列信息的文件，这些信息描述了如何在运行时创建一个进程，具体内容包括：

- 二进制格式标识
- 机器语言指令
- 程序入口地址
- 数据：变量初始值和字面量
- 符号表和重定向表
- 共享库和动态链接信息
- 其他略

可以用一个程序来创建许多进程，或者说许多进程运行的是同一程序。



### 进程

进程是由内核定义的抽象的实体，并未该实体分配用以执行程序的各项系统资源。

在内核角度来看，进程由用户内存空间（user-space memory）和一系列内核数据结构组成。用户内存空间包含程序代码和代码使用的变量。内核数据结构用以维持进程状态信息，记录在内核数据结构的信息有：进程相关标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递以及处理的有关信息、进程资源使用限制等大量信息。



### 进程号

```c
#include <unistd.h>

pid_t getpid(void);
```

获取一个进程的pid。

每个进程都有一个进程号，它是一个正数。linux内核创建一个进程时，会分配下一个可用的进程号给其使用，在linux2.4之前的版本32位平台的进程号是小于等于32767，linux2.6版本的64位平台的进程号最大值可达$2^{22}$，如果进程号超过最大值，那么将会重置到300再循环使用。

除了少数系统进程外，程序与运行该程序的进程号无任何关系，一般的分配1-300给系统进程和守护进程使用。



```c
#include <unistd.h>

pid_t getppid(void);
```

返回一个进程的父进程id。

每个进程的父进程号属性反应了系统上所有进程间的树状关系，进程的始祖进程是init进程。如果父进程终止则子进程会变成孤儿进程，init进程随后会接管该子进程。



### 进程内存布局

每个进程所分配的内存是由很多段（segment）组成，包括有：

- 文本段

  包含进程运行的程序机器语言指令，文本段是只读的，这是为了防止进程错误的指针修改到指令；文本段是共享的，一份程序代码的拷贝可以映射到所有这些进程的虚拟地址空间。

- 初始化数据段

  包含程序显式初始化的静态变量和全局变量，程序在加载到内存时就会从可执行文件中读取这些变量的值。

- 未初始化数据段

  包含未进行显式初始化的静态变量与全局变量，程序启动之前系统会将本段全部初始化为0，该段也被称为BSS。

  将静态变量、全局变量初始化和未初始化分开，主要是因为程序存储在磁盘时没必要为未初始化的静态变量和全局变量分配空间，程序运行时再分配存储空间即可。

- 栈

  栈是由栈帧组成，它是一个动态增长和收缩的段。

- 堆

  可在运行时为变量动态进行内存分配的一块区域，堆顶称为program break。

对于初始化和未初始化的数据段而言，表达更信息的称谓分别是用户初始化数据段（user-initialized data）和零初始化数据段（zero-initialized data）。



注：对于频繁使用的变量，编译器优化时会将其分配到寄存器中。



在x86-32体系结构中，各个段的布局从上到下分别有：

- argv、environ，顶部空间，用于存储程序命令行实参和进程环境列表。
- 栈，向下增长
- 堆，向上增长，栈与堆之间的是尚未使用分配的内存。
- 未初始化数据段
- 初始化数据段
- 文本数据（文本段）





### 虚拟内存管理

虚拟内存的规划之一是将每个程序使用的内存划分成小型的、固定大小的页（page），相应的RAM也会划分成与虚拟内存页大小尺寸相同的页帧。



虚拟地址空间（virtual address space）：可为进程所用的所有虚拟内存页面的集合，即进程可用的虚拟内存。

虚拟内存页：将虚拟地址空间（虚拟内存）划分为固定大小的页。



为了让虚拟页与RAM页帧对应起来，内核会为每个进程维护一张页面（page table），页表描述了每页（虚拟内存的页）在进程虚拟地址空间中的位置，页表中的每个条目要么指出虚拟页面在RAM中的位置，要么表明表明虚拟页是在磁盘上的（swap）。



由于内核能够为进程分配、释放页、页表条目，所以进程的有效虚拟地址范围在其生命周期内可以发生变化，例如：

- 由于栈向下发招超出之前到达的位置
- 堆分配或释放内存时
- 调用mmap()创建内存映射，或者调用munmap()解除内存映射

这些操作都会影响虚拟地址的范围。



虚拟内存管理将虚拟地址空间与物理地址空间隔离的优点：

- 进程与进程、进程与内核相互隔离，一个进程不能修改另一进程或内核的内存，这是因为各自的页表所指向物理页面是不同的。
- 实现内存保护机制，针对页面的每个条目，可以标记每个条目的读写性质。多个进程共享RAM页面时，允许每个进程对内存采取不同的保护措施，例如同一个页面，一个进程可能以只读访问某页面，另一进程可能以读写方式访问该页面。
- 适当情况下的共享内存，这是因为内核允许不同进程的页面指向相同的RAM页。



注：虚拟内存的实现需要硬件中分页内存管理单元（PMMU）的支持，PMMU会把要访问的虚拟内存地址转换成相应的物理内存地址，如果虚拟内存地址对应的页没有在RAM中时，会报页面错误通知内核。



### 栈帧

函数的调用和返回会使栈的增长和收缩成线性，在X86-32体系架构的系统中，栈位于内存的高端并向下增长。

每次调用函数时，会在栈上新分配一帧，每当函数返回时再从栈上将此帧移除掉。

每个栈帧包括如下信息：

- 函数实参和局部变量

  由于这些变量是在调用函数时自动创建的，因此C语言中称其未自动变量，函数返回时会自动销毁这些变量，因为栈帧会被释放。

  这些局部变量与静态变量的语义区别，静态变量与函数无关且长期存在。

- 函数调用的链接信息

  每个函数都会用到一些CPU寄存器，例如程序计数器，它指向下一条要执行的机器指令。

  每当一函数调用另一函数时，会在被调用函数的栈帧中保存寄存器的副本，以便函数返回时能够是调用者恢复寄存器状态。



命令行参数



环境列表

environment list，每个进程都有一个被称为环境列表的字符串数组，它是名称与值的成对集合。



新进程在创建时会继承其父进程的环境副本，环境提供了一种将信息从父进程传递给子进程的方法，由于子进程只有在创建之时才能获取父进程的环境变量副本，因此数据的传输是单向的且互不影响的，父子进程修改环境变量都不会影响到对方。



获取环境列表

全局变量char \*\*environ可用于访问环境列表，在C运行启动时便会定义该变量并以环境列表为其赋值。environ与argv参数类似，指向一个以NULL结尾的指针列表，而每个字符指针又以空字节终止。



```c
#include <stdlib.h>
char *getenv(const char *name);
```

getenv()能够从进程环境中检索某个值，name参数是环境变量名称，成功会返回相应的字符串指针，如果没有该环境变量会返回NULL。

注：该函数是用静态分配的缓冲区返回结果，后续对getenv()、setenv()、putenv()或者unsetenv()的函数调用可以重写该缓冲区，如果要使用返回的结果，建议进行复制使用。



```c
#include <stdlib.h>

int putenv(char *string);
//Returns 0 on success, or -1 on error.
```

修改一个进程的环境列表对其后续创建的所有子进程都是可见的。

putenv()会向调用进程的环境中添加一个新变量，或者修改一个已经存在的变量值，函数调用会将环境变量中某个元素的指向与string参数的指向相同，因此string参数必须是全局变量。

















