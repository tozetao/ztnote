### handler设计

处理器函数的俩种设计

- 设置全局标志变量

  信号处理器函数设置全局性标志变量并退出。主程序对次标志进行定期检查，一旦置位就采取相应动作。

  主程序若因监控一个或多个文件描述符的I/O而无法进程周期性检查，可以让信号处理器函数向一专用管道写入一个字节的数据，同时将该管道的读取端置于主程序所监控的文件范围之内。

- 信号处理器函数执行某种类型的清理动作，接着进程终止或者使用某种非本地跳转将栈解开并控制返回主程序的预定位置。

一般而言，信号处理函数设计越简单越好，这会降低引发竞争条件的风险。



### 可重入函数（reentrant）

在信号处理器函数中，并非所有系统调用和库函数调用是安全调用的，对于系统调用与库函数可以分为可重入与不可重入俩种类型。



可重入这个概念涉及到多线程，典型的unix程序中都具有一条执行线程，它贯穿程序始终，CPU会围绕着单条执行逻辑来处理指令。而多线程程序中，同一个进程却存在着多条独立、并发的执行逻辑流。

如果同一个进程中的多条线程可以同时安全的调用某一函数，那么该函数就是可重载入的。安全是指多条线程无论如何调用，即使交叉执行，函数都会产生预期结果。



执行逻辑流：我的理解是包含着多条程序指令。



### 不可重入函数

更新全局变量或静态数据结构的函数是不可重入的，只用到本地变量的函数是可重入的。例如对函数的俩个调用同时视图更新同一个数据结构，俩者可能会互相干扰产生不确定结果。



在C语言标准库函数中，不可重入的可能性很普遍。

像涉及内存分配的malloc()函数族，如果malloc()和free()维护一个已释放内存的链表，如果主程序在调用malloc()期间被一个同样调用malloc()函数的信号处理器程序中断，那么该链表可能会遭到破坏。

还有使用静态分配变量（内存）的函数库也不能使用，例如crypt()、getpwnam()、gethostbyname()以及getservbyname()。如果信号处理程序使用了这些函数，会覆盖主程序调用同一函数的结果。

将静态数据结构用于函数内部的函数库也是不可重入的，最典型的stdio.h库的成员函数，他们会为缓冲区I/O更新数据，如果在信号处理程序中使用printf()，而主程序在调用printf()函数期间被中断，那么有时会看到其他的输出。



总结：使用或返回静态分配变量的函数，都是不可重入的。









多线程与信号处理器程序有关，对于信号处理器程序，在调用时它会在任一地点异步中断程序的执行，从而形成俩条独立的执行线程，即主程序与信号处理器程序，虽然不是并发的。







异步信号安全函数（async-signal-safe）