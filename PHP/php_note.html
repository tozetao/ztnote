<!-- 

	19 对象的比较
		==：比较对象的类型、对象的属性个数和属性的值是否相等。
		===：比较对象的内存地址是否相等。

	20. 对象操作
		20.1 对象序列化
			序列化，将一个数据类型按照其结构变成对应的字符串的过程。
			serialize($obj)
			$obj：对象

			文件保存内容：O:6:"Person":2:{s:4:"name";s:5:"zetao";s:3:"age";i:12;}
			O：代表对象
			6:"Person"，表示6个长度的Person类
			2，表示属性个数。
			s:4:"name"，4个长度的string类型的属性名

		17.3 对象反序列化
			unserialize($str)
			将对应的字符串，反过来构造成原来的数据类型
			$str：字符串。

			系统反序列化的时候，会尝试去找Person类，如果没找到，系统会自动回收到自己门下，变成不完整类的对象
			一旦Person类存在，类被加载到内存，系统就会反序列化成对应类的对象。

			PS：必须保证对应的类被加载，如果没加载，是不完整的系统类的对象。
		
		3.3 反序列化自动加载

			$str=file_get_contents("文件路径");
			$obj=unserialize($str);//反序列化
			//重写自动加载方法
			function __autoload($name){
				if(is_file("{$name}.class.php")){
					include("{$name}.class.php");
				}
			}
		
		3.4 反序列化过程
			a.去代码区寻找对应的类文件Person，如果没有找到就归属于__PHP_Incomplete_class类下
			b.通过找到的类创建一个对象(会将类中所有属性都在对象空间创建一次)
			c.将保存的对象里的属性进行覆盖操作，
				个人理解：这里是读取后的数据对已经创建的对象进行数据的覆盖。
			d.最终得到的结果就是新对象+旧数据
		
		4. 资源对象的保存与读
		资源都不能被保存。
		如果new一个DB类，保存的时候，link资源就没办法保存。
		因为PHP脚本执行结束，释放所有变量，资源不存在，所以在序列化的时候，系统自动将资源进行整型转换，转换成0表示资源不存在。
		4.1 __sleep()
			当对象被当作文件保存时会自动触发的方法。
			该方法要做的事情，就是返回一个要保存的对象数据的数组。
			example7
			$db=new DB;
			
			//修改DB类，重载__sleep()方法
			public function __sleep(){
				return array("host","port","user","pwd","dbname");
				//返回需要保存对象属性的数组。
			}
		4.2 __wakeup()
			当对象是从文件里读出来进行反序列化得到对象的时候，会自动触发的方法
			wakeup

			$obj=unserialize(file_get_contents($filename));//反序列化对象
			//var_dump($obj);//这里是没有link资源的。
			

			//所以重写DB类的wakeup方法，在这里获取连接资源，赋值给反序列化对象。
			public funtcion __wakeup(){
				$this->connect();
				$this->setChar();
				//在这里使用方法的使用
			}
		17.4 对象循环

三、其他
	1. 进制
		10进制，逢10进1.
		
			153
			3：以1顶1
			5：以1顶10
			1：以1顶100，即10个10
			所以是100+50+3，即153.
		
		为什么会这样？不可能有那么多符号给我们来表示数的大小。

		8进制，封8进1，在php中，以0代表8进制
		example：
			0153
			3：以1顶1
			5：以1顶8，
			1：以1顶8*8=64

			即3*8^0+5*8^1+3*8^2
		
		16进制，封16进1，在php中，以0x代表16进制

		无论是什么进制，次方的表示总是从右边数起，以0次方开始递增计算。



		2进制，封2进1，php目前不支持表示。
		从右到左，分别以1顶1，顶2，顶4，顶8...
		example：
			10进制	2进制
			5		0000 0101		->因为计算机中，1个bytes=8bit
			255		1111 1111，128+64+32+16+8+4+2+1

		example
			10进制		2进制
			-1

		补码：
			有一个圆圈，以1作为一个单位，有256格，是以0-255表示。
			正数的255就是在0的左边1个单位。
			负数的-1也是在0的左边1个单位，相当于255-256。

			由于他们的绝对位置重合，所以-1的二进制也是等于1111 1111。
			那么数字到底理解成整数还是负数，取决于程序。

			在mysql中，对于1111 1111，你可以告诉他这是一个普通int，或unsigned int
			255
			int：-1
			unsigned int：无符号，理解成255

			






			11000111

			1*2^0+1*2^1+1*2^2+0+0+0+1*2^6+1*2^7
			
			

	2. 关于位运算符
		把位的0/1当成假/真，针对每个位的逻辑运算，就是位运算。
		把字节拆成位，针对每个位来进行逻辑运算。

		10进制	2进制
		5		0000 0101		->因为计算机中，1个bytes=8bit
		12		0000 1100，8+4+1
		&-----------------------逻辑与运算，11为1，01为0
				0000 0100
		|-----------------------逻辑或运算，11为1，01为1，00为0
				0000 1101
		^-----------------------异或运算，俩者必须不一样才为真，一致为假
				0000 1001
		echo 5 & 12;	//输出4
		echo 5 | 12;	//输出13
		echo 5 ^ 12;	//9
		
		//0000 0101 -> 11111010
		echo ~5;		//输出-6，//逻辑反运算，1变成，0变成1.

		位移运算，用于将整数增大或缩小一定的倍数。
		左移：变大一定的倍数，如10进制，左移3位，扩大1*10的3次方倍数
		右移：缩小一定的倍数，如10进制，右移2位，缩小1*2的2次方倍数，即x/10*10=x/100


		example：10进制的3，进行位运算
		2进制
		0000 0011	左移1位	0110，=4+2=6，	相当于扩大2的1次方倍数，即3*2^1=6
		0000 0011	右移1位 0001,=1，	相当于缩小2的1次方倍，即3/2^1=1.5

	3. 位运算与php错误报告设置

		php脚本的错误，分多个等级，如致命错误，notice，warning,n多级别

		php把不同等级的级别，用数字来表示，如
		1 E_ERROR(integer)	致命的运行错误，这类错误是不可恢复的情况，后果会导致脚本终止
		2	E_WARNING(integer)	运行时警告，
		4
		8
		16
		32

		0000 0001
		0000 0010
		0000 0100
		0000 1000

		这是错误的数字都是2的N次方，都可以转换成二进制。
		这些二进制数字的规律：不同级别的数字对应不同位数上的1.

		综上，像报告所有错误，可以把所有错误的级别 a | b | c...

		30719，所有2进制数合并后的结果。

		//设置报告所有错误
		error_reporting(E_ALL);
		error_reporting(1111 1111);	这是错误的。
		//不报告错误
		error_reporting(0);
		//报告所有错误，唯独notice的错误
		//由于2进制无法在php中显示，所以要进行位运算
		E_NOTICE=8		0000 0100
		E_ALL=30719		1111 1111

		让第三位为0，所以使用异或运算
		error_reporting(E_ALL ^ E_NOTICE);

		或者 ~E_NOTEC，给notice取反，然后逻辑与计算
		E_ALL & ~E_NOTICE

	4. 逻辑运算的短路特性与运算符的优先级
		一旦程序能判断这个表达式的结果，后边的程序就不会执行，也就是短路了。

		//利用短路写出简短的判断代码
		if(!defined(name)){
			define(name,var);
		}

		defined("PI") || define('PI',3.14);


		-------------------------------------
		$house=false;
		$car=true;
		if($house && $car){//房子已经为false，又用并且计算，结果为false，所以程序不会去判断car的值。，这个兼作逻辑运算的短路特性。
		}else{
		}
		
		$b=1;
		example：
			if($house && ($b=6)){ b=6被短路，没机会执行。
			}else{
			}

			echo $b;	//输出1

		example：
			if($house && ($b=6)){
			}
			echo $b;
			

	5. 浮点数不精确
		if(0.3-0.2==0.1){
			echo xiangdeng;
		}else{
			echo budeng;	//输出不等
		}

		10进制：3.1，是3*10^0 + 1*10^-1

		3进制：1.1，是1*3^0 + 1*3^-1	//对于10进制 1.333333...无限循环，所以会对后面的数字进行舍入。

		10进制		2进制
		0.5			0.1
		0.8			0.1110000。。。。

		某些小数在10进制下，是优先的，而转成2进制要无限循环，因此会损失一些精度，导致浮点数计算和数学上的结果不一致。

		如何避免这些事情?
		如0.8角，等于80分，
		银行一般都存整数，精确到分。
		

		不要去转牛角尖，没有意义。

	6. 引用传值在php的禁用
		在面向对象中，由于封装性，我们是不希望函数的代码能够去影响外部的变量的，也就是参数的引用传参。

		在php5.0以上的版本都不推荐使用了。
		php5.4版本，删除了引用传参的功能。

		allow_call_time_pass_reference = off
		这个选项是引用传值的开启项。

-->