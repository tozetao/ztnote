jwt

json web token，其实就是一个token，可以理解为签证的意思。



header.payload.signature



header

头部信息，指定jwt使用的签名算法

经过base64编码过的header就是要传递的头部信息。



payload

​    消息体，这是一个JSON对象，包含需要传递的数据。

payload由公有字段和私有字段组成，公有字段是jwt定义的字段，私有字段则是业务字段。



经过base64编码后的payload就是要传递的消息体。



signature

通过头部信息指定的签名算法，使用密钥对字符串（base64编码的header + "." + base64编码的payload）

进行加密，得到的加密字符串就是签名。



经过base64编码后的签名就是要传递的签名。



jwt使用流程

- 客户端发送用户名和密码，服务端进行验证，如果用户名和密码正确则发放token，否则提示相关错误信息。
- 在后续的请求中，客户端会在发送请求时会携带该签名，而服务端会验证该签名是否合法。





什么是jwt

优点

缺陷

CSRF攻击

token的过期设计



如果一个token过期了，允许在过期后的一定时间内对其进行刷新，这个值可以根据需求自定义。

因此我们会有俩个token，一个用于鉴权，一个用于刷新过期的token。

refresh token时一个一次性token，在刷新完鉴权token后会再次发放。















jwt的缺陷

jwt本身是无状态的，并且一个已经签发的jwt，在过期之前它是一直有效的。

因此它无法做到统计在线用户的人数、强行踢掉一个在线用户或者让一个未过期的jwt失效。对于一些有状态的需求，仍然需要Session的支持。



认证信息的存储







jwt有状态的实现

通过Session的配置来实现有状态的jwt，jwt的payload中保存SessionId，这样jwt就是有状态的。如果jwt的SessionId所对应服务器的Session数据不存在时，该jwt即使未过期也是无效的。



https://www.jianshu.com/p/805dc2a0f49e



web认证：

无论是使用Session或Token做认证，总要保证服务器可以管理Session，通过Session的存在来确认认证的有效性。



https://www.jianshu.com/p/805dc2a0f49e

https://blog.csdn.net/guyan0319/article/details/84879110

https://blog.csdn.net/lzy_zhi_yuan/article/details/73127601

https://www.cnblogs.com/chevin/p/5669940.html





实现一个基于token的session机制。

超时：在用户一段时候没有访问后，服务端session将会过期。



```go
//定义Session的操作接口
type Session interface {
    Get(key string) interface{}, error
    
    Set(key string, interface{}) error
    
    Delete(key string) error
    
    SessionId() string, error
}

//Session服务提供者，只要符合接口规范，可以以任意形式来实现Session的存储
type SessionProvider interface {
    //启动或复用一个请求的Session对象
    SessionStart(r *http.Request, w http.ResponseWriter) *Session, error
    
    //销毁一个请求的Session对象
    SessionDestory(r *http.Request, w http.ResponseWriter) error
    
    //对过期的Session进行垃圾回收
    GC()
}

var provider SessionProvider

func Init() {
    provider = MemeryStore()
}

func Start(r *http.Request) (*Session, error) {
    return provider.SessionStart()
}

func Destory(r *http.Request) {
    return provider.SessionDestory()
}

func GC() {
}

/*
Provider是全局可访问的，在Handler中也可以调用。

需要一个map容器，以键值对存储Session对象。
需要一个List，存储已经创建的Session对象，用于gc

SessionId -> map

session应该在哪里启动?
- 有一个全局初始化Session容器的地方

session如何获取?
- 每个请求都能够获取自己的Session对象。

*/
```





























在线人数的统计实现：

后台redis维护session_id的最后更新时间



我就问了一个问题 如何统计出网站的在线人数？  到现在 还没有我满意的答案。都要我引导下去说

这个要先定义什么是离线状态

后台redis 维护 session_id 的最后 更新时间

前台ajax 发送心跳包更新 时间

然后后台crontab 统计

ip不等于用户

心跳 + mysql 就好了啊 。。。。。。

where last_online_time > now（）- 60s

因为发送心跳的时间 量比较大 mysql 可能会撑不住

大概这样一句sql就是方案了嘛，剩下的是实现细节
不会撑不住啊 o（1） 的 update 而且不会大量锁冲突

我觉得吧，首先要问清楚面试官是在线还是离线统计，其次要看是实时还是非实时以及数据规模、保存时间等要求。办法有很多的，比如用监听器+MQ+bitmap也可以，也可以用MQ+LOG+ES

关键还是要细化下来。

如果你说实时统计在线人数，QPS平均水位在200和2000用的方案肯定是不同的

除了需求之外还要确定需求规模

因为很多问题其实没有唯一解或者有很多解的，如果不能把需求、场景、规模等多维度信息结合起来，你出的解决方案很可能只是局部最优解全局最差解。所以要是面试我的话得做好被各种反问的准备

而且我一般给出虚拟场景的答案也不会只给一个，一般会有1、人力时间充足的方案  2、业务最小侵入解 3、性能较好解 等等

所以友情建议，面试官提问之后别急着立刻答，先把多个维度信息逐步问出来补全场景。然后制定几套方案来回答

