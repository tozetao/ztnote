共享锁
    LOCK_SH，当前程序获得共享锁时，其他程序也能够获得该文件的共享锁，并允许读取文件，
    但是其他程序无法获取独占锁，必须等待获得共享锁的程序释放该锁。

独占锁
    LOCK_EX，当前程序获得独占锁时，其他程序必须等当前程序释放独占锁时，才能获取锁。

注：当前程序加锁时，其他程序可以不获取锁直接操作(读写)文件，不通过锁的方式其他程序时不会阻塞的。

锁争抢
    多个写锁发生的争抢，例如A请求获取读锁，这时候其他请求获取写锁
    多个读锁和写锁发生争抢，例如A请求获取写锁，这时候其他请求获取写锁或者读锁

sleep()函数是并发安全的，错误，sleep()函数并不会阻塞其他程序的运行，多线程等程序建议在linux上运行。
不同的系统会带来不同的效果。



域名检测接口
    一个cli程序，在linux中会每隔2秒运行一次，主要检测缓冲文件中的域名是否可用。
    不可用的会被删除，在检测到一个可用的域名时，循环会停止。


程序功能模拟
    ci3的文件写入是并发安全的，每2秒去更新域名的状态，如果这俩秒内域名失效，那么请求的域名都是被封的域名，俩秒后缓存才会被更新，
    又因为检查域名的接口有限制访问频率，所以回复正常的时间 = 定时器2秒 + 失效域名的个数 * 2

### 锁的一些操作说明
将方法或者函数作为一个原子操作，在有多个线程时，原子性的操作能够保证数据的正确性，不会发生脏读且不会发生写入不正确的数据。

例如有A、B、C 3个方法，在同一个时间段内，它们都对某个缓存文件进行读取数据，在处理完毕后写入处理后的数据，这种情况你应该在A、B、C方法代码的开头和结尾对文件加锁和解锁，保证原子性。

如果只保证写入的原子性，虽然不会导致多个线程同时在文件写入数据导致数据的错误，但是会发生另外一个问题，同时读取数据后排队写入数据，会导致其他方法看到它们不想要的结果。