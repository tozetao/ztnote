### 后期静态绑定
5.3.0新功能，用于解决self、__CLASS__关键字的局限性，self调用静态方法是取决于代码所在的上下文，无法实现取决于运行时环境的动态调用。

简单的说，后期静态绑定static::不被解析为当前方法所在的类，而是解析成运行时所在的类。

example：
```php
// self的限制：使用self是对当前类的静态引用，取决于当前方法所在的类。
// self、__CLASS__：取决于代码所在的上下文。

class A{
	public static function who(){
		echo __CLASS__;
	}

	public static function test()
	{
		self::who();
		echo "\n";
		static::who();
	}
}

class B extends A
{
	public static function who()
	{
		echo __CLASS__;
	}
}

B::test(); 
// 可以看到B类虽然重写了A类的test方法，但是仍然调用A类的who方法，这是self的局限。
```
		
	
example：this与static的区别
```php
// 非静态环境下，所调用的类即为该对象实例所属的类，
// $this->会在同一作用范围内尝试调用私有方法，这一点static不太一样。
class A {
    private function foo() {
        echo "success!\n";
    }
    public function test() {
        $this->foo();
        static::foo();
    }
}

class B extends A {
}

class C extends A {
    private function foo() {
        echo 'C success!', "\n";
    }
}

$b = new B();
$b->test();
$c = new C();
$c->test();   //fails，在A的上下文中调用C的foo私有方法

example：
// static::，如果你以类名显式的去调用父类使用了后期静态绑定的方法，static关键字则代表显式调用的类名。
class A {
    public static function foo() {
        static::who();
    }

    public static function who() {
        echo __CLASS__."\n";
    }
}

class B extends A {
    public static function test() {
        A::foo();
        parent::foo();
        self::foo();
    }

    public static function who() {
        echo 'b ' . __CLASS__."\n";
    }
}

class C extends B {
    public static function who() {
        echo 'c ' . __CLASS__."\n";
    }
}

// B::test();
C::test();
```