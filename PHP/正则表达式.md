## 正则表达式 ##
正则表达式类似于一个字符串模板，通过这个模板来匹配字符，它主要由各种元字符组成。

## 正则表达式的原字符

### 1. 正则表达式的定义
一般是/斜杠作为起始和结束来定义一个正则表达式，也可以是#字符。

```php
$regex = '/abc/i';	//匹配abc字符串的表达式
$regex = '/http:\/\/[\w.]+/';	//匹配一个域名
```

### 2. 模式修饰符
用于改变正则表达式的行为，一般位于正则表达式的最后，修饰符有：
- i，忽略字母大小写
- x，忽略空格


### 3. 限定符
限定符用于限制每个字符串出现的次数
- *，用于匹配0到多个字符。
- +，匹配1到多个字符。
- ?，匹配0到1个字符。
- {n}，匹配n个字符
- {n,}，匹配n到多个字符
- {n,m}，匹配n到m个字符

在贪婪模式中，限定符会尽可能的匹配多的字符。
```php
$regex = '/a{3,}/';
$content = 'aaaaabcdef';
preg_match($regex, $content, $arr);
var_dump($arr);		//输出aaaaa
```

对于?或*元字符，如果要匹配的字符处于字符串的中间，正则会解析成0个来匹配，如果匹配的字符位于字符串的开头，正则会尽可能多的去匹配，例如：
```php
$matches = array();
$regex = '/\d?/';		//匹配0个或1个数字
$content = 'abcdef 123 worlds 45 ho to';

preg_match($regex, $content, $matches);
var_dump($matches);		//输出空字符串
```

### 4. 匹配符
匹配符用于匹配某一类的字符，它是正则表达式预定义的字符集。
- \d，匹配一个数字字符。[0-9]
- \w，匹配0-9、a-z、A-Z任意中的一个字符，相当于[0-9a-zA-Z]
- \s，匹配空白字符，例如空格、换行符、制表符中任意一个
- \W，匹配一个非单词字符，相当于[^0-9a-zA-Z]
- \D，匹配一个非数字字符。[^0-9]
- \S，匹配一个非空表字符
- . 匹配任意一个非换行\n的字符。

### 5. 行定位符
- ^，定义一个表达式以什么字符开头
- $，定义表达式以什么字符结尾

### 6. 其他
- \b，匹配一个单词边界，字符串的起始、结束和空格称之为单词边界，它匹配的是单词的位置，并不会匹配到空格。
```php
$reg = '/\b(\w+)\b\s\1/i';
$content = 'hello hello hello abcd hello abcd hello';
preg_match($reg, $content, $matches);
var_dump($matches);	//输出hello hello

$reg = '/\b(\w+)\b\1/i';
# 这样写是错的，规则的逻辑有问题
```





## 元字符转义
有的时候需要匹配元字符，这个时候需要对其进行转义，例如：
```php
$regex = '/\*/';
# 匹配一个*字符

$regex = '/\./';
# 匹配一个.字符

$regex = '/\\\/';
# 匹配一个反斜杠

$content = 'abcd$efg';
$regex = '/\\$/i';		//匹配一个$字符
```
除了\反斜杠，其他元字符匹配用一个\或俩个\都能匹配，
为什么要俩个反斜杠？要匹配$，正则表达式是\$，而表达式中的\也需要转义，所以就变成了\\，最后的表达式是\\$。

在php中，对于元字符的匹配更好的解决方案是使用\Q\E来匹配元字符
```php
..........
```


## 字符类与限定符
字母、数字或空白字符都有对应字符集的元字符，如果想预定义字符集合，可以通过[]字符进行定义，字符类的意思是匹配字符集中的某个字符，例如：
```php
$reg = '/[abcde]/';
# 匹配abcde其中一个字符

$reg = '/[0-9]/';
# 匹配0-9中的一个数字，等同于\d
```

在字符类[]中，限定符是被作为普通字符处理，不需要对元字符转义，例如：
```php
$reg = '/[.?!*]/';
# 匹配其中一个字符

$reg = '/[\'\"]/';
# 匹配单引号或双引号

$reg = '/[\/]/';
# 匹配一个斜杠

$reg = '/[\\\]/';
# 匹配一个反斜杠

$reg = '/[ ]/';
# 匹配一个空格
```

### 1. 字符类与限定符配合使用
```php
$matches = array();
$regex = '/\w*[)-]?/';	//匹配0个或多个字符并且后面跟着0个或1个)或-字符
$content = "abcd-)----123456";

preg_match($regex, $content, $matches);
var_dump($matches);


$regex = '/\d{3}[1\-)]?/i';	
//匹配3个数字，其后跟随1或-或)，-在字符域中与数字使用时，需要转义
$content = '123-1)fjkdjfl';
preg_match($regex, $content, $matches);
print_r($matches);

```

### 2. 字符类与^字符
^字符用于在字符类中取反，例如：[^abc]表示匹配出abc意外的任意一个字符。



## 反义
有时候需要查找不属于某个字符类的字符，或者不属于特定字符集的字符，就需要用到反义。
常见反义元字符：
- \W，匹配任意不是字母、数字和_的字符
- \D，匹配任意一个非数字的字符
- \S
- \B
- [^abc]，匹配非abc的任意字符




## 分支条件，|
分支条件指的是正则表达式有几种规则，如果满足其中一种规则都应该当成匹配，
分支条件是用|字符将多个条件分割开。

匹配的时候分支条件会从左到右测试每个条件，如果其中一个满足条件了，其余的规则就不会匹配了。

```php
// 测试匹配条件
$matches = array();
$regex = '/123|456/';	//匹配123或456
$content = "abcdefg456123";

preg_match($regex, $content, $matches);
var_dump($matches);


$regex = '/0\d{2}-\d{8}|0\d{3}-\d{7}/i';	
//匹配3位区号，8位本地号或匹配4为区号，7为本地号
$n1 = '022-23423423';

preg_match($regex, $n1, $matches);
print_r($matches);
``` 

## ()字符
()字符一般用于：
- 改变分支条件字符|、限定符*、定界符^的作用范围，例如：
```php
# 对分支条件分组，控制分支条件的作用范围
# 匹配以0开头的2位数组或3位数组，后面跟着-字符和4位数组
$reg = '/(0\d{2}|0\d{3})-\d{4}/i';
$content = '0210-4567';
$content = '010-4567';
preg_match($reg, $content, $matches);
var_dump($matches);
```

- 配合限定符能匹配重复多个字符串
```php
$reg = '/(\d{3}\.)+/i';	//匹配3个数字加.字符，重复1次或多次
$content = '123.456.789.';
preg_match($reg, $content, $matches);
var_dump($matches);
```

注：()字符不同于[]字符，在()字符中元字符是有特殊意义的。


- 进行分组，便于反向使用，反向引用比较复杂，用一个章节说明

## 反向引用
使用()小括号指定一个子表达式后，匹配这个子表达式的文本，也就是分组捕获的内容可以在表达式中引用。
每个分组自动拥有组号，规则是从左向右,以分组的左括号为标识，第一个出现的分组的组号是1，第二个是2，以此类推。


### 1. 匹配顺序
```php
$str='abc1234fsdfds';
$reg='/abc\d(\d)(\d)/i';

$m = array();
preg_match_all($reg, $str, $m, PREG_PATTERN_ORDER);
var_dump($m);	//输出abc123，1，2

# 第一次匹配到abc123，子表达式在原表达式匹配到的内容上进行匹配，
# 第一个子表达式匹配到2，第二个子表达式匹配到3
```

### 2. 子表达式的引用
反向引用用于重复搜索前面某个分组匹配的文本，例如\1代表分组1匹配到的文本，
```php

```
其他关于引用的语法再看。



## 贪婪匹配与懒惰匹配
当正则表达式中包含能接受重复的限定符时，通常行为是尽可能多的匹配字符，在整个表达式能匹配到的情况下。
```php
$reg = '/a.*b/i';
# 匹配最长的a开始，以b结束的字符
$content = 'aaaabdfdfdfdfb';
```

### 懒惰匹配模式
上述的限定符，都能转化为懒惰模式，只需要在限定符后面加上?，该限定符就会尽可能少的匹配字符。
```php
$reg = '/a.*?b/';
$content = 'aabab';
preg_match($reg, $content, $matches);
var_dump($matches);		//输出aab

# 懒惰模式会匹配成功下尽可能少的匹配
```
- *?，重复任意次，但尽可能少重复
- +?，重复1次或多次，但尽可能少的重复
- ??，重复0次或多次，但尽可能少的重复
- {n,m}?，重复n到m次，但尽可能少重复
- {n,}?，重复n次以上，但尽可能少重复

## 平衡组/递归匹配







正则大体可以理解成匹配任意一个字符，匹配一组字符。
