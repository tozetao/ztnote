TCP是一种面向连接的、可靠的、基于字节流的通信协议，数据在传输时需要建立连接，传输完毕后要断开连接。



- 面向连接

  TCP提供客户端与服务端的链接，首先客户端会跟给定的服务器建立一个连接，再通过该连接与服务端交换数据，然后关闭该连接。

- 可靠性

  当TCP给一端发送数据时，它要求对端返回一个确认。如果没有收到确认，TCP就自动重传数据并等待更长时间。在数次重传失败后，TCP才会放弃，尝试重传花费的时间依赖于实现。

  TCP含有用于动态估算客户端与服务端发送数据之间的往返时间的算法，称为RTT(round-trip time)。以便知道等待一个确认包需要多少时间，TCP会持续估算给定连接的RTT。

- 数据是有序的

  TCP通过给每个数据包关联一个序列号，以此进行排序。

  假设一个应用要写入2048个字节到一个TCP套接字，导致TCP分为2个数据包发送，第一个数据包序号为1-1024，第二个数据包序号为1025-2048，如果俩个数据包非顺序到达，接收端TCP将根据数据包的序号重新排列，再把结果数据传递给接收应用。

- 数据包：TCP传递给IP的数据单元。

- 流量控制

  TCP提供流量控制，TCP总是会告诉对端在任何时刻它一次能够从对端接收多少字节的数据，这被称为Advertised Window。

  Advertised Window会指出接收缓冲区中当前可用的空间，从而确保发送端发送的数据不会使接收缓冲区溢出。这个窗口是时刻变化的，当从接收缓冲区读取数据时，窗口会变大，当从接收缓冲区写入数据是，窗口会变小。

- 全双工

  TCP连接时全双工的，这意味着在一个给定的连接上的应用可以在任何时刻在进出的俩个方向上既发送数据又接收数据。





### TCP数据报结构

```c
struct tcp_package {
    short source_port;	//源端口
    short target_port;	//目标端口
    int seq;	//Sequence Number，序号，占32位
    int ack;	//Acknowledge Numb，确认号，占32位
    //6个标志位
    //其他略...
};
```

重点关注以下字段：

- seq

  Sequence Number，序号，占32位，用来标识从计算机A发送到计算机B的数据包的序号，在发送数据包时会对此进行标记。

- ack

  Acknowledge Number，确认号，32位，客户端和服务端都可以发送，ack = seq + 1

标志位有6个，每个标志位占1个字节，分别是：

-  URG：紧急指针（urgent pointer）有效。
-  ACK：确认序号有效。
-  PSH：接收方应该尽快将这个报文交给应用层。
-  RST：重置连接。
-  SYN：建立一个新连接。
-  FIN：断开一个连接。

SYN是Synchronous的缩写，表示同步的；FIN是Finish的缩写，表示完成；seq是Sequence的缩写，表示序列；ack是Acknowledge，表示确认。



### TCP连接的建立

客户端调用socket()函数创建socket套接字后，因为没有建立连接，所以处于CLOSED状态；服务端调用listen()函数后，套接字进入LISTEN状态，开始监听客户端请求。

- 建立连接

  客户端调用connect()发起连接，这时TCP会发送一个SYN包，它会设置SYN标志位，设置客户端发送数据的初始序列号，即设置Seq字段的序列号为G。当发出SYN包后，客户端处于SYNC-SEND状态。

  说明：SYN包不携带数据，它包含一个IP头部，TCP头部和相关TCP选项。

- 服务端确认客户端的SYN

  服务器必须确认客户端的SYN包，因此也需要发送一个SYN包，它包含服务器将在同一连接中发送数据的初始序列号，也包含客户端期待的确认号。

  TCP会在包中设置SYN标志位和ACK标志位，设置序列号Seq字段的为K，设置确认号ACK字段的为G+1，当发送数据包后，服务器处于SYNC-SENT状态。

- 客户端确认服务器的SYN包

  客户端收到服务端的SYN包后，检测检测到有SYN标志位和ACK标志位，知道这是服务端发来的"确认包"，因此会检测确认号ACK字段的值是否等于G+1，如果是说明连接建立成功。

  客户端会发送确认包，设置ACK标志位，设置确认号ACK字段为K+1，然后发送数据包，这时客户端处于ESTABLISED状态，表示连接建立成功。

- 服务端收到数据包，检测到有ACK标志位，知道这是客户端发来的"确认包"，服务端会检测ACK字段，判断是否等于K+1，如果是说明连接建立成功，服务端进入ESTABLISED状态。

注1：确认号 = 序列号 + 1，可以理解为响应的确认号为发送方的序列号加1

注2：握手的关键是确认对方收到了自己的数据包，确认是通过ACK标志位和确认号来实现的；



### TCP连接的断开

建立一个连接要三次握手，而断开一个连接要经过四次握手。

- A端发起断开连接的请求

  某一端调用close()，执行主动关闭。TCP会设置FIN标志位，设置序列号Seq字段为M，然后发送FIN包，这时该端处于FIN_WAIT_1状态。

- B端确认FIN包

  B端在收到FIN包会执行被动关闭，该端需要确认FIN包。

  FIN是由TCP确认的，FIN的接收会作为一个文件结束符(end of file)传递给应用进程，即将文件结束符放在应用进程接收的任何数据之后，因此FIN表示接收端应用进程在连接上没有可以接收的数据了。

  TCP会设置ACK标志位，设置确认号ack字段为M+1，发送确认包，这时B端处于CLOSE_WAIT状态。

- A端在收到确认包后会进入FIN_WAIT_2状态，等待B端再次发送数据包。

- B端发送FIN包

  在一段时间后，接受到这个文件描述符的应用进程会调用close()关闭它的套接字，TCP也会发送一个FIN包。

  TCP会设置FIN标志位，设置序列号Seq字段为N，发送该数据包，这时B端进入LAST_ACK状态。

- A端确认FIN包

  接收到最终FIN包的原发送端TCP确认这个FIN。

  TCP会设置ACK标志位，设置确认号ack字段为N+1，然后发送确认包，这时A端处于TIME_WATI状态。

- 最终B端在收到A端的确认包后就断开连接，进入CLOSE状态。

不论是客户端还是服务器，任何一端都可以执行主动关闭，通常是客户端执行关闭，但是某些协议例如HTTP协议却是由服务器执行主动关闭。





### TIME_WAIT

在TCP断开连接的四次握手中，主动发起断开连接的一方，在最后响应FIN包之后会处于TIME_WAIT状态。

主要有俩个原因：

1. 为了可靠地实现TCP全双工连接的终止

   主动发起断开连接的一方，最后确认FIN包时会发送ACK包，如果ACK包丢失，接收方则会再次重传FIN包，因此必须维护状态信息，以便能够再次发送最终的ACK包。

2. 允许老的重复包在网络中消逝



### TCP数据的传输

假设主机A要分2个数据包向主机B传输200字节数据，那么会有以下过程：

- 发送方发送数据包

  主机A通过一个数据包发送100个字节的数据，数据包的Seq序号设置为1200

- 接收方响应ACK包

  主机B为了确保收到主机A的数据包会响应ACK数据包，并将ACK字段设为1301。

  ACK字段  = Seq + 传递的字节数 + 1，将传递的字节数计算在内是为了让发送端能够确保自己的数据发送成功，加1是告诉发送方下次传递的Seq序号

- 发送方继续发送数据包

  主机A收到ACK数据包，检测ACK字段是否为1301，如果是代表数据发送成功。然后会以1301作为序号发送下一个数据包。



发送方是如何确保接收方收到数据的?

为了保证数据准确到达，目标机器在收到数据包（SYN包、FIN包、普通数据包等）都需要回传ACK包，这样发送方才能确保接收方有收到数据包。



超时重传

如果发送的数据包丢失或者中途发生错误，例如在一定时间内没有收到目标机器相应的ACK包，或者ACK包数据长度验证失败，那么TCP协议会对数据包进行重传。

为了完成数据包的重传，TCP套接字在每次发送数据包的时候都会启动定时器，如果在一定时间内没有收到目标服务器的ACK包，那么定时器超时，数据包会重传。

- 重传超时时间 

  重传的超时时间理论上最好的是网络RTT时间，RTT指的是从发送端发送数据包开始，到发送端收到来自接收端的ACK确认包，总共经历的时间。



