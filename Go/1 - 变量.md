### 声明

声明语句定义了程序的各种实体对象以及部分属性。Go的声明语句有4种类型：

- var

  声明变量

- const

  声明常量

- type

  声明结构体或自定义类型。

- func

  声明函数

包一级的声明语句称为全局声明，声明的变量可在整个包中对应的每个源文件中访问；在函数内部声明的语句被称为局部声明，声明的变量只能在函数内部中使用。



### 变量

> var 变量名 类型 = 表达式

变量声明语法如上所示。其中"类型"或"=表达式"任意一方可以省略。如果只有"=表达式"，Go会根据表达式来推到变量的具体类型；如果只有"类型"，Go会使用零值初始化变量。

Go支持声明一组变量或初始化一组变量：

```go
var a, b, c int
var a, b, c = 1, 2, 3
```

- 零值初始化机制

  如果声明的变量没有初始化，那么将使用零值初始化该变量。

  数值类型的零值是0，字符串类型的零值是空字符串，布尔值类型的零值是false，接口或引用类型变量对应的零值是nil。数组或结构体等聚合类型的零值是每个元素或字段的自身类型的零值。

  优点：避免使用未初始化变量导致的未知错误。



- 初始化时机

  局部变量将在声明语句被执行到的时候完成初始化，全局变量会在main函数初始化之前完成初始化。



### 简短变量声明

Go在函数内部提供了一种简单方式来声明和初始化变量，称为简短变量声明。语法如下：

> 名字 := 表达式

变量的类型将根据表达式自动推导。简短变量声明也支持声明和初始化一组变量：

```go
a, b, c := 1, 2, 3
```

一般的，var声明语句使用在需要显示指定变量类型的地方，如果不需要显示指定变量类型，在函数内部使用简短声明更方便。



简短变量声明要注意俩点，一是要注意":="是一个声明语句，而"="是一个赋值语句。如果一个变量已经声明过，简短变量声明将只会尝试赋值行为。

```go
in, err := os.Open(infile)		//声明in与err，并赋值
out, err := os.Open(outfile)	//声明out，然后赋值out和err
```

另一点是简短变量声明语句中至少要声明一个变量，如果所声明的变量是已经提前被声明过的，将会报错。

```go
f, err := os.Open(file1)
f. err := os.Open(file2)	//error
```







### 变量的生命周期

变量的生命周期是指程序在运行期间变量的有效存在时间。

对于包一级声明的变量来说，它们的声明周期和整个程序的运行周期是一致的。而局部变量的声明周期是动态的，每次执行声明语句创建一个新变量的开始，直到该变量不会再被引用为止，变量的存储空间可能被回收。

函数的参数变量和返回值变量都是局部变量，它们在函数每次被调用时创建。



栈与堆

局部变量存储空间的创建是由编译器来选择的，逃逸的局部变量会在堆上创建，未逃逸的局部变量可能会在栈上创建，取决于该局部变量是否被外部使用。

个人理解的是如果局部变量被全局变量引用了，将无法回收。如果局部变量被外部函数使用，那么该局部变量将会在堆上创建，当没有引用该局部变量时GC将会从堆上回收。

```go
var global *int

func foo() {
    var x int
    x = 100
    global = &x
}
```

x变量的内到地址赋值给global，被全局引用了，因此该局部变量逃逸了。





### 指针

什么是变量?

一个变量对应一个保存该变量类型的内存空间。

普通变量在声明语句时被绑定到一个变量名，比如一个x的变量，在赋值语句的右边表达访问该变量内存空间的值，在赋值语句左边表达对该变量的内存空间赋值。



什么是指针?

指针变量是一种保存变量内存地址的变量，一个指针指向一个变量在内存中的存储位置。

通过"&"取址运算符可以获取一个变量的内存地址，而通过"*"间接访问运算符可以访问一个指针所指向的变量。

```go
var n int = 100;
var p *int = &n;

*p = 200	//赋值变量n
t := *p		//访问变量n
```

p是一个指向变量n的指针，\*p在赋值语句的右边表示读取变量n的值，\*p在赋值语句左边表示更新变量n的值。



与C语言不同的是Go有垃圾回收系统，因此可以返回函数中局部变量的地址。

```go
func GetPoint() *int {
    num := 100
    return &num
}
```



### new函数

new(T)函数是一个预定义函数，它表示将创建一个T类型的匿名变量。new(T)会初始化一个T类型的零值，然后返回变量的地址，返回的指针类型为*T。

```go
p := new(int)
```

new函数是类似语法糖，它与普通的声明语句创建变量并没有什么区别。

注：new不是关键字，因此变量名可以使用new。



### 类型声明

有一些变量内部存储结构是相同的，但是却表示不同的概念。比如float类型的变量可以用来表示每秒移动几米的变量，或者是不同温度单位下的温度。

针对这种情况，Go提供了type关键字用于类型声明，它允许创建一个新的类型名称。虽然新的类型名称和原有类型具有相同的底层结构，但是它们之间是不兼容的。

也就是说底层结构相同的不同类型，不允许相互比较或混入同一个表达式中，比如：

```go
// 华氏温度
type Celsius float64

// 摄氏温度
type Fahrenheit float64

func CToF(c Celsius) Fahrenheit {
	n := c*9/5 + 32
	// 类型转换，可不是函数调用
	return Fahrenheit(n)
}

func FToC(f Fahrenheit) Celsius {
	n := (f - 32) * 5 / 9
	// 类型转换
	return Celsius(n)
}

func TestConvert() {
	var c Celsius = 10.55
	var f Fahrenheit = 1.55
	var temp float64 = 3.31

	total1 := c + f    //编译错误
	total2 := c + temp //编译错误
	total := c + FToC(f)
	fmt.Println(total)
}
```

还有一点需要明白的是，新的类型声明的底层结构，决定了新类型的存储方式以及对内置运算符的支持。在上面代码中，俩个温度类型底层类型是float，因此可以像float一样进行数学运算。



### 类型转换

对于每个类型T，都有对应的一个类型转换操作T(x)，用于将x转换为T类型。如果是指针类型的转换，需要用小括号包装T，比如：(int *)(0)。

- 注1

  类型转换是只有俩个类型的底层基础类型相同时才允许这种操作，或者是俩个指向相同底层结构的指针类型。

- 注2

  在Go中，数值类型之间的转型是允许的，这类转型会改变值的表现。比如float转int将会丢失小数。



### 作用域

声明语句的作用域对应的是一个源代码的文本区域，它是一个编译时的属性。

对于全局的源代码来说，存在一个整体的词法块称为全局词法块；对于每个包、每个for、if和switch语句，也都对应词法块；每个switch和select的分支也有独立的词法块；当然显示书写的大括号块也是词法块。



- 变量名的查找

当编译器在遇到一个名字引用时，首先从最内层的词法域向全局的作用域查找。如果查找失败就报告未声明的名字错误；如果该名字在内部和外部的块分别声明过，则内部块的声明会屏蔽外部同名的声明，优先使用内部块声明。

```go
func test() {
    x := "hello!"
	for i := 0; i < len(x); i++ {
		x := x[i]
		if x != '!' {
			x := x + 'A' - 'a'
			fmt.Printf("%c", x)		//HELLO
		}
	}
}
```

大括号的是显式的词法块，而for的初始化语句、条件判断和迭代部分都是隐式的词法块。可以看到在内部词法块寻找不到变量名时将会去外部寻找。







