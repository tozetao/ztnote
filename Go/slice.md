### 数组

数组是一个由固定长度的特定类型元素组成的序列，数组与slice最大的区别是，数组长度是固定的，slice长度是运行时可改变的。

数组在内存中是一段连续的存储空间，并且Go语言的数组是值类型，数组赋值时是对整个数组值的拷贝。

声明格式：

```go
var array [length]type
```

length是数组长度，俩个类型相同但是长度不同的数组是俩种类型，比如：

```go
var arr1 [5]int;	//长度为5的int型数组
var arr2 [3]int;	//长度为3的int型数组
```





### 切片

切片是引用类型，它是对数组某个连续片段的引用，切片的长度是运行时可改变的。

声明：

```go
var slice []type;
```

初始化：

```go
var slice []type = array[start:end]
```

切片是可索引访问的，对数组进行切片后，切片索引将从0开始访问。

- 切片的长度

  长度 = end - start，也就是引用数组[start, end)左闭右开这段范围的元素。

- 切片的容量

  cap()用于计算切片的最大容量。

  它等于切片的长度 + 数组切片之外的长度，也就是slice[start]到数组末尾的数组长度。

- 数组共享

  由于是引用类型，对同一个数组的不同切片是共享同一个数组数据的。

example：

```go
//创建长度为4的数组并创建了一个相关切片
var slice1 = []int{1,2,3,4}[:]
var slice2 = []int{1,2,3,4}
```

注：字符串是纯粹不可变的数组，因此可以切片。



### make()

当一个数组还没定义时，可以使用make创建一个切片，同时创建好相关数组。



make函数的原型：

```c
func make([]T, len, cap)
```

[]T是要创建切片的类型，len是切片的长度，cap是可选参数，表示切片的容量，也可以认为是数组的长度；如果len、cap参数同时使用，那么会创建一个只占用数组len个项的切片。



初始化：

```go
var slice []type = make([]type, len)	//slice := make([]type, len)
```



### new()

new(T)为每个新的类型T分配一块内存，它会按照数据类型对开辟的内存空间做默认初始化，并返回类型为T的内存地址。new(T)适用于值类型的数组和结构体。

```go
var a *int = new(int);					// *a == 0
var slice *[]string = new([]string)		// *slice == nil

//简短赋值
a := new(int)
slice := new([]string)
```



make(T)是返回类型为T的初始值，它只适用于slice、map和channel。与new的区别在于：new()函数是返回指向内存的指针，而make是返回值类型。

new(T)、mak(T)都是在堆上分配内存空间。







shop_exchange





### Go方法

Go方法是作用于接收者（receiver）上的一个函数。

接收者是某种类型的变量，它指向调用者（调用方法的一方）。如果接收者是指针类型，它则指向调用者的指针，如果接收者是非指向类型，它是调用者的一份拷贝。

接收者类型可以是除了接口外的任意类型，可以是结构体类型，也可以是函数、int、bool或数组的别名类型。

注：不在接收者类型所在的包中定义方法会产生编译错误。

example：指针类型的接收者与非指针类型的接收者的比较

```go
type User struct {
    name string
    age  int
}

//会改变结构体的值
func (recv *User) changeAge1() {
    recv.age += 100
}

//不会改变结构体的值
func (recv User) changeAge2() {
    recv.age += 100
}
```





### 内嵌类型

内嵌类型也被称为匿名类型，即在结构体中只声明类型而不声明变量名。

内嵌类型主要提供了一种混合的方式，它能够把一个结构体的字段和方法混合到当前结构中，通过内嵌类型可以模拟继承。

- 重载

  内嵌时，字段与方法可以被覆盖。在结构体内部中，外层名字会覆盖内层名字，这里的内层指的是混入的类型，外外层指的是当前结构体本身。





goroutine

协程是独立的处理单元，无法确定协程是什么时候开始执行的，因此代码逻辑必须独立与协程的调用顺序。



协程提供了一种简单的方法来编写并发程序。









概念：

协程可以看作是能够保存上下文，可让出执行但不可抢占的执行单元。



协程与线程

线程是抢占式的，使用线程无法确定系统何时调度线程，何时切换线程。而协程是非抢占式的。在没主动交出CPU之前是不会被突然切换到其他协程上的，因此使用协程的好处是不用加锁，访问共享的数据不用进行同步操作。



协程与异步回调

异步回调可以避免IO阻塞，但是需要将处理操作写在回调函数中，而回调函数会使连贯的业务代码拆分到多个回调函数中，增加维护的成本，而使用协程能够以同步的写法写入异步效果的代码。



实现分析：

实现协程主要是保存函数调用的上下文，函数调用上下文包括：

- 寄存器的值
- 函数调用栈









协程的实现

```c
int setjmp(jmp_buf buf);
```

将堆栈上下文环境保存在buf中，供longjmp()调用时使用。

setjmp()返回值依赖于longjmp传递，如果longjmp没有传递返回值将返回0，否则返回longjmp传递的值。



```c
void longjmp(jmp_buf buf, int val);
```

执行longjmp()可以跳转会之前执行setjmp()的地方，跳转是可以跨函数的。





### ucontext

ucontext.h基本使用流程：

- 获取上下文

- 设置上下文

  分配新堆栈，并定义后继上下文。

- 激活上下文

  在激活上下文时，将调用函数func，并传递遵循argc参数的一系列整数参数，调用者必须在argc中指定这些参数的数量。当此函数返回时，将激活后继上下文。如果后继上下文指针为NULL，则线程退出。



```c
int getcontext(ucontext_t *ucp);
```

将当前上下文信息保存到ucp中。

```c
void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);
```

修改ucp指向的上下文，绑定上下文要执行的函数。

在调用makecontext之前，调用者必须为此上下文分配一个新堆栈，并i将其地址分配给ucp->uc_stack，并定义后继上下文并将其地址分配给ucp->uc_link。

```c
int setcontext(const ucontext_t *ucp);
```

激活ucp指向的上下文。

```c
int swapcontext(ucontext_t *oucp, ucontext_t *ucp);
```

将当前上下文保存在oucp中，然后激活ucp指向的上下文。







setcontext()是跳转到指定的上下文中。

swapcontext()是在执行完当前上下文后，跳转到后继上下文的地方来执行代码。



实现逻辑：

一个存储执行协程执行单元的List。

- 创建一个协程

  会保存创建的上下文、保存主函数的上下文（即create_coro的函数结尾），然后激活创建的上下文，执行任务。


- 挂起一个协程

  一般会在任务中挂起一个协程。

  挂起一个协程时，会保存任务挂起的上下文，并激活主函数上下文。激活函数上下文，create_coro其实就执行完毕了；在后续中需要检查是否有协程需要执行。


- 恢复一个协程

  会激活挂起的上下文，恢复任务的执行，同时保存主函数的上下文。

  激活一个协程后，resume_coro函数就执行完毕了。

    

三个阶段中，协程单元都会保存每个阶段的挂起点。



执行完毕后，协程单元处于Free状态。



RUNNABLE：协程处于创建状态

SUSPEND：协程处于挂起状态

FREE：协程执行完毕。



