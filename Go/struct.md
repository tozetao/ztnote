

### Go方法

Go方法是作用于接收者（receiver）上的一个函数。

接收者是某种类型的变量，它指向调用者（调用方法的一方）。如果接收者是指针类型，它则指向调用者的指针，如果接收者是非指向类型，它是调用者的一份拷贝。

接收者类型可以是除了接口外的任意类型，可以是结构体类型，也可以是函数、int、bool或数组的别名类型。

注：不在接收者类型所在的包中定义方法会产生编译错误。

example：指针类型的接收者与非指针类型的接收者的比较

```go
type User struct {
    name string
    age  int
}

//会改变结构体的值
func (recv *User) changeAge1() {
    recv.age += 100
}

//不会改变结构体的值
func (recv User) changeAge2() {
    recv.age += 100
}
```





### 内嵌类型

内嵌类型也被称为匿名类型，即在结构体中只声明类型而不声明变量名。

内嵌类型主要提供了一种混合的方式，它能够把一个结构体的字段和方法混合到当前结构中，通过内嵌类型可以模拟继承。

- 重载

  内嵌时，字段与方法可以被覆盖。在结构体内部中，外层名字会覆盖内层名字，这里的内层指的是混入的类型，外外层指的是当前结构体本身。







### Interface

接口可以定义一组抽象（不具体实现）方法来说明对象的行为，所以接口是一种抽象类型。



接口按照如下格式进行定义：

```go
type Namer interface {
    methods(param_list) return_type
}
```



Go的多态：

接口的方法由具体类型来实现，当某个类型的实例实现了接口定义的方法，那么该接口类型的变量可以指向这个实例的引用，并且该变量可以调用实例实现了接口定义的方法。

这便是多态，是同一种类型在不同实例上表现出不同的行为。



类型断言

类型断言指在运行期间，判断接口类型的变量是哪种具体类型。

```go
v, err := interfaceVar.(T)
```

interfaceVar是某种接口类型的变量，T是要转换的类型。如果转换合法，v是interfaceVar转换到类型T的值，err会是true；否则v是类型T的零值，ok是false，也不会发生运行时错误。

注：在做类型断言处理时，总是要处理错误。





