## 排序 ##

比较俩个数据项、交换俩个数据项，这俩个操作是这样几个排序算法的基本操作。

### 冒泡排序 ###
最大的数据项总是冒泡到数组的顶端，所以叫做冒泡算法。

> 执行流程：

- 将索引0的数据项与索引1的数据项对比，如果左边的数据项大于右边的数据项，就进行交换，否则不变。
- 接着右移一个位置，继续比较索引1和2的数据项，规则同上，左边数据项大于右边数据项就交换位置，否则不变。
- 按照上述俩个步骤进行下去直到队列结束，最大的数据项就会排列到数组的顶端。

- 在对数组进行第一趟排序后，进行了N-1次比较，并进行了最少0次，最多N-1次交换。
- 当碰到第一个排列好的数组后，就返回数组的最左端开始下一次排序。
- 每趟比较都不需要对比最右边已经冒泡过的数据项，例如第二趟比较只需要对比到右边第二个队员（N-2），因为N-1的队员已经比较过了。N-2次比较，0次交换，N-2次交换。

> 执行效率

一般来说，如果一个数组的数据项有N个，则第一趟排序有N-1次，第二趟排序是N-2次，这种序列的求和公式为：
```
= (N-1) + (N-2) + (N-3) + ... + 1
= 1+(N-1) * (N-1)/2
= N*(N-1)/2
= N*N/2
(约) = N的2次方
```

俩个数据项只有在需要的时候才会交换，所以交换的次数少于比较的次数。
因为数据是随机的，那么大概有一半的数据需要交换，则交换的次数为 N*N/2/2，即 N*N/4（这里不考虑最坏的情况）。

由于交换和比较的次数都是和N的2次方成正比，在大O表示法中，可以忽略2和4，所以认为冒泡排序运行需要O(N的2次方）时间级别。

无论何时，只要看到一个循环套着另外一个循环，就可以怀疑这个算法的运行时间为N的2次方级别。


#### 选择排序 ####
选择排序是对冒泡排序的一种改进，将交换次数从 O(N*N) 减少到 O(N)，但是比较次数仍然是 O(N*N)。

> 算法执行流程

- 遍历数组，从中选出值最小的数据项

- 将选出的数据项与最左端的数据项交换位置，第一次是交换索引为0的数据项。现在最左端的数据项是有序的，不需要再次交换位置了。

- 再次遍历，忽略索引0的数据项，选出最小的数据项，然后和索引1的数据项交换位置。

- 执行上述过程直到数据排序完毕

> 不变性

下标小于或等于out的位置的数据项总是有序的。

> 效率分析

选择排序和冒泡排序执行了相同次数的比较：N*(N-1)/2，然后只需要少于N-1次数据项的比较。

结论：选择排序一样运行了O(N*N)时间，相比冒泡排序，它的速度无疑更快，因为它的交换次数少的多，当N值较小的时候，而交换数据项的时间级别比比较数据项的时间级别大的多的时候，选择排序实际上是非常快的。


#### 插入排序 ####
在大多数情况下，插入排序是基本排序算法中最好的一种，虽然插入排序仍然是O(N*N)的运行时间级别，但是在一般情况下，插入排序比冒泡排序快一倍，比选择排序快一点。

插入排序经常被用于在较复杂的排序算法的最后阶段，例如快速排序。

> 局部有序

在插入排序中，数组中的数据项仅仅是局部有序的，这部分局部有序的数据项的最终排序位置还没有确定，因为当有需要排序的数据项插入的时候，这部分有序的数据项位置是会发生变动的。
而冒泡排序和选择排序，一组数据项在某个时刻是完全有序的，


> 算法执行流程

定义：被标记数据项。
作为被标记的数据项，它和它右边的数据项都是未排过序的。

- 先确定被标记的数据项，该数据项和它右边的数据项都是未排序的

- 将被标记数据项插入到局部有序组中，为了做到这点，先将被标记数据项从数组中移除并存储起来，提供空间给局部有序组右移

- 在移动有序组的时候进行判断，如果要移动的数据项大于被标记数据项，则允许移动位置并继续下一个数据项的移动，如果要移动的数据项小于被标记数据项，则停止有序组的移动，空出的位置就是被移动数据项要插入的位置。

- 这时候局部有序组则多了一个新的数据项，而未排序的部分少了一个数据项。作为被标记的数据项就要右移一位。

- 重复这个过程，直到所有未排序的数据项都被插入局部有序组中正确的位置。

如果是一个未排序的数组，一般我们将索引0的数据项作为已经排序好的有序组，再使用右边的数据项来进行插入排序。

> 插入排序的不变性

每次插入排序后，被标记数据项左边的数据项都是有序的。


> 算法效率

这个算法需要的比较次数和复制次数。

在第一趟排序中，最多比较一次，第二趟排序中，最多比较俩次，以此类推，最后一趟比较N-1次，因此有：
```
= 1 + 2 + 3 + ... + N-1
= (1+N-1)*(N-1)/2
= N(N-1)/2
```
然后在每次排序确定插入点之前，大概平均只有全体数据项的一半进行了比较，因此得到：N(N-1)/4。

复制的次数大致等于比较的次数，然而一次复制与一次交换的时间耗费不同，所以相对于随机数据，这个算法比冒泡排序快一倍，比选择排序略快。

在任意情况下，对于随机顺序的数据进行插入排序也需要O(N*N)的时间级。

对于已经有序或基本有序的数据来说，插入排序要好的多，当数据有序的时候，用被标记数据项比较有序组是接近线性级的，算法大约需要O(N)的时间。

然而对于逆序排序的数据，每次比较和移动都会执行，这种情况下插入排序并不比冒泡排序快的多。


> 一些理解

3 4 5 6 11 20 19 7 8 12

冒泡：每次找出最大的数据项，无论数组是否基本有序，比较的次数都是不会变化的。
插入：由于是以局部有序的数据项作为基准，将要对比的数据项插入合适的位置，所以比较的次数会少的多。