## Memcached内存分配机制

### 1. 内存的碎片化
内存的碎片化是由于空闲的连续内存空间要比申请的空间小而造成的。

我们把内存条理解成一个线性的内存块供系统使用，
在c语言中malloc()是用于在内存中申请内存大小的，假设现在申请了0-9，10-15俩段内存，

如果把第一段的内存释放掉然后申请大于10块的空间来使用，由于第一段空间不能满足大小，只能从16开始分配空间，这种情况就造成了内存的浪费，也就是内存碎片化。

### 2. memcached内存分配机制
memcached使用slab allocator分配机制，原理是按照预先规定的大小，将分配的内存分割成各种规格大小的块（chunk），例如可能有88字节、112字节、144字节的内存块，再将相同规格大小的内存块分成组（slab），通过这种方式最大化的利用内存空间。

在存储的时候memcached会按照数据的大小选择合适的slab，memcached中保存着slab空间chunk的列表，根据该列表选择chunk然后将数据缓存到内存中，可能数据会比chunk小，这种浪费是不可避免的。

内存浪费是不可避免的，只能说缓解。

问题：如果有100byte的内容要存储，但是122大小的仓库慢了，这种情况下会发生什么？
解答：memcached并不会找更大仓库的chunk来存储，只是会将122仓库的旧数据踢出，再来进行存储。

### 3. 增长因子
不同规格大小的chunk比例称为增长因子。

一般而言可以观察缓存大小的变化规律来合理的设置chunk的增长因子，默认memcached是1.25左右大小。增长因子并不是越大越好，过大的chunk反而会造成更多的内存浪费，按照网站的情况来设置。

启动的-f选项用于指定增长因子大小。

### 4. Lazy Expiration
memcached内部不会监视缓存数据是否过期，只有在get是查看缓存数据的时间戳，检查数据是否过期，这种技术成为Lazy Expiration，

因此memcached不会在监视数据是否过期上而耗费CPU时间。

### 5. LRU删除机制
memcached会优先使用已超时的记录的空间，但即使如此也会发生追加新纪录时slab仓库空间不够的情况，在这种情况下会使用Least Recently Used（LRU）机制来分配空间。

LRU指的是"删除最少使用的"记录的机制，当memcached的空间不足的时候，无法从salb class获得新的空间时，就从最近未被使用的记录中搜索，并将其空间分配给新的记录，从缓存的实用角度来看，该模型十分理想。

原理：内部会给每个单元各自维护一个count（计数器），当有单元被请求时，请求单元的新鲜度会被设置最新（set=0），slab下的其他单元count则自增，根据count值得大小以此来判断哪个单元是最不活跃的。

注：即使某个key是永久有效的，LRU删除机制也是照样发挥作用的。

### 6. memcached参数限制
key的限制：文本协议下key的长度限制为250个字符，后期二进制长度可能会修改到6w多个字节。
value的限制：1m，一般是存储文本，如新闻列表之类的。
memcached内存限制：在32位机制下最大是2G，62位没有限制内存大小。

如果有30的数据要缓存，一般也不会单个实例缓存30G的数据，主要是为了防止一个实例崩溃，因此可以在同台机器的不同端口或不同机器下开启多个实例。





