Symfony provides many tools to secure your application. Some HTTP-related security tools, like [secure session cookies](https://symfony.com/doc/current/session.html) and [CSRF protection](https://symfony.com/doc/current/security/csrf.html) are provided by default. The SecurityBundle, which you will learn about in this guide, provides all authentication and authorization features needed to secure your application.

Symfony提供了许多工具来保护你的应用程序。一些与HTTP相关的安全工具，如session cookies安全和CSRF保护是默认提供的。在本指南你将要学习的SecurityBundle，提供了保护你的应用程序所需的所有认证和授权功能。

To get started, install the SecurityBundle:

为了开始工作，请安装SecurityBundle：

```
$ composer require symfony/security-bundle
```

If you have [Symfony Flex](https://symfony.com/doc/current/setup.html#symfony-flex) installed, this also creates a `security.yaml` configuration file for you:

如果你安装了Symfony Flex，这也会为你创建一个security.yaml配置文件：

```yaml
# config/packages/security.yaml
security:
    # https://symfony.com/doc/current/security.html#registering-the-user-hashing-passwords
    password_hashers:
        Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface: 'auto'
    # https://symfony.com/doc/current/security.html#where-do-users-come-from-user-providers
    providers:
        users_in_memory: { memory: null }
    firewalls:
        dev:
            pattern: ^/(_(profiler|wdt)|css|images|js)/
            security: false
        main:
            lazy: true
            provider: users_in_memory

            # activate different ways to authenticate
            # https://symfony.com/doc/current/security.html#firewalls-authentication

            # https://symfony.com/doc/current/security/impersonating_user.html
            # switch_user: true

    # Easy way to control access for large sections of your site
    # Note: Only the *first* access control that matches will be used
    access_control:
        # - { path: ^/admin, roles: ROLE_ADMIN }
        # - { path: ^/profile, roles: ROLE_USER }
```

That's a lot of config! In the next sections, the three main elements are discussed:

这是一个很长的配置! 在接下来的章节中，将讨论三个主要元素：

- [The User](https://symfony.com/doc/current/security.html#the-user) (`providers`)

  Any secured section of your application needs some concept of a user. The user provider loads users from any storage (e.g. the database) based on a "user identifier" (e.g. the user's email address);

  你的应用程序的任何安全部分都需要一些用户的概念。用户提供者根据 "用户标识符"（如用户的电子邮件地址）从任意的存储中（如数据库）加载用户；

- [The Firewall](https://symfony.com/doc/current/security.html#the-firewall) & [Authenticating Users](https://symfony.com/doc/current/security.html#authenticating-users) (`firewalls`)

  The firewall is the core of securing your application. Every request within the firewall is checked if it needs an authenticated user. The firewall also takes care of authenticating this user (e.g. using a login form);

  防火墙是你应用程序的安全核心。防火墙内的每个请求都会被检查是否需要一个认证的用户。当然防火墙也负责对该用户进行认证（例如，使用一个登录表格）；

- [Access Control (Authorization)](https://symfony.com/doc/current/security.html#access-control-authorization) (`access_control`)

  Using access control and the authorization checker, you control the required permissions to perform a specific action or visit a specific URL.

  使用访问控制和授权检查器，你可以控制执行特定动作或访问特定URL所需的权限。



## [The User](https://symfony.com/doc/current/security.html#the-user)

Permissions in Symfony are always linked to a user object. If you need to secure (parts of) your application, you need to create a user class. This is a class that implements [UserInterface](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Component/Security/Core/User/UserInterface.php). This is often a Doctrine entity, but you can also use a dedicated Security user class.

在Symfony中的权限总是与用户对象相关联。如果你需要保护你的应用程序（部分），你需要创建一个用户类。这是一个实现了[UserInterface](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Component/Security/Core/User/UserInterface.php)的类。通常是一个Doctrine实体，但你也可以使用一个专门的安全用户类。

The easiest way to generate a user class is using the `make:user` command from the [MakerBundle](https://symfony.com/doc/current/bundles/SymfonyMakerBundle/index.html):

生成一个用户类的最简单方法是使用[MakerBundle](https://symfony.com/doc/current/bundles/SymfonyMakerBundle/index.html)中的`make:user`命令：

```shell
$ php bin/console make:user
 The name of the security user class (e.g. User) [User]:
 > User

 Do you want to store user data in the database (via Doctrine)? (yes/no) [yes]:
 > yes

 Enter a property name that will be the unique "display" name for the user (e.g. email, username, uuid) [email]:
 > email

 Will this app need to hash/check user passwords? Choose No if passwords are not needed or will be checked/hashed by some other system (e.g. a single sign-on server).

 Does this app need to hash/check user passwords? (yes/no) [yes]:
 > yes

 created: src/Entity/User.php
 created: src/Repository/UserRepository.php
 updated: src/Entity/User.php
 updated: config/packages/security.yaml
```



```php
// src/Entity/User.php
namespace App\Entity;

use App\Repository\UserRepository;
use Doctrine\ORM\Mapping as ORM;
use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;
use Symfony\Component\Security\Core\User\UserInterface;

#[ORM\Entity(repositoryClass: UserRepository::class)]
class User implements UserInterface, PasswordAuthenticatedUserInterface
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column(type: 'integer')]
    private $id;

    #[ORM\Column(type: 'string', length: 180, unique: true)]
    private $email;

    #[ORM\Column(type: 'json')]
    private $roles = [];

    #[ORM\Column(type: 'string')]
    private $password;

    public function getId(): ?int
    {
        return $this->id;
    }

    public function getEmail(): ?string
    {
        return $this->email;
    }

    public function setEmail(string $email): self
    {
        $this->email = $email;

        return $this;
    }

    /**
     * The public representation of the user (e.g. a username, an email address, etc.)
     *
     * @see UserInterface
     */
    public function getUserIdentifier(): string
    {
        return (string) $this->email;
    }

    /**
     * @see UserInterface
     */
    public function getRoles(): array
    {
        $roles = $this->roles;
        // guarantee every user at least has ROLE_USER
        $roles[] = 'ROLE_USER';

        return array_unique($roles);
    }

    public function setRoles(array $roles): self
    {
        $this->roles = $roles;

        return $this;
    }

    /**
     * @see PasswordAuthenticatedUserInterface
     */
    public function getPassword(): string
    {
        return $this->password;
    }

    public function setPassword(string $password): self
    {
        $this->password = $password;

        return $this;
    }

    /**
     * Returning a salt is only needed if you are not using a modern
     * hashing algorithm (e.g. bcrypt or sodium) in your security.yaml.
     *
     * @see UserInterface
     */
    public function getSalt(): ?string
    {
        return null;
    }

    /**
     * @see UserInterface
     */
    public function eraseCredentials()
    {
        // If you store any temporary, sensitive data on the user, clear it here
        // $this->plainPassword = null;
    }
}
```

If your user is a Doctrine entity, like in the example above, don't forget to create the tables by [creating and running a migration](https://symfony.com/doc/current/doctrine.html#doctrine-creating-the-database-tables-schema):

如果你的用户是一个Doctrine实体，就像上面的例子一样，别忘了通过创建和运行迁移来创建表：

```
$ php bin/console make:migration
$ php bin/console doctrine:migrations:migrate
```



### [Loading the User: The User Provider](https://symfony.com/doc/current/security.html#loading-the-user-the-user-provider)

Besides creating the entity, the `make:user` command also adds config for a user provider in your security configuration:

除了创建实体，`make:user`命令还为安全配置中的用户提供者添加配置：

```yaml
# config/packages/security.yaml
security:
    # ...

    providers:
        app_user_provider:
            entity:
                class: App\Entity\User
                property: email
```

This user provider knows how to (re)load users from a storage (e.g. a database) based on a "user identifier" (e.g. the user's email address or username). The configuration above uses Doctrine to load the `User` entity using the `email` property as "user identifier".

这个用户提供者知道如何根据 "用户标识符"（如用户的电子邮件地址或用户名）从存储（如数据库）中（重新）加载用户。上面的配置使用Doctrine来加载`User`实体，使用`email`属性作为 "用户标识符"。

User providers are used in a couple places during the security lifecycle:

在安全生命周期中，用户提供者被用在几个地方：

- **Load the User based on an identifier**

  During login (or any other authenticator), the provider loads the user based on the user identifier. Some other features, like [user impersonation](https://symfony.com/doc/current/security/impersonating_user.html) and [Remember Me](https://symfony.com/doc/current/security/remember_me.html) also use this.

  在登录（或任何其他认证器）期间，提供者基于用户标识符加载用户。其他一些功能，如[user impersonation](https://symfony.com/doc/current/security/impersonating_user.html)和[remember me](https://symfony.com/doc/current/security/remember_me.html)也使用这个。

- **Reload the User from the session**

  At the beginning of each request, the user is loaded from the session (unless your firewall is `stateless`). The provider "refreshes" the user (e.g. the database is queried again for fresh data) to make sure all user information is up to date (and if necessary, the user is de-authenticated/logged out if something changed). See [Security](https://symfony.com/doc/current/security.html#user_session_refresh) for more information about this process.

  在每个请求的开始，用户加载于session中（除非你的防火墙是 "无状态"）。提供者会 "刷新 "用户（例如，再次查询数据库的新鲜数据），以确保所有的用户信息是最新的（如果有必要，在用户数据有变化时，可以取消认证用户/注销用户）。关于这个过程的更多信息，见[安全](https://symfony.com/doc/current/security.html#user_session_refresh)。

Symfony comes with several built-in user providers:

Symfony有几个内置的用户提供者：

- [Entity User Provider](https://symfony.com/doc/current/security/user_providers.html#security-entity-user-provider)

  Loads users from a database using [Doctrine](https://symfony.com/doc/current/doctrine.html);

- [LDAP User Provider](https://symfony.com/doc/current/security/ldap.html#security-ldap-user-provider)

  Loads users from a LDAP server;

  从LDAP服务器中加载用户；

- [Memory User Provider](https://symfony.com/doc/current/security/user_providers.html#security-memory-user-provider)

  Loads users from a configuration file;

  从一个配置文件中加载用户；

- [Chain User Provider](https://symfony.com/doc/current/security/user_providers.html#security-chain-user-provider)

  Merges two or more user providers into a new user provider. Since each firewall has exactly *one* user provider, you can use this to chain multiple providers together.

  将两个或多个用户提供者合并为一个新的用户提供者。由于每个防火墙正好有1个用户提供者，你可以用它来把多个提供者连在一起。

The built-in user providers cover the most common needs for applications, but you can also create your own [custom user provider](https://symfony.com/doc/current/security/user_providers.html#security-custom-user-provider).

内置的用户提供者涵盖了应用程序最常见的需求，但你也可以创建你自己的[自定义用户提供者](https://symfony.com/doc/current/security/user_providers.html#security-custom-user-provider)。

Sometimes, you need to inject the user provider in another class (e.g. in your custom authenticator). All user providers follow this pattern for their service ID: `security.user.provider.concrete.<your-provider-name>` (where `<your-provider-name>` is the configuration key, e.g. `app_user_provider`). If you only have one user provider, you can autowire it using the [UserProviderInterface](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Component/Security/Core/User/UserProviderInterface.php) type-hint.

有时，你需要在另一个类中注入用户提供者（例如，在你的自定义认证器中）。所有用户提供者的服务ID都遵循这个模式：`security.user.provider.concrete.<your-provider-name>`（其中`<your-provider-name>`是配置key，例如`app_user_provider`）。如果你只有一个用户提供者，你可以使用[UserProviderInterface](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Component/Security/Core/User/UserProviderInterface.php)类型提示自动连接它。



### [Registering the User: Hashing Passwords](https://symfony.com/doc/current/security.html#registering-the-user-hashing-passwords)

Many applications require a user to log in with a password. For these applications, the SecurityBundle provides password hashing and verification functionality.

许多应用程序要求用户用密码登录。对于这些应用，SecurityBundle提供了密码hashing和验证功能。

First, make sure your User class implements the [PasswordAuthenticatedUserInterface](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Component/Security/Core/User/PasswordAuthenticatedUserInterface.php):

首先，确保你的用户类实现了[PasswordAuthenticatedUserInterface](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Component/Security/Core/User/PasswordAuthenticatedUserInterface.php)：

```php
// src/Entity/User.php

// ...
use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;

class User implements UserInterface, PasswordAuthenticatedUserInterface
{
    // ...

    /**
     * @return string the hashed password for this user
     */
    public function getPassword(): string
    {
        return $this->password;
    }
}
```

Then, configure which password hasher should be used for this class. If your `security.yaml` file wasn't already pre-configured, then `make:user` should have done this for you:

然后，配置该类应使用的密码散列器。如果你的`security.yaml`文件没有预先配置，那么`make:user`应该已经为你做了这个：

```yaml
# config/packages/security.yaml
security:
    # ...
    password_hashers:
        # Use native password hasher, which auto-selects and migrates the best
        # possible hashing algorithm (which currently is "bcrypt")
        Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface: 'auto'
```

Now that Symfony knows *how* you want to hash the passwords, you can use the `UserPasswordHasherInterface` service to do this before saving your users to the database:

现在Symfony知道了你想用什么方式对密码进行hash，你可以使用 "UserPasswordHasherInterface "服务在将用户保存到数据库之前完成这一工作：

```php
// src/Controller/RegistrationController.php
namespace App\Controller;

// ...
use Symfony\Component\PasswordHasher\Hasher\UserPasswordHasherInterface;

class RegistrationController extends AbstractController
{
    public function index(UserPasswordHasherInterface $passwordHasher)
    {
        // ... e.g. get the user data from a registration form
        $user = new User(...);
        $plaintextPassword = ...;

        // hash the password (based on the security.yaml config for the $user class)
        $hashedPassword = $passwordHasher->hashPassword(
            $user,
            $plaintextPassword
        );
        $user->setPassword($hashedPassword);

        // ...
    }
}
```

The `make:registration-form` maker command can help you set-up the registration controller and add features like email address verification using the [SymfonyCastsVerifyEmailBundle](https://github.com/symfonycasts/verify-email-bundle).

`make:registration-form` maker命令可以帮助你设置注册控制器，并使用[SymfonyCastsVerifyEmailBundle](https://github.com/symfonycasts/verify-email-bundle)添加电子邮件地址验证等功能。

```
$ composer require symfonycasts/verify-email-bundle
$ php bin/console make:registration-form
```

You can also manually hash a password by running:

你也可以通过运行手动哈希密码：

```
$ php bin/console security:hash-password
```

Read more about all available hashers and password migration in [Password Hashing and Verification](https://symfony.com/doc/current/security/passwords.html).

在[Password Hashing and Verification](https://symfony.com/doc/current/security/passwords.html)中阅读更多关于所有可用的哈希器和密码迁移的信息。

> 6.2 In applications using Symfony 6.2 and PHP 8.2 or newer, the [SensitiveParameter PHP attribute](https://wiki.php.net/rfc/redact_parameters_in_back_traces) is applied to all plain passwords and sensitive tokens so they don't appear in stack traces.
>
> 6.2 在使用Symfony 6.2和PHP 8.2或更新版本的应用程序中，[SensitiveParameter PHP属性](https://wiki.php.net/rfc/redact_parameters_in_back_traces)被应用于所有普通密码和敏感令牌，因此它们不会出现在堆栈跟踪中。



## [The Firewall](https://symfony.com/doc/current/security.html#the-firewall)

The `firewalls` section of `config/packages/security.yaml` is the *most* important section. A "firewall" is your authentication system: the firewall defines which parts of your application are secured and *how* your users will be able to authenticate (e.g. login form, API token, etc).

`config/packages/security.yaml`中的`firewalls`部分是最重要的部分。防火墙是你的认证系统：防火墙定义了你的应用程序的哪部分是安全的，以及你的用户将能够以何种方式进行认证（例如，登录表格、API令牌等）。

```yaml
# config/packages/security.yaml
security:
    # ...
    firewalls:
        dev:
            pattern: ^/(_(profiler|wdt)|css|images|js)/
            security: false
        main:
            lazy: true
            # provider that you set earlier inside providers
            provider: app_user_provider

            # activate different ways to authenticate
            # https://symfony.com/doc/current/security.html#firewalls-authentication

            # https://symfony.com/doc/current/security/impersonating_user.html
            # switch_user: true
```

Only one firewall is active on each request: Symfony uses the `pattern` key to find the first match (you can also [match by host or other things](https://symfony.com/doc/current/security/firewall_restriction.html)).

对于每个请求只有一个防火墙处于活动状态： Symfony使用`pattern`键来寻找第一个匹配（你也可以[通过主机或其他东西匹配](https://symfony.com/doc/current/security/firewall_restriction.html)）。

The `dev` firewall is really a fake firewall: it makes sure that you don't accidentally block Symfony's dev tools - which live under URLs like `/_profiler` and `/_wdt`.

`dev`防火墙实际上是一个假的防火墙：它确保你不会意外地阻止Symfony的开发工具 - 存在于`/_profiler`和`/_wdt`这样的URL。

All *real* URLs are handled by the `main` firewall (no `pattern` key means it matches *all* URLs). A firewall can have many modes of authentication, in other words, it enables many ways to ask the question "Who are you?".

所有真实的URL都由`main`防火墙处理（没有`pattern`键意味着它匹配所有URL）。防火墙可以有许多认证模式，换句话说，它可以用许多方法来问 "你是谁？"的问题。

Often, the user is unknown (i.e. not logged in) when they first visit your website. If you visit your homepage right now, you *will* have access and you'll see that you're visiting a page behind the firewall in the toolbar:

通常情况下，当用户第一次访问你的网站时，他们是未知的（即没有登录）。如果你现在访问你的主页，你会有访问权，可以看到你正在访问工具栏中防火墙后面的页面：

![img](https://symfony.com/doc/6.2/_images/anonymous_wdt.png)

Visiting a URL under a firewall doesn't necessarily require you to be authenticated (e.g. the login form has to be accessible or some parts of your application are public). You'll learn how to restrict access to URLs, controllers or anything else within your firewall in the [access control](https://symfony.com/doc/current/security.html#security-access-control) section.

在防火墙下访问一个URL，不一定需要你进行身份验证（例如，登录表格必须可以访问，或者你的应用程序的某些部分是公开的）。你将在访问控制部分学习如何在你的防火墙内限制对URL、控制器或任何其他东西的访问。

> The `lazy` anonymous mode prevents the session from being started if there is no need for authorization (i.e. explicit check for a user privilege). This is important to keep requests cacheable (see [HTTP Cache](https://symfony.com/doc/current/http_cache.html)).
>
> 提示：如果不需要授权（即明确检查用户权限），懒惰的匿名模式会阻止会话的启动。这对于保持请求的可缓存性很重要（见HTTP缓存）。

If you do not see the toolbar, install the [profiler](https://symfony.com/doc/current/profiler.html) with:

如果你没有看到工具条，请用以下方式安装profiler：

```
$ composer require --dev symfony/profiler-pack
```

### [Fetching the Firewall Configuration for a Request](https://symfony.com/doc/current/security.html#fetching-the-firewall-configuration-for-a-request)

If you need to get the configuration of the firewall that matched a given request, use the [Security](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Bundle/SecurityBundle/Security.php) service:

如果你需要获得与给定请求相匹配的防火墙的配置，请使用[安全](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Bundle/SecurityBundle/Security.php)服务：

```php
// src/Service/ExampleService.php
// ...

use Symfony\Bundle\SecurityBundle\Security;
use Symfony\Component\HttpFoundation\RequestStack;

class ExampleService
{
    public function __construct(
        // Avoid calling getFirewallConfig() in the constructor: auth may not
        // be complete yet. Instead, store the entire Security object.
        private Security $security,
        RequestStack $requestStack,
    ) {
    }

    public function someMethod()
    {
        $request = $this->requestStack->getCurrentRequest();
        $firewallName = $this->security->getFirewallConfig($request)?->getName();

        // ...
    }
}
```

> 6.2 The `getFirewallConfig()` method was introduced in Symfony 6.2.



## [Authenticating Users](https://symfony.com/doc/current/security.html#authenticating-users)

During authentication, the system tries to find a matching user for the visitor of the webpage. Traditionally, this was done using a login form or a HTTP basic dialog in the browser. However, the SecurityBundle comes with many other authenticators:

在认证期间，系统试图为网页的访问者找到匹配的用户。传统上，这是使用登录表单或浏览器中的HTTP基本对话框来完成的。然而，SecurityBundle附带了许多认证器：

- [Form Login](https://symfony.com/doc/current/security.html#form-login)
- [JSON Login](https://symfony.com/doc/current/security.html#json-login)
- [HTTP Basic](https://symfony.com/doc/current/security.html#http-basic)
- [Login Link](https://symfony.com/doc/current/security.html#login-link)
- [X.509 Client Certificates](https://symfony.com/doc/current/security.html#x-509-client-certificates)
- [Remote users](https://symfony.com/doc/current/security.html#remote-users)
- [Custom Authenticators](https://symfony.com/doc/current/security/custom_authenticator.html)

If your application logs users in via a third-party service such as Google, Facebook or Twitter (social login), check out the [HWIOAuthBundle](https://github.com/hwi/HWIOAuthBundle) community bundle.

如果你的应用程序通过第三方服务如Google、Facebook或Twitter（社交登录）来登录用户，请查看[HWIOAuthBundle](https://github.com/hwi/HWIOAuthBundle)社区包。



### [Form Login](https://symfony.com/doc/current/security.html#form-login)

Most websites have a login form where users authenticate using an identifier (e.g. email address or username) and a password. This functionality is provided by the *form login authenticator*.

大多数网站都有一个登录表单，用户使用一个标识符（如电子邮件地址或用户名）和一个密码进行认证。这个功能是由*form login authenticator*提供的。

First, create a controller for the login form:

首先，为登录表单创建一个控制器：

```
$ php bin/console make:controller Login

 created: src/Controller/LoginController.php
 created: templates/login/index.html.twig
```



```php
// src/Controller/LoginController.php
namespace App\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;

class LoginController extends AbstractController
{
    #[Route('/login', name: 'app_login')]
    public function index(): Response
    {
        return $this->render('login/index.html.twig', [
            'controller_name' => 'LoginController',
        ]);
    }
}
```

Then, enable the form login authenticator using the `form_login` setting:

然后，使用`form_login`设置启用表单登录验证器：

```yaml
# config/packages/security.yaml
security:
    # ...

    firewalls:
        main:
            # ...
            form_login:
                # "app_login" is the name of the route created previously
                login_path: app_login
                check_path: app_login
```

The `login_path` and `check_path` support URLs and route names (but cannot have mandatory wildcards - e.g. `/login/{foo}` where `foo` has no default value).

`login_path`和`check_path`支持URL和路由名称（但不能有强制性的通配符 - 例如`/login/{foo}`，其中`foo`没有默认值）。

Once enabled, the security system redirects unauthenticated visitors to the `login_path` when they try to access a secured place (this behavior can be customized using [authentication entry points](https://symfony.com/doc/current/security/access_denied_handler.html#security-entry-point)).

一旦启用，安全系统会在未认证的访问者试图访问受保护的地方时将其重定向到`login_path`（这种行为可以使用[authentication entry points](https://symfony.com/doc/current/security/access_denied_handler.html#security-entry-point)来定制）。

Edit the login controller to render the login form:

编辑登录控制器来呈现登录表单：

```php
// ...
+ use Symfony\Component\Security\Http\Authentication\AuthenticationUtils;

  class LoginController extends AbstractController
  {
      #[Route('/login', name: 'app_login')]
-     public function index(): Response
+     public function index(AuthenticationUtils $authenticationUtils): Response
      {
+         // get the login error if there is one
+         $error = $authenticationUtils->getLastAuthenticationError();
+
+         // last username entered by the user
+         $lastUsername = $authenticationUtils->getLastUsername();
+
          return $this->render('login/index.html.twig', [
-             'controller_name' => 'LoginController',
+             'last_username' => $lastUsername,
+             'error'         => $error,
          ]);
      }
  }
```

Don't let this controller confuse you. Its job is only to *render* the form: the `form_login` authenticator will handle the form *submission* automatically. If the user submits an invalid email or password, that authenticator will store the error and redirect back to this controller, where we read the error (using `AuthenticationUtils`) so that it can be displayed back to the user.

不要让这个控制器迷惑到你。它的工作只是*render*表单：`form_login`认证器将自动处理表单的*submission*。如果用户提交了一个无效的电子邮件或密码，该认证器将存储错误并重定向到这个控制器，在那里我们读取错误（使用`AuthenticationUtils'），以便它可以显示给用户。

Finally, create or update the template:

最后，创建或更新模板：

```twig
{# templates/login/index.html.twig #}
{% extends 'base.html.twig' %}

{# ... #}

{% block body %}
    {% if error %}
        <div>{{ error.messageKey|trans(error.messageData, 'security') }}</div>
    {% endif %}

    <form action="{{ path('app_login') }}" method="post">
        <label for="username">Email:</label>
        <input type="text" id="username" name="_username" value="{{ last_username }}">

        <label for="password">Password:</label>
        <input type="password" id="password" name="_password">

        {# If you want to control the URL the user is redirected to on success
        <input type="hidden" name="_target_path" value="/account"> #}

        <button type="submit">login</button>
    </form>
{% endblock %}
```

> The `error` variable passed into the template is an instance of [AuthenticationException](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Component/Security/Core/Exception/AuthenticationException.php). It may contain sensitive information about the authentication failure. *Never* use `error.message`: use the `messageKey` property instead, as shown in the example. This message is always safe to display.
>
> 警告：传入模板的`error`变量是一个[AuthenticationException](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Component/Security/Core/Exception/AuthenticationException.php)的实例。它可能包含关于认证失败的敏感信息。*千万不要*使用`error.message`：使用`messageKey`属性代替，如例子所示。这个消息的显示总是安全的。

The form can look like anything, but it usually follows some conventions:

表单可以看起来像任何东西，但它通常遵循一些惯例：

- The `<form>` element sends a `POST` request to the `app_login` route, since that's what you configured as the `check_path` under the `form_login` key in `security.yaml`;

  `<form>`元素向`app_login`路由发送`POST`请求，这是因为在`security.yaml`的`form_login` key下配置的`check_path`；

- The username (or whatever your user's "identifier" is, like an email) field has the name `_username` and the password field has the name `_password`.

  用户名（或用户的“标识符”，如电子邮件）字段的名称为“\_username”，密码字段的名称是“_password”。

> Actually, all of this can be configured under the `form_login` key. See [Security Configuration Reference (SecurityBundle)](https://symfony.com/doc/current/reference/configuration/security.html#reference-security-firewall-form-login) for more details.
>
> 提示：实际上，所有这些都可以在`form_login`键下进行配置。更多细节见[安全配置参考（SecurityBundle）](https://symfony.com/doc/current/reference/configuration/security.html#reference-security-firewall-form-login)。

> This login form is currently not protected against CSRF attacks. Read [Security](https://symfony.com/doc/current/security.html#form_login-csrf) on how to protect your login form.
>
> 警告：这个登录表格目前没有针对CSRF攻击的保护。请阅读[安全](https://symfony.com/doc/current/security.html#form_login-csrf)，了解如何保护你的登录表格。

And that's it! When you submit the form, the security system automatically reads the `_username` and `_password` POST parameter, loads the user via the user provider, checks the user's credentials and either authenticates the user or sends them back to the login form where the error can be displayed.

就这样了! 当你提交表单时，安全系统会自动读取\_username和\_password POST参数，通过用户提供者加载用户，检查用户的证书，并且要么验证用户，要么将他们送回登录表单，在那里可以显示错误。

To review the whole process:

来回顾一下整个过程：

1. The user tries to access a resource that is protected (e.g. `/admin`);

   用户试图访问一个受保护的资源（例如：/admin）；

2. The firewall initiates the authentication process by redirecting the user to the login form (`/login`);

   防火墙通过将用户重定向到登录表格（/login）来启动认证过程；

3. The `/login` page renders login form via the route and controller created in this example;

   /login页面通过本例中创建的路由和控制器渲染登录表单；

4. The user submits the login form to `/login`;

   用户提交登录表单到/login；

5. The security system (i.e. the `form_login` authenticator) intercepts the request, checks the user's submitted credentials, authenticates the user if they are correct, and sends the user back to the login form if they are not.

   安全系统（即form_login认证器）拦截请求，检查用户提交的凭证，如果正确则验证用户，如果不正确则将用户送回登录表。

> You can customize the responses on a successful or failed login attempt. See [Customizing the Form Login Authenticator Responses](https://symfony.com/doc/current/security/form_login.html).
>
> 提示：你可以自定义登录尝试成功或失败时的响应。参见自定义表单登录验证器的响应。



#### [CSRF Protection in Login Forms](https://symfony.com/doc/current/security.html#csrf-protection-in-login-forms)

[Login CSRF attacks](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests) can be prevented using the same technique of adding hidden CSRF tokens into the login forms. The Security component already provides CSRF protection, but you need to configure some options before using it.

登录CSRF攻击可以使用同样的技术来防止，即在登录表单中添加隐藏的CSRF令牌。安全组件已经提供了CSRF保护，但是你需要在使用它之前配置一些选项。

First, you need to enable CSRF on the form login:

首先，你需要在登录表单上启用CSRF：

```yaml
# config/packages/security.yaml
security:
    # ...

    firewalls:
        secured_area:
            # ...
            form_login:
                # ...
                enable_csrf: true
```

Then, use the `csrf_token()` function in the Twig template to generate a CSRF token and store it as a hidden field of the form. By default, the HTML field must be called `_csrf_token` and the string used to generate the value must be `authenticate`:

```twig
{# templates/login/index.html.twig #}

{# ... #}
<form action="{{ path('app_login') }}" method="post">
    {# ... the login fields #}

    <input type="hidden" name="_csrf_token" value="{{ csrf_token('authenticate') }}">

    <button type="submit">login</button>
</form>
```

After this, you have protected your login form against CSRF attacks.

在这之后，你已经保护了你的登录表单免受CSRF攻击。

> You can change the name of the field by setting `csrf_parameter` and change the token ID by setting `csrf_token_id` in your configuration. See [Security Configuration Reference (SecurityBundle)](https://symfony.com/doc/current/reference/configuration/security.html#reference-security-firewall-form-login) for more details.
>
> 提示：你可以通过设置`csrf_parameter`来改变字段的名称，通过设置`csrf_token_id`来改变配置中的token ID。更多细节请参见[安全配置参考（SecurityBundle）](https://symfony.com/doc/current/reference/configuration/security.html#reference-security-firewall-form-login)。



### [JSON Login](https://symfony.com/doc/current/security.html#json-login)

Some applications provide an API that is secured using tokens. These applications may use an endpoint that provides these tokens based on a username (or email) and password. The JSON login authenticator helps you create this functionality.

一些应用程序提供了一个使用令牌的安全API。这些应用程序可能使用一个端点，根据用户名（或电子邮件）和密码提供这些令牌。JSON登录认证器帮助你创建这种功能。

Enable the authenticator using the `json_login` setting:

使用json_login设置启用认证器：

```yaml
# config/packages/security.yaml
security:
    # ...

    firewalls:
        main:
            # ...
            json_login:
                # api_login is a route we will create below
                check_path: api_login
```

> The `check_path` supports URLs and route names (but cannot have mandatory wildcards - e.g. `/login/{foo}` where `foo` has no default value).
>
> check_path支持URL和路由名称（但不能有强制性的通配符--例如/login/{foo}，其中foo没有默认值）。

The authenticator runs when a client requests the `check_path`. First, create a controller for this path:

当客户端请求check_path时，认证器会运行。首先，为这个路径创建一个控制器：

```
$ php bin/console make:controller --no-template ApiLogin

 created: src/Controller/ApiLoginController.php
```



```php
// src/Controller/ApiLoginController.php
namespace App\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;

class ApiLoginController extends AbstractController
{
    #[Route('/api/login', name: 'api_login')]
    public function index(): Response
    {
        return $this->json([
            'message' => 'Welcome to your new controller!',
            'path' => 'src/Controller/ApiLoginController.php',
        ]);
    }
}
```

This login controller will be called after the authenticator successfully authenticates the user. You can get the authenticated user, generate a token (or whatever you need to return) and return the JSON response:

这个登录控制器将在认证器成功认证用户后被调用。你可以获得认证的用户，生成一个令牌（或任何你需要返回的东西）并返回JSON响应：

```php
// ...
+ use App\Entity\User;
+ use Symfony\Component\Security\Http\Attribute\CurrentUser;

  class ApiLoginController extends AbstractController
  {
      #[Route('/api/login', name: 'api_login')]
-     public function index(): Response
+     public function index(#[CurrentUser] ?User $user): Response
      {
+         if (null === $user) {
+             return $this->json([
+                 'message' => 'missing credentials',
+             ], Response::HTTP_UNAUTHORIZED);
+         }
+
+         $token = ...; // somehow create an API token for $user
+
          return $this->json([
-             'message' => 'Welcome to your new controller!',
-             'path' => 'src/Controller/ApiLoginController.php',
+             'user'  => $user->getUserIdentifier(),
+             'token' => $token,
          ]);
      }
  }
```

> The `#[CurrentUser]` can only be used in controller arguments to retrieve the authenticated user. In services, you would use [getUser()](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Component/Security/Core/Security.php#method_getUser).
>
> \#[CurrentUser]只能在控制器参数中使用，以检索认证的用户。在服务中，你会使用getUser()。

That's it! To summarize the process:

就这样吧!总结一下这个过程：

1. A client (e.g. the front-end) makes a *POST request* with the `Content-Type: application/json` header to `/api/login` with `username` (even if your identifier is actually an email) and `password` keys:

   客户端（例如前端）向/api/login发出一个带有Content-Type: application/json头的POST请求，其中包括用户名（即使你的标识符实际上是一个电子邮件）和密码键：

   ```json
   {
       "username": "dunglas@example.com",
       "password": "MyPassword"
   }
   ```

2. The security system intercepts the request, checks the user's submitted credentials and authenticates the user. If the credentials are incorrect, an HTTP 401 Unauthorized JSON response is returned, otherwise your controller is run;

   安全系统拦截请求，检查用户提交的凭证并验证用户的身份。如果凭证不正确，就会返回HTTP 401 Unauthorized JSON响应，否则就会运行你的控制器；

3. Your controller creates the correct response:

   你的控制器创建正确的响应：

   ```json
   {
       "user": "dunglas@example.com",
       "token": "45be42..."
   }
   ```

> The JSON request format can be configured under the `json_login` key. See [Security Configuration Reference (SecurityBundle)](https://symfony.com/doc/current/reference/configuration/security.html#reference-security-firewall-json-login) for more details.
>
> 提示：JSON请求格式可以在json_login键下进行配置。更多细节见安全配置参考（SecurityBundle）。

### [HTTP Basic](https://symfony.com/doc/current/security.html#http-basic)

[HTTP Basic authentication](https://en.wikipedia.org/wiki/Basic_access_authentication) is a standardized HTTP authentication framework. It asks credentials (username and password) using a dialog in the browser and the HTTP basic authenticator of Symfony will verify these credentials.

HTTP基本认证是一个标准化的HTTP认证框架。它使用浏览器中的对话框询问凭证（用户名和密码），Symfony的HTTP基本认证器将验证这些凭证。

Add the `http_basic` key to your firewall to enable HTTP Basic authentication:

将http_basic密钥添加到你的防火墙，以启用HTTP Basic认证：

```
# config/packages/security.yaml
security:
    # ...

    firewalls:
        main:
            # ...
            http_basic:
                realm: Secured Area
```

That's it! Whenever an unauthenticated user tries to visit a protected page, Symfony will inform the browser that it needs to start HTTP basic authentication (using the `WWW-Authenticate` response header). Then, the authenticator verifies the credentials and authenticates the user.

这就是了!每当一个未经认证的用户试图访问一个受保护的页面时，Symfony会通知浏览器它需要启动HTTP基本认证（使用WWW-Authenticate响应头）。然后，认证器会验证凭证，并对用户进行认证。

> You cannot use [log out](https://symfony.com/doc/current/security.html#security-logging-out) with the HTTP basic authenticator. Even if you log out from Symfony, your browser "remembers" your credentials and will send them on every request.
>
> 注：你不能用HTTP基本认证器进行注销。即使你从Symfony注销，你的浏览器也会 "记住 "你的凭证，并在每次请求时发送这些凭证。

### [Login Link](https://symfony.com/doc/current/security.html#login-link)

Login links are a passwordless authentication mechanism. The user will receive a short-lived link (e.g. via email) which will authenticate them to the website.

登录链接是一种无密码认证机制。用户将收到一个短暂的链接（例如通过电子邮件），该链接将对他们进行网站认证。

You can learn all about this authenticator in [How to use Passwordless Login Link Authentication](https://symfony.com/doc/current/security/login_link.html).

你可以在《如何使用无密码登录链接认证》中了解这种认证器的全部内容。

### [Access Tokens](https://symfony.com/doc/current/security.html#access-tokens)

Access Tokens are often used in API contexts. The user receives a token from an authorization server which authenticates them.

You can learn all about this authenticator in [How to use Access Token Authentication](https://symfony.com/doc/current/security/access_token.html).

访问令牌经常被用于API环境中。用户从授权服务器上收到一个令牌，该令牌对他们进行认证。

你可以在《如何使用访问令牌认证》中了解关于这种认证器的所有信息。

### [X.509 Client Certificates](https://symfony.com/doc/current/security.html#x-509-client-certificates)

When using client certificates, your web server does all the authentication itself. The X.509 authenticator provided by Symfony extracts the email from the "distinguished name" (DN) of the client certificate. Then, it uses this email as user identifier in the user provider.

当使用客户证书时，你的Web服务器自己做所有的认证。Symfony提供的X.509认证器从客户证书的 "区分名称"（DN）中提取电子邮件。然后，它在用户提供者中使用这个电子邮件作为用户标识。

First, configure your web server to enable client certificate verification and to expose the certificate's DN to the Symfony application:

首先，配置你的Web服务器，使客户证书验证生效，并将证书的DN暴露给Symfony应用程序：

```
server {
    # ...

    ssl_client_certificate /path/to/my-custom-CA.pem;

    # enable client certificate verification
    ssl_verify_client optional;
    ssl_verify_depth 1;

    location / {
        # pass the DN as "SSL_CLIENT_S_DN" to the application
        fastcgi_param SSL_CLIENT_S_DN $ssl_client_s_dn;

        # ...
    }
}
```

Then, enable the X.509 authenticator using `x509` on your firewall:

然后，在你的防火墙上使用x509启用X.509认证器：

```
# config/packages/security.yaml
security:
    # ...

    firewalls:
        main:
            # ...
            x509:
                provider: your_user_provider
```

By default, Symfony extracts the email address from the DN in two different ways:

默认情况下，Symfony以两种不同的方式从DN中提取电子邮件地址：

1. First, it tries the `SSL_CLIENT_S_DN_Email` server parameter, which is exposed by Apache;

   首先，它尝试SSL_CLIENT_S_DN_Email服务器参数，这是由Apache暴露的；

2. If it is not set (e.g. when using Nginx), it uses `SSL_CLIENT_S_DN` and matches the value following `emailAddress=`.

   如果没有设置（例如，当使用Nginx时），它会使用SSL_CLIENT_S_DN并匹配emailAddress=之后的值。

You can customize the name of both parameters under the `x509` key. See [the configuration reference](https://symfony.com/doc/current/reference/configuration/security.html#reference-security-firewall-x509) for more details.
你可以自定义x509密钥下的两个参数的名称。更多细节见配置参考。



### [Remote Users](https://symfony.com/doc/current/security.html#remote-users)

Besides client certificate authentication, there are more web server modules that pre-authenticate a user (e.g. kerberos). The remote user authenticator provides a basic integration for these services.

除了客户端证书认证，还有更多的Web服务器模块可以预先认证用户（例如kerberos）。远程用户认证器为这些服务提供了一个基本的集成。

These modules often expose the authenticated user in the `REMOTE_USER` environment variable. The remote user authenticator uses this value as the user identifier to load the corresponding user.

这些模块通常在REMOTE_USER环境变量中公开认证的用户。远程用户认证器使用这个值作为用户标识符来加载相应的用户。

Enable remote user authentication using the `remote_user` key:

使用remote_user密钥启用远程用户认证：

```
# config/packages/security.yaml
security:
    firewalls:
        main:
            # ...
            remote_user:
                provider: your_user_provider
```

> You can customize the name of this server variable under the `remote_user` key. See [the configuration reference](https://symfony.com/doc/current/reference/configuration/security.html#reference-security-firewall-remote-user) for more details.
>
> 提示：你可以在remote_user键下自定义这个服务器变量的名称。更多细节请参见配置参考。



### [Limiting Login Attempts](https://symfony.com/doc/current/security.html#limiting-login-attempts)

Symfony provides basic protection against [brute force login attacks](https://owasp.org/www-community/controls/Blocking_Brute_Force_Attacks). You must enable this using the `login_throttling` setting:

Symfony提供了基本的保护，防止暴力登录攻击。你必须使用login_throttling设置来启用它：

```
# config/packages/security.yaml
security:

    firewalls:
        # ...

        main:
            # ...

            # by default, the feature allows 5 login attempts per minute
            login_throttling: null

            # configure the maximum login attempts
            login_throttling:
                max_attempts: 3          # per minute ...
                # interval: '15 minutes' # ... or in a custom period

            # use a custom rate limiter via its service ID
            login_throttling:
                limiter: app.my_login_rate_limiter
```

> The value of the `interval` option must be a number followed by any of the units accepted by the [PHP date relative formats](https://www.php.net/datetime.formats.relative) (e.g. `3 seconds`, `10 hours`, `1 day`, etc.)
>
> 注：间隔选项的值必须是一个数字，后面是PHP日期相对格式所接受的任何单位（例如3秒，10小时，1天，等等）。

Internally, Symfony uses the [Rate Limiter component](https://symfony.com/doc/current/rate_limiter.html) which by default uses Symfony's cache to store the previous login attempts. However, you can implement a [custom storage](https://symfony.com/doc/current/rate_limiter.html#rate-limiter-storage).

在内部，Symfony使用Rate Limiter组件，它默认使用Symfony的缓存来存储以前的登录尝试。然而，你可以实现一个自定义的存储。

Login attempts are limited on `max_attempts` (default: 5) failed requests for `IP address + username` and `5 * max_attempts` failed requests for `IP address`. The second limit protects against an attacker using multiple usernames from bypassing the first limit, without disrupting normal users on big networks (such as offices).

登录尝试被限制在IP地址+用户名的max_attempts（默认：5）失败请求和IP地址的5*max_attempts失败请求。第二个限制可以防止使用多个用户名的攻击者绕过第一个限制，而不影响大网络（如办公室）中的正常用户。

> 提示：Limiting the failed login attempts is only one basic protection against brute force attacks. The [OWASP Brute Force Attacks](https://owasp.org/www-community/controls/Blocking_Brute_Force_Attacks) guidelines mention several other protections that you should consider depending on the level of protection required.限制失败的登录尝试只是防止蛮力攻击的一个基本保护措施。OWASP暴力攻击指南提到了其他几种保护措施，你应该根据所需的保护级别来考虑。

If you need a more complex limiting algorithm, create a class that implements [RequestRateLimiterInterface](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Component/HttpFoundation/RateLimiter/RequestRateLimiterInterface.php) (or use [DefaultLoginRateLimiter](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Component/Security/Http/RateLimiter/DefaultLoginRateLimiter.php)) and set the `limiter` option to its service ID:

如果你需要更复杂的限制算法，创建一个实现RequestRateLimiterInterface的类（或使用DefaultLoginRateLimiter），并将限制器选项设置为其服务ID：

```yaml
# config/packages/security.yaml
framework:
    rate_limiter:
        # define 2 rate limiters (one for username+IP, the other for IP)
        username_ip_login:
            policy: token_bucket
            limit: 5
            rate: { interval: '5 minutes' }

        ip_login:
            policy: sliding_window
            limit: 50
            interval: '15 minutes'

services:
    # our custom login rate limiter
    app.login_rate_limiter:
        class: Symfony\Component\Security\Http\RateLimiter\DefaultLoginRateLimiter
        arguments:
            # globalFactory is the limiter for IP
            $globalFactory: '@limiter.ip_login'
            # localFactory is the limiter for username+IP
            $localFactory: '@limiter.username_ip_login'

security:
    firewalls:
        main:
            # use a custom rate limiter via its service ID
            login_throttling:
                limiter: app.login_rate_limiter
```



## [Login Programmatically](https://symfony.com/doc/current/security.html#login-programmatically)

> 6.2 The [Symfony\Bundle\SecurityBundle\Security](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Bundle/SecurityBundle/Security.php) class was introduced in Symfony 6.2. Prior to 6.2, it was called `Symfony\Component\Security\Core\Security`.
>
> 6.2 Symfony/Bundle/SecurityBundle/Security类是在Symfony 6.2中引入的。在6.2之前，它被称为Symfony\Component\Security\Core\Security。

> 6.2 The [login()](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Bundle/SecurityBundle/Security.php#method_login) method was introduced in Symfony 6.2.
>
> 6.2 login()方法是在Symfony 6.2中引入的。

You can log in a user programmatically using the `login()` method of the [Security](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Bundle/SecurityBundle/Security.php) helper:

你可以使用Security帮助器的login()方法以编程方式登录用户：

```php
// src/Controller/SecurityController.php
namespace App\Controller\SecurityController;

use App\Security\Authenticator\ExampleAuthenticator;
use Symfony\Bundle\SecurityBundle\Security;

class SecurityController
{
    public function someAction(Security $security): Response
    {
        // get the user to be authenticated
        $user = ...;

        // log the user in on the current firewall
        $security->login($user);

        // if the firewall has more than one authenticator, you must pass it explicitly
        // by using the name of built-in authenticators...
        $security->login($user, 'form_login');
        // ...or the service id of custom authenticators
        $security->login($user, ExampleAuthenticator::class);

        // you can also log in on a different firewall
        $security->login($user, 'form_login', 'other_firewall');

        // ... redirect the user, e.g. to their account page
    }
}
```



## [Logging Out](https://symfony.com/doc/current/security.html#logging-out)

To enable logging out, activate the `logout` config parameter under your firewall:

要启用注销，在你的防火墙下激活注销配置参数：

```
# config/packages/security.yaml
security:
    # ...

    firewalls:
        main:
            # ...
            logout:
                path: app_logout

                # where to redirect after logout
                # target: app_any_route
```

Next, you need to create a route for this URL (but not a controller):

接下来，你需要为这个URL创建一个路由（但不是一个控制器）：

```
# config/routes.yaml
app_logout:
    path: /logout
    methods: GET
```

That's it! By sending a user to the `app_logout` route (i.e. to `/logout`) Symfony will un-authenticate the current user and redirect them.

这就是了! 通过将用户发送到app_logout路由（即/logout），Symfony将取消对当前用户的认证并重定向他们。

### [Logout programmatically](https://symfony.com/doc/current/security.html#logout-programmatically)

> 6.2 The [Symfony\Bundle\SecurityBundle\Security](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Bundle/SecurityBundle/Security.php) class was introduced in Symfony 6.2. Prior to 6.2, it was called `Symfony\Component\Security\Core\Security`.

> 6.2 The [logout()](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Bundle/SecurityBundle/Security.php#method_logout) method was introduced in Symfony 6.2.

You can logout user programmatically using the `logout()` method of the [Security](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Bundle/SecurityBundle/Security.php) helper:

你可以使用安全辅助工具的logout()方法以编程方式注销用户：

```
// src/Controller/SecurityController.php
namespace App\Controller\SecurityController;

use Symfony\Bundle\SecurityBundle\Security;

class SecurityController
{
    public function someAction(Security $security): Response
    {
        // logout the user in on the current firewall
        $response = $security->logout();

        // you can also disable the csrf logout
        $response = $security->logout(false);

        // ... return $response (if set) or e.g. redirect to the homepage
    }
}
```

The user will be logout from the firewall of the request. If the request is not behind a firewall a `\LogicException` will be thrown.

用户将从该请求的防火墙中注销。如果请求不在防火墙后面，就会抛出一个\LogicException。

### [Customizing Logout](https://symfony.com/doc/current/security.html#customizing-logout)

In some cases you need to run extra logic upon logout (e.g. invalidate some tokens) or want to customize what happens after a logout. During logout, a [LogoutEvent](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Component/Security/Http/Event/LogoutEvent.php) is dispatched. Register an [event listener or subscriber](https://symfony.com/doc/current/event_dispatcher.html) to execute custom logic:

在某些情况下，你需要在注销时运行额外的逻辑（例如，使某些令牌无效），或者想要定制注销后发生的事情。在注销期间，一个LogoutEvent被派发。注册一个事件监听器或订阅器来执行自定义逻辑：

```php
// src/EventListener/LogoutSubscriber.php
namespace App\EventListener;

use Symfony\Component\EventDispatcher\EventSubscriberInterface;
use Symfony\Component\HttpFoundation\RedirectResponse;
use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
use Symfony\Component\Security\Http\Event\LogoutEvent;

class LogoutSubscriber implements EventSubscriberInterface
{
    public function __construct(
        private UrlGeneratorInterface $urlGenerator
    ) {
    }

    public static function getSubscribedEvents(): array
    {
        return [LogoutEvent::class => 'onLogout'];
    }

    public function onLogout(LogoutEvent $event): void
    {
        // get the security token of the session that is about to be logged out
        $token = $event->getToken();

        // get the current request
        $request = $event->getRequest();

        // get the current response, if it is already set by another listener
        $response = $event->getResponse();

        // configure a custom logout response to the homepage
        $response = new RedirectResponse(
            $this->urlGenerator->generate('homepage'),
            RedirectResponse::HTTP_SEE_OTHER
        );
        $event->setResponse($response);
    }
}
```



## [Fetching the User Object](https://symfony.com/doc/current/security.html#fetching-the-user-object)

After authentication, the `User` object of the current user can be accessed via the `getUser()` shortcut in the [base controller](https://symfony.com/doc/current/controller.html#the-base-controller-class-services):

在认证之后，当前用户的User对象可以通过基础控制器中的getUser()快捷方式访问：

```php
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;

class ProfileController extends AbstractController
{
    public function index(): Response
    {
        // usually you'll want to make sure the user is authenticated first,
        // see "Authorization" below
        $this->denyAccessUnlessGranted('IS_AUTHENTICATED_FULLY');

        // returns your User object, or null if the user is not authenticated
        // use inline documentation to tell your editor your exact User class
        /** @var \App\Entity\User $user */
        $user = $this->getUser();

        // Call whatever methods you've added to your User class
        // For example, if you added a getFirstName() method, you can use that.
        return new Response('Well hi there '.$user->getFirstName());
    }
}
```

### [Fetching the User from a Service](https://symfony.com/doc/current/security.html#fetching-the-user-from-a-service)

If you need to get the logged in user from a service, use the [Security](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Bundle/SecurityBundle/Security.php) service:

如果你需要从一个服务中获取登录的用户，请使用安全服务：

```php
// src/Service/ExampleService.php
// ...

use Symfony\Bundle\SecurityBundle\Security;

class ExampleService
{
    // Avoid calling getUser() in the constructor: auth may not
    // be complete yet. Instead, store the entire Security object.
    public function __construct(
        private Security $security,
    ){
    }

    public function someMethod()
    {
        // returns User object or null if not authenticated
        $user = $this->security->getUser();

        // ...
    }
}
```

> 6.2 The [Security](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Bundle/SecurityBundle/Security.php) class was introduced in Symfony 6.2. In previous Symfony versions this class was defined in `Symfony\Component\Security\Core\Security`.

### [Fetch the User in a Template](https://symfony.com/doc/current/security.html#fetch-the-user-in-a-template)

In a Twig Template the user object is available via the `app.user` variable thanks to the [Twig global app variable](https://symfony.com/doc/current/templates.html#twig-app-variable):

```
{% if is_granted('IS_AUTHENTICATED_FULLY') %}
    <p>Email: {{ app.user.email }}</p>
{% endif %}
```



## [Access Control (Authorization)](https://symfony.com/doc/current/security.html#access-control-authorization)

Users can now log in to your app using your login form. Great! Now, you need to learn how to deny access and work with the User object. This is called **authorization**, and its job is to decide if a user can access some resource (a URL, a model object, a method call, ...).

用户现在可以使用你的登录表格登录到你的应用程序。接着你需要学习如何拒绝访问并与用户对象一起工作。这被称为授权，它的工作是决定一个用户是否可以访问一些资源（一个URL、一个模型对象、一个方法调用......）。

The process of authorization has two different sides:

授权过程有两个不同的方面：

1. The user receives a specific role when logging in (e.g. `ROLE_ADMIN`).

   用户在登录时得到一个特定的角色（例如ROLLE_ADMIN）。

2. You add code so that a resource (e.g. URL, controller) requires a specific "attribute" (e.g. a role like `ROLE_ADMIN`) in order to be accessed.
   你添加代码，使一个资源（如URL，控制器）需要一个特定的 "属性"（如ROLE_ADMIN这样的角色）才能被访问。



### [Roles](https://symfony.com/doc/current/security.html#roles)

When a user logs in, Symfony calls the `getRoles()` method on your `User` object to determine which roles this user has. In the `User` class that was generated earlier, the roles are an array that's stored in the database and every user is *always* given at least one role: `ROLE_USER`:

当用户登录时，Symfony会调用用户对象上的getRoles()方法来确定这个用户有哪些角色。在前面生成的User类中，角色是一个存储在数据库中的数组，每个用户总是被赋予至少一个角色：ROLE_USER：

```php
// src/Entity/User.php

// ...
class User
{
    #[ORM\Column(type: 'json')]
    private $roles = [];

    // ...
    public function getRoles(): array
    {
        $roles = $this->roles;
        // guarantee every user at least has ROLE_USER
        $roles[] = 'ROLE_USER';

        return array_unique($roles);
    }
}
```

This is a nice default, but you can do *whatever* you want to determine which roles a user should have. The only rule is that every role **must start with** the `ROLE_` prefix - otherwise, things won't work as expected. Other than that, a role is just a string and you can invent whatever you need (e.g. `ROLE_PRODUCT_ADMIN`).

这是一个很好的默认值，但是你可以做任何你想做的事情来决定一个用户应该有哪些角色。唯一的规则是，每个角色都必须以ROLLE_前缀开始 - 否则，事情就不会像预期的那样进行。除此以外，角色只是一个字符串，你可以发明任何你需要的东西（例如，ROLLE_PRODUCT_ADMIN）。

You'll use these roles next to grant access to specific sections of your site.

接下来你将使用这些角色来授予你网站的特定部分的访问权。



#### [Hierarchical Roles](https://symfony.com/doc/current/security.html#hierarchical-roles)

Instead of giving many roles to each user, you can define role inheritance rules by creating a role hierarchy:

你可以通过创建一个角色层次结构来定义角色继承规则，而不是给每个用户许多角色：

```yaml
# config/packages/security.yaml
security:
    # ...

    role_hierarchy:
        ROLE_ADMIN:       ROLE_USER
        ROLE_SUPER_ADMIN: [ROLE_ADMIN, ROLE_ALLOWED_TO_SWITCH]
```

Users with the `ROLE_ADMIN` role will also have the `ROLE_USER` role. Users with `ROLE_SUPER_ADMIN`, will automatically have `ROLE_ADMIN`, `ROLE_ALLOWED_TO_SWITCH` and `ROLE_USER` (inherited from `ROLE_ADMIN`).

拥有ROLE_ADMIN角色的用户也将拥有ROLE_USER角色。拥有ROLE_SUPER_ADMIN的用户，将自动拥有ROLE_ADMIN、ROLE_ALLOWED_TO_SWITCH和ROLE_USER（继承自ROLE_ADMIN）。

> For role hierarchy to work, do not use `$user->getRoles()` manually. For example, in a controller extending from the [base controller](https://symfony.com/doc/current/controller.html#the-base-controller-class-services):
>
> 为了使角色等级制度发挥作用，不要手动使用$user->getRoles()。例如，在一个从基础控制器延伸出来的控制器中：
>
> ```php
> // BAD - $user->getRoles() will not know about the role hierarchy
> $hasAccess = in_array('ROLE_ADMIN', $user->getRoles());
> 
> // GOOD - use of the normal security methods
> $hasAccess = $this->isGranted('ROLE_ADMIN');
> $this->denyAccessUnlessGranted('ROLE_ADMIN');
> ```

> The `role_hierarchy` values are static - you can't, for example, store the role hierarchy in a database. If you need that, create a custom [security voter](https://symfony.com/doc/current/security/voters.html) that looks for the user roles in the database.
>
> role_hierarchy值是静态的--例如，你不能在数据库中存储角色层次结构。如果你需要，创建一个自定义的安全选民，在数据库中寻找用户角色。



### [Add Code to Deny Access](https://symfony.com/doc/current/security.html#add-code-to-deny-access)

There are **two** ways to deny access to something:

有两种方法可以拒绝对某对象的访问：

1. [access_control in security.yaml](https://symfony.com/doc/current/security.html#security-authorization-access-control) allows you to protect URL patterns (e.g. `/admin/*`). Simpler, but less flexible;

   security.yaml中的access_control允许你以URL模式进行保护（例如/admin/*），这个很简单但不太灵活；

2. [in your controller (or other code)](https://symfony.com/doc/current/security.html#security-securing-controller).

   在你的控制器（或其他代码）中。



#### [Securing URL patterns (access_control)](https://symfony.com/doc/current/security.html#securing-url-patterns-access-control)

The most basic way to secure part of your app is to secure an entire URL pattern in `security.yaml`. For example, to require `ROLE_ADMIN` for all URLs that start with `/admin`, you can:

保护你的应用程序的部分安全的最基本方法是在security.yaml中保护整个URL模式。例如，要对所有以/admin开头的URL要求ROLE_ADMIN，你可以：

```yaml
# config/packages/security.yaml
security:
    # ...

    firewalls:
        # ...
        main:
            # ...

    access_control:
        # require ROLE_ADMIN for /admin*
        - { path: '^/admin', roles: ROLE_ADMIN }

        # or require ROLE_ADMIN or IS_AUTHENTICATED_FULLY for /admin*
        - { path: '^/admin', roles: [IS_AUTHENTICATED_FULLY, ROLE_ADMIN] }

        # the 'path' value can be any valid regular expression
        # (this one will match URLs like /api/post/7298 and /api/comment/528491)
        - { path: ^/api/(post|comment)/\d+$, roles: ROLE_USER }
```

You can define as many URL patterns as you need - each is a regular expression. **BUT**, only **one** will be matched per request: Symfony starts at the top of the list and stops when it finds the first match:

你可以根据需要定义任意多的URL模式 - 每个模式都是一个正则表达式。但是每个请求只能匹配一个URI模式：Symfony从列表的顶部开始，当它找到第一个匹配时就停止：

```yaml
# config/packages/security.yaml
security:
    # ...

    access_control:
        # matches /admin/users/*
        - { path: '^/admin/users', roles: ROLE_SUPER_ADMIN }

        # matches /admin/* except for anything matching the above rule
        - { path: '^/admin', roles: ROLE_ADMIN }
```

Prepending the path with `^` means that only URLs *beginning* with the pattern are matched. For example, a path of `/admin` (without the `^`) would match `/admin/foo` but would also match URLs like `/foo/admin`.

在路径前加^意味着只匹配以模式开头的URL。例如，一个/admin的路径（没有^）会匹配/admin/foo，但也会匹配/foo/admin这样的URL。

Each `access_control` can also match on IP address, hostname and HTTP methods. It can also be used to redirect a user to the `https` version of a URL pattern. For more complex needs, you can also use a service implementing `RequestMatcherInterface`.

每个access_control也可以在IP地址、主机名和HTTP方法上匹配。它也可以用来将用户重定向到一个URL模式的https版本。对于更复杂的需求，你也可以使用一个实现RequestMatcherInterface的服务。

See [How Does the Security access_control Work?](https://symfony.com/doc/current/security/access_control.html).

更多介绍参见 [How Does the Security access_control Work?](https://symfony.com/doc/current/security/access_control.html).



#### [Securing Controllers and other Code](https://symfony.com/doc/current/security.html#securing-controllers-and-other-code)

You can deny access from inside a controller:

你可以从控制器内部拒绝访问：

```php
// src/Controller/AdminController.php
// ...

public function adminDashboard(): Response
{
    $this->denyAccessUnlessGranted('ROLE_ADMIN');

    // or add an optional message - seen by developers
    $this->denyAccessUnlessGranted('ROLE_ADMIN', null, 'User tried to access a page without having ROLE_ADMIN');
}
```

That's it! If access is not granted, a special [AccessDeniedException](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Component/Security/Core/Exception/AccessDeniedException.php) is thrown and no more code in your controller is called. Then, one of two things will happen:

这就是了!如果访问权限没有被授予，就会抛出一个特殊的AccessDeniedException，并且不再调用控制器中的代码。然后，两件事中的一件会发生：

1. If the user isn't logged in yet, they will be asked to log in (e.g. redirected to the login page).

   如果用户还没有登录，他们将被要求登录（例如，重定向到登录页面）。

2. If the user *is* logged in, but does *not* have the `ROLE_ADMIN` role, they'll be shown the 403 access denied page (which you can [customize](https://symfony.com/doc/current/controller/error_pages.html#controller-error-pages-by-status-code)).
   如果用户已经登录，但没有ROLE_ADMIN的角色，他们将显示403访问拒绝页面（你可以自定义）。



Another way to secure one or more controller actions is to use an attribute. In the following example, all controller actions will require the `ROLE_ADMIN` permission, except for `adminDashboard()`, which will require the `ROLE_SUPER_ADMIN` permission:

另一种保护一个或多个控制器动作的方法是使用一个属性。在下面的例子中，所有的控制器动作都需要ROLE_ADMIN权限，除了adminDashboard()，它需要ROLE_SUPER_ADMIN权限：

```php
// src/Controller/AdminController.php
// ...

use Symfony\Component\Security\Http\Attribute\IsGranted;

#[IsGranted('ROLE_ADMIN')]
class AdminController extends AbstractController
{
    // Optionally, you can set a custom message that will be displayed to the user
    #[IsGranted('ROLE_SUPER_ADMIN', message: 'You are not allowed to access the admin dashboard.')]
    public function adminDashboard(): Response
    {
        // ...
    }
}
```

If you want to use a custom status code instead of the default one (which is 403), this can be done by setting with the `statusCode` argument:

如果你想使用一个自定义的状态代码，而不是默认的（403），这可以通过设置statusCode参数来实现：

```php
// src/Controller/AdminController.php
// ...

use Symfony\Component\Security\Http\Attribute\IsGranted;

#[IsGranted('ROLE_ADMIN', statusCode: 423)]
class AdminController extends AbstractController
{
    // ...
}
```

> 6.2 The `#[IsGranted()]` attribute was introduced in Symfony 6.2.



#### [Access Control in Templates](https://symfony.com/doc/current/security.html#access-control-in-templates)

If you want to check if the current user has a certain role, you can use the built-in `is_granted()` helper function in any Twig template:

如果你想检查当前用户是否拥有某个角色，你可以在任何Twig模板中使用内置的is_granted()辅助函数：

```twig
{% if is_granted('ROLE_ADMIN') %}
    <a href="...">Delete</a>
{% endif %}
```



#### [Securing other Services](https://symfony.com/doc/current/security.html#securing-other-services)

You can check access *anywhere* in your code by injecting the `Security` service. For example, suppose you have a `SalesReportManager` service and you want to include extra details only for users that have a `ROLE_SALES_ADMIN` role:

你可以通过注入安全服务检查代码中的任何地方的访问。例如，假设你有一个SalesReportManager服务，你想只为拥有ROLE_SALES_ADMIN角色的用户包括额外的细节：

```php
// src/SalesReport/SalesReportManager.php

  // ...
  use Symfony\Component\Security\Core\Exception\AccessDeniedException;
+ use Symfony\Bundle\SecurityBundle\Security;

  class SalesReportManager
  {
+     public function __construct(
+         Security $security,
+     ) {
+     }

      public function generateReport()
      {
          $salesData = [];

+         if ($this->security->isGranted('ROLE_SALES_ADMIN')) {
+             $salesData['top_secret_numbers'] = rand();
+         }

          // ...
      }

      // ...
  }
```

If you're using the [default services.yaml configuration](https://symfony.com/doc/current/service_container.html#service-container-services-load-example), Symfony will automatically pass the `security.helper` to your service thanks to autowiring and the `Security` type-hint.

如果你使用默认的services.yaml配置，由于自动布线和安全类型提示，Symfony会自动把security.helper传递给你的服务。

You can also use a lower-level [AuthorizationCheckerInterface](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Component/Security/Core/Authorization/AuthorizationCheckerInterface.php) service. It does the same thing as `Security`, but allows you to type-hint a more-specific interface.

你也可以使用低级别的AuthorizationCheckerInterface服务。它的作用与Security相同，但允许你对一个更具体的接口进行类型提示。



### [Allowing Unsecured Access (i.e. Anonymous Users)](https://symfony.com/doc/current/security.html#allowing-unsecured-access-i-e-anonymous-users)

When a visitor isn't yet logged in to your website, they are treated as "unauthenticated" and don't have any roles. This will block them from visiting your pages if you defined an `access_control` rule.

当访问者还没有登录到你的网站时，他们被视为 "未认证"，没有任何角色。如果你定义了一个访问控制规则，这将阻止他们访问你的网页。

In the `access_control` configuration, you can use the `PUBLIC_ACCESS` security attribute to exclude some routes for unauthenticated access (e.g. the login page):

在access_control配置中，你可以使用PUBLIC_ACCESS安全属性来排除一些未经认证的访问路线（例如，登录页面）：

```yaml
# config/packages/security.yaml
security:

    # ...
    access_control:
        # allow unauthenticated users to access the login form
        - { path: ^/admin/login, roles: PUBLIC_ACCESS }

        # but require authentication for all other admin routes
        - { path: ^/admin, roles: ROLE_ADMIN }
```



### [Granting Anonymous Users Access in a Custom Voter](https://symfony.com/doc/current/security.html#granting-anonymous-users-access-in-a-custom-voter)

If you're using a [custom voter](https://symfony.com/doc/current/security/voters.html), you can allow anonymous users access by checking if there is no user set on the token:

如果你使用的是自定义投票器，你可以通过检查令牌上是否没有设置用户来允许匿名用户访问：

```php

// src/Security/PostVoter.php
namespace App\Security;

// ...
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
use Symfony\Component\Security\Core\Authentication\User\UserInterface;
use Symfony\Component\Security\Core\Authorization\Voter\Voter;

class PostVoter extends Voter
{
    // ...

    protected function voteOnAttribute(string $attribute, $subject, TokenInterface $token): bool
    {
        // ...

        if (!$token->getUser() instanceof UserInterface) {
            // the user is not authenticated, e.g. only allow them to
            // see public posts
            return $subject->isPublic();
        }
    }
}
```



### [Setting Individual User Permissions](https://symfony.com/doc/current/security.html#setting-individual-user-permissions)

Most applications require more specific access rules. For instance, a user should be able to only edit their *own* comments on a blog. Voters allow you to write *whatever* business logic you need to determine access. Using these voters is similar to the role-based access checks implemented in the previous chapters. Read [How to Use Voters to Check User Permissions](https://symfony.com/doc/current/security/voters.html) to learn how to implement your own voter.

大多数应用程序需要更具体的访问规则。例如，一个用户应该只能在博客上编辑自己的评论。投票者允许你编写任何你需要的业务逻辑来决定访问。使用这些投票者类似于前几章中实现的基于角色的访问检查。阅读《如何使用投票器检查用户权限》，了解如何实现你自己的投票器。

### [Checking to see if a User is Logged In](https://symfony.com/doc/current/security.html#checking-to-see-if-a-user-is-logged-in)

If you *only* want to check if a user is logged in (you don't care about roles), you have the following two options.

如果你只想检查一个用户是否已经登录（你不关心角色），你有以下两个选项。

Firstly, if you've given *every* user `ROLE_USER`, you can check for that role.

首先，如果你给了每个用户ROLLE_USER，你可以检查这个角色。

Secondly, you can use the special "attribute" `IS_AUTHENTICATED_FULLY` in place of a role:

第二，你可以使用特殊的 "属性 "IS_AUTHENTICATED_FULLY来代替角色：

```php
// ...

public function adminDashboard(): Response
{
    $this->denyAccessUnlessGranted('IS_AUTHENTICATED');

    // ...
}
```

You can use `IS_AUTHENTICATED` anywhere roles are used: like `access_control` or in Twig.

你可以在任何使用角色的地方使用IS_AUTHENTICATED：如access_control或Twig中。

`IS_AUTHENTICATED` isn't a role, but it kind of acts like one, and every user that has logged in will have this. Actually, there are some special attributes like this:

IS_AUTHENTICATED不是一个角色，但它的作用有点像一个角色，每个登录过的用户都会有这个角色。实际上，有一些特殊的属性是这样的：

- `IS_AUTHENTICATED_REMEMBERED`: *all* logged in users have this, even if they are logged in because of a "remember me cookie". Even if you don't use the [remember me functionality](https://symfony.com/doc/current/security/remember_me.html), you can use this to check if the user is logged in.

  IS_AUTHENTICATED_REMEMBERED：所有登录的用户都有这个，即使他们是由于 "记住我的cookie "而登录的。即使你不使用记住我的功能，你也可以用这个来检查用户是否已经登录了。

- `IS_AUTHENTICATED_FULLY`: This is similar to `IS_AUTHENTICATED_REMEMBERED`, but stronger. Users who are logged in only because of a "remember me cookie" will have `IS_AUTHENTICATED_REMEMBERED` but will not have `IS_AUTHENTICATED_FULLY`.

  IS_AUTHENTICATED_FULLY: 这与IS_AUTHENTICATED_REMEMBERED相似，但更强大。仅仅因为 "记住我的cookie "而登录的用户将拥有IS_AUTHENTICATED_REMEMBERED，但不会拥有IS_AUTHENTICATED_FULLY。

- `IS_REMEMBERED`: *Only* users authenticated using the [remember me functionality](https://symfony.com/doc/current/security/remember_me.html), (i.e. a remember-me cookie).

  IS_REMBERED：只有使用remember me功能认证的用户，（即remember-me cookie）。

- `IS_IMPERSONATOR`: When the current user is [impersonating](https://symfony.com/doc/current/security/impersonating_user.html) another user in this session, this attribute will match.
  IS_IMPERSONATOR: 当当前用户在这个会话中冒充另一个用户时，这个属性将匹配。



## [Understanding how Users are Refreshed from the Session](https://symfony.com/doc/current/security.html#understanding-how-users-are-refreshed-from-the-session)

At the end of every request (unless your firewall is `stateless`), your `User` object is serialized to the session. At the beginning of the next request, it's deserialized and then passed to your user provider to "refresh" it (e.g. Doctrine queries for a fresh user).

在每个请求结束时（除非你的防火墙是无状态的），你的用户对象被序列化为session。在下一个请求开始时，它被反序列化，然后传递给你的用户提供者以 "刷新 "它（例如，Doctrine查询一个新用户）。

Then, the two User objects (the original from the session and the refreshed User object) are "compared" to see if they are "equal". By default, the core `AbstractToken` class compares the return values of the `getPassword()`, `getSalt()` and `getUserIdentifier()` methods. If any of these are different, your user will be logged out. This is a security measure to make sure that malicious users can be de-authenticated if core user data changes.

然后，两个用户对象（会话中的原始对象和刷新的用户对象）被 "比较"，看它们是否 "相等"。默认情况下，核心AbstractToken类会比较getPassword()、getSalt()和getUserIdentifier()方法的返回值。如果其中任何一个不同，你的用户将被注销。这是一项安全措施，以确保如果核心用户数据发生变化，恶意用户可以被取消认证。

However, in some cases, this process can cause unexpected authentication problems. If you're having problems authenticating, it could be that you *are* authenticating successfully, but you immediately lose authentication after the first redirect.

然而，在某些情况下，这个过程可能会导致意外的认证问题。如果你在认证方面有问题，可能是你认证成功了，但在第一次重定向后立即失去认证。

In that case, review the serialization logic (e.g. the `__serialize()` or `serialize()` methods) on your user class (if you have any) to make sure that all the fields necessary are serialized and also exclude all the fields not necessary to be serialized (e.g. Doctrine relations).

在这种情况下，审查你的用户类（如果你有的话）上的序列化逻辑（例如__serialize()或serialize()方法），确保所有必要的字段都被序列化，同时排除所有没有必要被序列化的字段（例如Doctrine关系）。



### [Comparing Users Manually with EquatableInterface](https://symfony.com/doc/current/security.html#comparing-users-manually-with-equatableinterface)

Or, if you need more control over the "compare users" process, make your User class implement [EquatableInterface](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Component/Security/Core/User/EquatableInterface.php). Then, your `isEqualTo()` method will be called when comparing users instead of the core logic.

或者，如果你需要对 "比较用户 "的过程进行更多的控制，让你的用户类实现EquatableInterface。然后，你的isEqualTo()方法将在比较用户时被调用，而不是核心逻辑。



## [Security Events](https://symfony.com/doc/current/security.html#security-events)

During the authentication process, multiple events are dispatched that allow you to hook into the process or customize the response sent back to the user. You can do this by creating an [event listener or subscriber](https://symfony.com/doc/current/event_dispatcher.html) for these events.

在认证过程中，多个事件被派发，允许你钩住该过程或定制发回给用户的响应。你可以通过为这些事件创建一个事件监听器或订阅者来实现这一目的。

Every Security firewall has its own event dispatcher (`security.event_dispatcher.FIREWALLNAME`). Events are dispatched on both the global and the firewall-specific dispatcher. You can register on the firewall dispatcher if you want your listener to only be called for a specific firewall. For instance, if you have an `api` and `main` firewall, use this configuration to register only on the logout event in the `main` firewall:

每个安全防火墙都有自己的事件调度器（security.event_dispatcher.FIREWALLNAME）。事件在全局和防火墙特定的调度器上被调度。如果你想让你的监听器只为一个特定的防火墙被调用，你可以在防火墙调度器上注册。例如，如果你有一个api和主防火墙，使用这个配置只在主防火墙的logout事件上注册：

```yaml
# config/services.yaml
services:
    # ...

    App\EventListener\LogoutSubscriber:
        tags:
            - name: kernel.event_subscriber
              dispatcher: security.event_dispatcher.main
```



### [Authentication Events](https://symfony.com/doc/current/security.html#authentication-events)

![](.\1684117437264.png)

- [CheckPassportEvent](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Component/Security/Http/Event/CheckPassportEvent.php)

  Dispatched after the authenticator created the [security passport](https://symfony.com/doc/current/security/custom_authenticator.html#security-passport). Listeners of this event do the actual authentication checks (like checking the passport, validating the CSRF token, etc.)

- [AuthenticationTokenCreatedEvent](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Component/Security/Http/Event/AuthenticationTokenCreatedEvent.php)

  Dispatched after the passport was validated and the authenticator created the security token (and user). This can be used in advanced use-cases where you need to modify the created token (e.g. for multi factor authentication).

- [AuthenticationSuccessEvent](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Component/Security/Core/Event/AuthenticationSuccessEvent.php)

  Dispatched when authentication is nearing success. This is the last event that can make an authentication fail by throwing an `AuthenticationException`.

- [LoginSuccessEvent](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Component/Security/Http/Event/LoginSuccessEvent.php)

  Dispatched after authentication was fully successful. Listeners to this event can modify the response sent back to the user.

- [LoginFailureEvent](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Component/Security/Http/Event/LoginFailureEvent.php)

  Dispatched after an `AuthenticationException` was thrown during authentication. Listeners to this event can modify the error response sent back to the user.



### [Other Events](https://symfony.com/doc/current/security.html#other-events)

- [LogoutEvent](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Component/Security/Http/Event/LogoutEvent.php)

  Dispatched just before a user logs out of your application. See [Security](https://symfony.com/doc/current/security.html#security-logging-out).

- [TokenDeauthenticatedEvent](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Component/Security/Http/Event/TokenDeauthenticatedEvent.php)

  Dispatched when a user is deauthenticated, for instance because the password was changed. See [Security](https://symfony.com/doc/current/security.html#user_session_refresh).

- [SwitchUserEvent](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Component/Security/Http/Event/SwitchUserEvent.php)

  Dispatched after impersonation is completed. See [How to Impersonate a User](https://symfony.com/doc/current/security/impersonating_user.html).



## [Frequently Asked Questions](https://symfony.com/doc/current/security.html#frequently-asked-questions)

- **Can I have Multiple Firewalls?**

  Yes! However, each firewall is like a separate security system: being authenticated in one firewall doesn't make you authenticated in another one. Each firewall can have multiple ways of allowing authentication (e.g. form login, and API key authentication). If you want to share authentication between firewalls, you have to explicitly specify the same [Security Configuration Reference (SecurityBundle)](https://symfony.com/doc/current/reference/configuration/security.html#reference-security-firewall-context) for different firewalls.

- **Security doesn't seem to work on my Error Pages**

  As routing is done *before* security, 404 error pages are not covered by any firewall. This means you can't check for security or even access the user object on these pages. See [How to Customize Error Pages](https://symfony.com/doc/current/controller/error_pages.html) for more details.

- **My Authentication Doesn't Seem to Work: No Errors, but I'm Never Logged In**

  Sometimes authentication may be successful, but after redirecting, you're logged out immediately due to a problem loading the `User` from the session. To see if this is an issue, check your log file (`var/log/dev.log`) for the log message:

- **Cannot refresh token because user has changed**

  If you see this, there are two possible causes. First, there may be a problem loading your User from the session. See [Security](https://symfony.com/doc/current/security.html#user_session_refresh). Second, if certain user information was changed in the database since the last page refresh, Symfony will purposely log out the user for security reasons.



## [Learn More](https://symfony.com/doc/current/security.html#learn-more)

### [Authentication (Identifying/Logging in the User)](https://symfony.com/doc/current/security.html#authentication-identifying-logging-in-the-user)

- [Password Hashing and Verification](https://symfony.com/doc/current/security/passwords.html)
- [Authenticating against an LDAP server](https://symfony.com/doc/current/security/ldap.html)
- [How to Add "Remember Me" Login Functionality](https://symfony.com/doc/current/security/remember_me.html)
- [How to Impersonate a User](https://symfony.com/doc/current/security/impersonating_user.html)
- [How to Create and Enable Custom User Checkers](https://symfony.com/doc/current/security/user_checkers.html)
- [How to Restrict Firewalls to a Request](https://symfony.com/doc/current/security/firewall_restriction.html)
- [How to Implement CSRF Protection](https://symfony.com/doc/current/security/csrf.html)
- [Customizing the Form Login Authenticator Responses](https://symfony.com/doc/current/security/form_login.html)
- [How to Write a Custom Authenticator](https://symfony.com/doc/current/security/custom_authenticator.html)
- [The Entry Point: Helping Users Start Authentication](https://symfony.com/doc/current/security/entry_point.html)

### [Authorization (Denying Access)](https://symfony.com/doc/current/security.html#authorization-denying-access)

- [How to Use Voters to Check User Permissions](https://symfony.com/doc/current/security/voters.html)
- [How Does the Security access_control Work?](https://symfony.com/doc/current/security/access_control.html)
- [Using Expressions in Security Access Controls](https://symfony.com/doc/current/security/expressions.html)
- [How to Customize Access Denied Responses](https://symfony.com/doc/current/security/access_denied_handler.html)
- [How to Force HTTPS or HTTP for different URLs](https://symfony.com/doc/current/security/force_https.html)