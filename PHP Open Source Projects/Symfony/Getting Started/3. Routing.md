When your application receives a request, it calls a [controller action](https://symfony.com/doc/current/controller.html) to generate the response. The routing configuration defines which action to run for each incoming URL. It also provides other useful features, like generating SEO-friendly URLs (e.g. `/read/intro-to-symfony` instead of `index.php?article_id=57`).

当你的应用程序接受到一个请求时，它会调用控制器Action去生成一个响应。路由配置定义了每个进来的URL由哪个Action去处理。它也提供了其他有用的功能，比如生成SEO友好的URL（例如用/read/intro-to-symfony替代index.php?article_id=57）。



### Creating Routes

Routes can be configured in YAML, XML, PHP or using attributes. All formats provide the same features and performance, so choose your favorite. [Symfony recommends attributes](https://symfony.com/doc/current/best_practices.html#best-practice-controller-annotations) because it's convenient to put the route and controller in the same place.

路由可以用YAML、XML、PHP或使用attributes或annotations来配置。所有的格式都提供相同的功能和性能，所以选择你喜欢的方式。Symfony推荐使用[attributes](https://symfony.com/doc/5.4/best_practices.html#best-practice-controller-annotations) ，因为它方便把路由和控制器放在同一个地方。



#### Creating Routes as Attributes or Annotations

PHP attributes allow to define routes next to the code of the [controllers](https://symfony.com/doc/current/controller.html) associated to those routes. Attributes are native in PHP 8 and higher versions, so you can use them right away.

PHP属性和注解允许在与这些路由相关的控制器的代码旁边定义路由。属性在PHP 8和更高版本中是原生的，所以你可以直接使用它们。

You need to add a bit of configuration to your project before using them. If your project uses [Symfony Flex](https://symfony.com/doc/current/setup.html#symfony-flex), this file is already created for you. Otherwise, create the following file manually:

在PHP 7和更早的版本中，你可以使用注解（通过Doctrine注解库），但首先你需要在你的项目中安装以下依赖项：

```
composer require doctrine/annotations
```

> 5.2 使用PHP属性配置路由是在5.2中引入的。在此之前，Doctrine Annotations配置路由的唯一方式是使用注解。

Regardless of what you use (attributes or annotations) you need to add a bit of configuration to your project before using them. If you installed the annotations dependency and your project uses [Symfony Flex](https://symfony.com/doc/5.4/setup.html#symfony-flex), this file is already created for you. Otherwise, create the following file manually (the `type: annotation` option also applies to attributes, so you can keep it):

无论你使用什么（属性或注解），在使用它们之前，你都需要在你的项目中添加一些配置。如果你安装了注释依赖，并且你的项目使用Symfony Flex，这个配置文件已经为你创建了。否则，请手动创建以下文件（type: annotation选项也适用于属性，所以你可以保留它）。

```yaml
# config/routes/annotations.yaml
controllers:
    resource: ../../src/Controller/
    type: annotation

kernel:
    resource: ../../src/Kernel.php
    type: annotation
```

This configuration tells Symfony to look for routes defined as annotations/attributes in any PHP class stored in the `src/Controller/` directory.

这个配置告诉Symfony寻找存储在src/Controller/目录下任何PHP类中定义为注解/属性的路由。

Suppose you want to define a route for the `/blog` URL in your application. To do so, create a [controller class](https://symfony.com/doc/5.4/controller.html) like the following:

假设你想为你的应用程序中的/blog URL定义一个路由。要做到这一点，请创建一个控制器类，如下所示：

```php
// src/Controller/BlogController.php
namespace App\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\Routing\Annotation\Route;

class BlogController extends AbstractController
{
    /**
     * @Route("/blog", name="blog_list")
     */
    public function list(): Response
    {
        // ...
    }
}
```

This configuration defines a route called `blog_list` that matches when the user requests the `/blog` URL. When the match occurs, the application runs the `list()` method of the `BlogController` class.

这个配置定义了一个名为blog_list的路由，当用户请求/blog的URL时，这个路由会被匹配。当匹配发生时，应用程序运行BlogController类的list()方法。

> The query string of a URL is not considered when matching routes. In this example, URLs like `/blog?foo=bar` and `/blog?foo=bar&bar=foo` will also match the `blog_list` route.
>
> 匹配路由时不考虑URL的查询字符串。在这个例子中，像/blog?foo=bar和/blog?foo=bar&bar=foo这样的URL也将匹配blog_list路由。
>
> warning：If you define multiple PHP classes in the same file, Symfony only loads the routes of the first class, ignoring all the other routes.
>
> 警告：如果你在同一个文件中定义了多个PHP类，Symfony只加载第一个类的路由，忽略其他所有的路由。

The route name (`blog_list`) is not important for now, but it will be essential later when [generating URLs](https://symfony.com/doc/5.4/routing.html#routing-generating-urls). You only have to keep in mind that each route name must be unique in the application.

路由名称（blog_list）现在并不重要，但以后在生成URL时，它将是必不可少的。你只需要记住，每个路由名称在应用程序中必须是唯一的。



#### Creating Routes in YAML, XML or PHP Files

Instead of defining routes in the controller classes, you can define them in a separate YAML, XML or PHP file. The main advantage is that they don't require any extra dependency. The main drawback is that you have to work with multiple files when checking the routing of some controller action.

你可以在一个单独的YAML、XML或PHP文件中定义路由以替代在控制器类中定义路由。优点是它们不需要任何额外依赖，而缺点是在检查一些控制器动作的路由时，你必须使用多个文件。

The following example shows how to define in YAML/XML/PHP a route called `blog_list` that associates the `/blog` URL with the `list()` action of the `BlogController`:

下面的例子显示了如何在YAML/XML/PHP中定义一个名为blog_list的路由，将/blog的URL与BlogController的list()动作联系起来。

```yaml
# config/routes.yaml
blog_list:
    path: /blog
    # the controller value has the format 'controller_class::method_name'
    controller: App\Controller\BlogController::list

    # if the action is implemented as the __invoke() method of the
    # controller class, you can skip the '::method_name' part:
    # controller: App\Controller\BlogController
```

> By default Symfony only loads the routes defined in YAML format. If you define routes in XML and/or PHP formats, you need to [update the src/Kernel.php file](https://symfony.com/doc/5.4/configuration.html#configuration-formats).
>
> 注：默认情况下，Symfony只加载以YAML格式定义的路由。如果你用XML和/或PHP格式定义路由，你需要[更新 src/Kernel.php文件](https://symfony.com/doc/5.4/configuration.html#configuration-formats).。





#### Matching HTTP Methods

By default, routes match any HTTP verb (`GET`, `POST`, `PUT`, etc.) Use the `methods` option to restrict the verbs each route should respond to:

默认情况下，路由匹配任何HTTP动作（GET、POST、PUT等）。使用methods选项来限制每个路由应该响应的动作。

```yaml
# config/routes.yaml
api_post_show:
    path:       /api/posts/{id}
    controller: App\Controller\BlogApiController::show
    methods:    GET|HEAD

api_post_edit:
    path:       /api/posts/{id}
    controller: App\Controller\BlogApiController::edit
    methods:    PUT
```

> HTML forms only support `GET` and `POST` methods. If you're calling a route with a different method from an HTML form, add a hidden field called `_method` with the method to use (e.g. `<input type="hidden" name="_method" value="PUT">`). If you create your forms with [Symfony Forms](https://symfony.com/doc/5.4/forms.html) this is done automatically for you when the [framework.http_method_override](https://symfony.com/doc/5.4/reference/configuration/framework.html#configuration-framework-http_method_override) option is `true`.
>
> 提示：HTML表单只支持GET和POST方法。如果你用不同的方法从HTML表单中调用路由，可以添加一个名为\_method的隐藏字段，写上要使用的方法（例如：<input type="hidden" name="_method" value="PUT">）。如果你用Symfony Forms创建表单，当framework.http_method_override选项为 "true "时，会自动为你完成。



#### Matching Expressions

Use the `condition` option if you need some route to match based on some arbitrary matching logic:

如果需要基于某些任意匹配逻辑来匹配某些路由，请使用condition选项：

```yaml
# config/routes.yaml
contact:
    path:       /contact
    controller: 'App\Controller\DefaultController::contact'
    condition:  "context.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches '/firefox/i'"
    # expressions can also include configuration parameters:
    # condition: "request.headers.get('User-Agent') matches '%app.allowed_browsers%'"
    # expressions can even use environment variables:
    # condition: "context.getHost() == env('APP_MAIN_HOST')"
```

The value of the `condition` option is an expression using any valid [expression language syntax](https://symfony.com/doc/5.4/reference/formats/expression_language.html) and can use any of these variables created by Symfony:

condition选项的值是一个使用任何有效表达式语言语法（[expression language syntax](https://symfony.com/doc/5.4/reference/formats/expression_language.html) ）的表达式，可以使用Symfony创建的以下任何变量：

- context

  An instance of [RequestContext](https://github.com/symfony/symfony/blob/5.4/src/Symfony/Component/Routing/RequestContext.php), which holds the most fundamental information about the route being matched.

  [RequestContext](https://github.com/symfony/symfony/blob/5.4/src/Symfony/Component/Routing/RequestContext.php)的一个实例，它持有关于被匹配的路由的最基本信息。

- request

  The [Symfony Request](https://symfony.com/doc/5.4/components/http_foundation.html#component-http-foundation-request) object that represents the current request.
  
  [Symfony Request](https://symfony.com/doc/5.4/components/http_foundation.html#component-http-foundation-request) 对象，表示当前请求。

你也可以使用这个函数：

- env(string $name)

  Returns the value of a variable using [Environment Variable Processors](https://symfony.com/doc/5.4/configuration/env_var_processors.html)
  
  使用环境变量处理器（[Environment Variable Processors](https://symfony.com/doc/5.4/configuration/env_var_processors.html)）返回一个变量的值。

Behind the scenes, expressions are compiled down to raw PHP. Because of this, using the `condition` key causes no extra overhead beyond the time it takes for the underlying PHP to execute.

在幕后，表达式被编译成了原始的PHP。正因为如此，除了底层PHP的执行时间外，使用条件键不会造成额外的开销。

> Conditions are *not* taken into account when generating URLs (which is explained later in this article).
>
> 警告：生成URL时不考虑条件（本文后面会解释）。



#### Debugging Routes

As your application grows, you'll eventually have a *lot* of routes. Symfony includes some commands to help you debug routing issues. First, the `debug:router` command lists all your application routes in the same order in which Symfony evaluates them:

随着你的应用程序的增长，你最终会有很多的路由。Symfony包括一些命令来帮助你调试路由问题。首先，debug:router命令按照Symfony评估路由的顺序列出你所有的应用路由：

```
$ php bin/console debug:router

----------------  -------  -------  -----  --------------------------------------------
Name              Method   Scheme   Host   Path
----------------  -------  -------  -----  --------------------------------------------
homepage          ANY      ANY      ANY    /
contact           GET      ANY      ANY    /contact
contact_process   POST     ANY      ANY    /contact
article_show      ANY      ANY      ANY    /articles/{_locale}/{year}/{title}.{_format}
blog              ANY      ANY      ANY    /blog/{page}
blog_show         ANY      ANY      ANY    /blog/{slug}
----------------  -------  -------  -----  --------------------------------------------
```

Pass the name (or part of the name) of some route to this argument to print the route details:

将某些路由的名称（或部分名称）传递给此参数以打印路由详细信息：

```
$ php bin/console debug:router app_lucky_number

+-------------+---------------------------------------------------------+
| Property    | Value                                                   |
+-------------+---------------------------------------------------------+
| Route Name  | app_lucky_number                                        |
| Path        | /lucky/number/{max}                                     |
| ...         | ...                                                     |
| Options     | compiler_class: Symfony\Component\Routing\RouteCompiler |
|             | utf8: true                                              |
+-------------+---------------------------------------------------------+
```

The other command is called `router:match` and it shows which route will match the given URL. It's useful to find out why some URL is not executing the controller action that you expect:

另一个命令叫做router:match，它显示了哪条路由将匹配给定的URL。这对于找出某些URL没有执行你所期望的控制器动作的原因很有用：

```
$ php bin/console router:match /lucky/number/8
  [OK] Route "app_lucky_number" matches
```



### Route Parameters

The previous examples defined routes where the URL never changes (e.g. `/blog`). However, it's common to define routes where some parts are variable. For example, the URL to display some blog post will probably include the title or slug (e.g. `/blog/my-first-post` or `/blog/all-about-symfony`).

前面的例子定义了URL不会改变的路由（例如/blog）。然而，定义某些部分是可变的路由是很常见的。例如，显示某些博客文章的URL可能包括标题或slug（例如/blog/my-first-post或/blog/all-about-symfony）。

In Symfony routes, variable parts are wrapped in `{ }`. For example, the route to display the blog post contents is defined as `/blog/{slug}`:

在Symfony路由中，变量部分是用{ }包装的。例如，显示博客文章内容的路由被定义为/blog/{slug}：

```yaml
# config/routes.yaml
blog_show:
    path:       /blog/{slug}
    controller: App\Controller\BlogController::show
```

The name of the variable part (`{slug}` in this example) is used to create a PHP variable where that route content is stored and passed to the controller. If a user visits the `/blog/my-first-post` URL, Symfony executes the `show()` method in the `BlogController` class and passes a `$slug = 'my-first-post'` argument to the `show()` method.

变量部分的名称（本例中为{slug}）被用来创建一个PHP变量，该路由内容被存储并传递给控制器。如果用户访问/blog/my-first-post URL，Symfony会执行BlogController类中的show()方法，并向show()方法传递$slug = 'my-first-post' 参数。

Routes can define any number of parameters, but each of them can only be used once on each route (e.g. `/blog/posts-about-{category}/page/{pageNumber}`).

路由可以定义任意数量的参数，但每个参数只能在每个路由上使用一次（例如：/blog/posts-about-{category}/page/{pageNumber}）。



#### Parameters Validation

Imagine that your application has a `blog_show` route (URL: `/blog/{slug}`) and a `blog_list` route (URL: `/blog/{page}`). Given that route parameters accept any value, there's no way to differentiate both routes.

想象一下，你的应用程序有一个blog_show路由（URL：/blog/{slug}）和一个blog_list路由（URL：/blog/{page}）。由于路由参数接受任何值，没有办法区分这两个路由。

If the user requests `/blog/my-first-post`, both routes will match and Symfony will use the route which was defined first. To fix this, add some validation to the `{page}` parameter using the `requirements` option:

如果用户请求/blog/my-first-post，两条路由都会匹配，Symfony会使用最先定义的路由。要解决这个问题，可以使用requirements选项给{page}参数添加一些验证。

```yaml
# config/routes.yaml
blog_list:
    path:       /blog/{page}
    controller: App\Controller\BlogController::list
    requirements:
        page: '\d+'

blog_show:
    path:       /blog/{slug}
    controller: App\Controller\BlogController::show
```

The `requirements` option defines the [PHP regular expressions](https://www.php.net/manual/en/book.pcre.php) that route parameters must match for the entire route to match. In this example, `\d+` is a regular expression that matches a *digit* of any length. Now:

requirements 选项定义了路由参数必须与整个路由匹配的PHP正则表达式（[PHP regular expressions](https://www.php.net/manual/en/book.pcre.php) ）。在这个例子中，\d+ 是一个正则表达式，可以匹配任何长度的数字。现在:

| URL                   | Route       | Parameters                |
| --------------------- | ----------- | ------------------------- |
| `/blog/2`             | `blog_list` | `$page` = `2`             |
| `/blog/my-first-post` | `blog_show` | `$slug` = `my-first-post` |

> Route requirements (and route paths too) can include [configuration parameters](https://symfony.com/doc/5.4/configuration.html#configuration-parameters), which is useful to define complex regular expressions once and reuse them in multiple routes.
>
> 注：路由requirements（也包括路由paths）可以包括配置参数([configuration parameters](https://symfony.com/doc/5.4/configuration.html#configuration-parameters))，这对于定义一次复杂的正则表达式并在多个路由中重复使用很有用。

> Parameters also support [PCRE Unicode properties](https://www.php.net/manual/en/regexp.reference.unicode.php), which are escape sequences that match generic character types. For example, `\p{Lu}` matches any uppercase character in any language, `\p{Greek}` matches any Greek characters, etc.
>
> 注：参数也支持[PCRE Unicode properties](https://www.php.net/manual/en/regexp.reference.unicode.php)，它是匹配通用字符类型的转义序列。例如， \p{Lu} 匹配任何语言中的任何大写字符， \p{Greek} 匹配任何希腊字符，等等。

> When using regular expressions in route parameters, you can set the `utf8` route option to `true` to make any `.` character match any UTF-8 characters instead of just a single byte.
>
> 说明：当在路由参数中使用正则表达式时，你可以将utf8路由选项设置为true，以使任何 . 字符匹配任何UTF-8字符，而不仅仅是一个字节。

If you prefer, requirements can be inlined in each parameter using the syntax `{parameter_name<requirements>}`. This feature makes configuration more concise, but it can decrease route readability when requirements are complex:

如果你愿意，可以使用{parameter_name<requirements>}语法在每个参数中内置使用requirements。这个功能使配置更加简洁，但当需求复杂时，它可能会降低路由的可读性。

```yaml
# config/routes.yaml
blog_list:
    path:       /blog/{page<\d+>}
    controller: App\Controller\BlogController::list
```



#### Optional Parameters

In the previous example, the URL of `blog_list` is `/blog/{page}`. If users visit `/blog/1`, it will match. But if they visit `/blog`, it will **not** match. As soon as you add a parameter to a route, it must have a value.

在前面的例子中，blog_list的URL是/blog/{page}。如果用户访问/blog/1，它将匹配。但如果他们访问/blog，它将不匹配。只要你给路由添加了一个参数，它就必须有一个值。

You can make `blog_list` once again match when the user visits `/blog` by adding a default value for the `{page}` parameter. When using annotations or attributes, default values are defined in the arguments of the controller action. In the other configuration formats they are defined with the `defaults` option:

你可以通过为{page}参数添加一个默认值，使blog_list在用户访问/blog时再次匹配。当使用注解或属性时，默认值被定义在控制器动作的参数中。在其他配置格式中，它们是用defaults选项来定义的。

```yaml
# config/routes.yaml
blog_list:
    path:       /blog/{page}
    controller: App\Controller\BlogController::list
    defaults:
        page: 1
    requirements:
        page: '\d+'

blog_show:
    # ...
```

Now, when the user visits `/blog`, the `blog_list` route will match and `$page` will default to a value of `1`.

现在，当用户访问/blog时，blog_list路由将被匹配，$page将默认为1的值。

> warning：You can have more than one optional parameter (e.g. `/blog/{slug}/{page}`), but everything after an optional parameter must be optional. For example, `/{page}/blog` is a valid path, but `page` will always be required (i.e. `/blog` will not match this route).
>
> 警告：你可以有一个以上的可选参数（例如：/blog/{slug}/{page}），但可选参数之后的所有内容是必须的。例如，/{page}/blog是一个有效的路径，但page永远是必需的（即/blog不会匹配这个路径）。

If you want to always include some default value in the generated URL (for example to force the generation of `/blog/1` instead of `/blog` in the previous example) add the `!` character before the parameter name: `/blog/{!page}`

如果你想在生成的URL中总是包含一些默认值（例如强制生成/blog/1而不是前面例子中的/blog），在参数名称前添加 ! 字符：/blog/{!page}

As it happens with requirements, default values can also be inlined in each parameter using the syntax `{parameter_name?default_value}`. This feature is compatible with inlined requirements, so you can inline both in a single parameter:

和requirements选项一样，也可以使用{parameter_name?default_value}语法在每个参数中内置使用可选参数。这个功能与内置requiredments兼容，所以你可以在一个参数中同时内置两者。

```yaml
# config/routes.yaml
blog_list:
    path:       /blog/{page<\d+>?1}
    controller: App\Controller\BlogController::list
```

> To give a `null` default value to any parameter, add nothing after the `?` character (e.g. `/blog/{page?}`). If you do this, don't forget to update the types of the related controller arguments to allow passing `null` values (e.g. replace `int $page` by `?int $page`).
>
> 提示：要给任意参数一个空的默认值，在? 字符后面不加任何东西（例如：/blog/{page?}）。如果你这样做，别忘了更新相关控制器参数的类型，以允许传递空值（例如，用?int $page替换int $page）。



#### Priority Parameter

> 5.1 The `priority` parameter was introduced in Symfony 5.1
>
> 5.1 优先级参数是在Symfony 5.1中引入的。

Symfony evaluates routes in the order they are defined. If the path of a route matches many different patterns, it might prevent other routes from being matched. In YAML and XML you can move the route definitions up or down in the configuration file to control their priority. In routes defined as PHP annotations or attributes this is much harder to do, so you can set the optional `priority` parameter in those routes to control their priority

Symfony按照定义的顺序评估路由。如果一个路由的路径匹配了许多不同的模式，它可能会阻止其他路由被匹配。在YAML和XML中，你可以在配置文件中向上或向下移动路由定义来控制它们的优先级。在定义为 PHP 注释或属性的路由中，这就更难做到了，所以你可以在这些路由中设置可选的优先级参数来控制它们的优先级

```php
// src/Controller/BlogController.php
namespace App\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\Routing\Annotation\Route;

class BlogController extends AbstractController
{
    /**
     * This route has a greedy pattern and is defined first.
     *
     * @Route("/blog/{slug}", name="blog_show")
     */
    public function show(string $slug): Response
    {
        // ...
    }

    /**
     * This route could not be matched without defining a higher priority than 0.
     *
     * @Route("/blog/list", name="blog_list", priority=2)
     */
    public function list(): Response
    {
        // ...
    }
}
```

The priority parameter expects an integer value. Routes with higher priority are sorted before routes with lower priority. The default value when it is not defined is `0`.

优先级参数希望是一个整数值。优先级较高的路由会排序在优先级较低的路由之前。当它没有被定义时，默认值是0。



#### Parameter Conversion

A common routing need is to convert the value stored in some parameter (e.g. an integer acting as the user ID) into another value (e.g. the object that represents the user). This feature is called a "param converter".

一个常见的路由需求是将存储在某些参数中的值（例如作为用户ID的整数）转换成另一个值（例如代表用户的对象）。这个功能被称为 "参数转换器"。

To add support for "param converters" we need SensioFrameworkExtraBundle:

为了增加对 "参数转换器 "的支持，我们需要SensioFrameworkExtraBundle: 

```
$ composer require sensio/framework-extra-bundle
```

Now, keep the previous route configuration, but change the arguments of the controller action. Instead of `string $slug`, add `BlogPost $post`:

现在，保持之前的路由配置，但改变控制器动作的参数。取代字符串\$slug，添加BlogPost \$post。

```php
// src/Controller/BlogController.php
namespace App\Controller;

use App\Entity\BlogPost;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;

class BlogController extends AbstractController
{
    // ...

    /**
     * @Route("/blog/{slug}", name="blog_show")
     */
    public function show(BlogPost $post): Response
    {
        // $post is the object whose slug matches the routing parameter

        // ...
    }
}
```

If your controller arguments include type-hints for objects (`BlogPost` in this case), the "param converter" makes a database request to find the object using the request parameters (`slug` in this case). If no object is found, Symfony generates a 404 response automatically.

如果你的控制器参数包括对象的类型提示（本例中是BlogPost），"参数转换器 "会使用请求参数（本例中是slug）进行数据库请求以找到对象。如果没有找到对象，Symfony会自动生成一个404响应。

Read the [full param converter documentation](https://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/annotations/converters.html) to learn about the converters provided by Symfony and how to configure them.

阅读完整的参数转换器文档([full param converter documentation](https://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/annotations/converters.html))，了解Symfony提供的转换器以及如何配置它们。



#### Special Parameters

In addition to your own parameters, routes can include any of the following special parameters created by Symfony:

除了你自己的参数外，路由还可以包括以下由Symfony创建的特殊参数：

- _controller

  This parameter is used to determine which controller and action is executed when the route is matched.

  该参数被用于去确定当一个路由被匹配时会执行哪个控制器和Action。

- _format

  The matched value is used to set the "request format" of the `Request` object. This is used for such things as setting the `Content-Type` of the response (e.g. a `json` format translates into a `Content-Type` of `application/json`).

  匹配的值被用来设置Request对象的 "请求格式"。这用于设置响应的Content-Type（例如，json格式转换为application/json的内容类型）。

- _fragment

  Used to set the fragment identifier, which is the optional last part of a URL that starts with a `#` character and is used to identify a portion of a document.

  用于设置片段标识符，这是URL中可选的最后一部分，以#字符开头，用于标识文档的一部分。

- _locale

  Used to set the [locale](https://symfony.com/doc/5.4/translation.html#translation-locale-url) on the request.
  
  用来设置请求中的地区语言。

You can include these attributes (except `_fragment`) both in individual routes and in route imports. Symfony defines some special attributes with the same name (except for the leading underscore) so you can define them easier:

你可以在单个路由（individual routes）或路由导入（route imports）中包含这些属性（除了_fragment）。Symfony定义了一些具有相同名称的特殊属性（除了前面的下划线），所以你可以更容易地定义它们：

```yaml
# config/routes.yaml
article_search:
  path:        /articles/{_locale}/search.{_format}
  controller:  App\Controller\ArticleController::search
  locale:      en
  format:      html
  requirements:
      _locale: en|fr
      _format: html|xml
```



#### Extra Parameters

In the `defaults` option of a route you can optionally define parameters not included in the route configuration. This is useful to pass extra arguments to the controllers of the routes:

在路由的defaults选项中，你可以选择性地定义不包括在路由配置中的参数。这对于向路由的控制器传递额外的参数很有用：

```yaml
# config/routes.yaml
blog_index:
    path:       /blog/{page}
    controller: App\Controller\BlogController::index
    defaults:
        page: 1
        title: "Hello world!"
```



#### Slash Characters in Route Parameters

Route parameters can contain any values except the `/` slash character, because that's the character used to separate the different parts of the URLs. For example, if the `token` value in the `/share/{token}` route contains a `/` character, this route won't match.

路由参数可以包含任何值，除了/斜线字符，因为那是用来分隔URL不同部分的字符。例如，如果/share/{token}路由中的token值包含一个/字符，这个路由就不会匹配。

A possible solution is to change the parameter requirements to be more permissive:

一个可能的解决方案是改变参数要求，使其更加宽松:

```yaml
# config/routes.yaml
share:
    path:       /share/{token}
    controller: App\Controller\DefaultController::share
    requirements:
        token: .+
```

> If the route defines several parameters and you apply this permissive regular expression to all of them, you might get unexpected results. For example, if the route definition is `/share/{path}/{token}` and both `path` and `token` accept `/`, then `token` will only get the last part and the rest is matched by `path`.
>
> 注：如果路由定义了几个参数，而你把这个放纵性的正则表达式应用到所有参数上，你可能会得到意想不到的结果。例如，如果路由的定义是/share/{path}/{token}，而path和token都接受/，那么token将只得到最后一部分，其余部分由path来匹配。

> If the route includes the special `{_format}` parameter, you shouldn't use the `.+` requirement for the parameters that allow slashes. For example, if the pattern is `/share/{token}.{_format}` and `{token}` allows any character, the `/share/foo/bar.json` URL will consider `foo/bar.json` as the token and the format will be empty. This can be solved by replacing the `.+` requirement by `[^.]+` to allow any character except dots.
>
> 注：如果路由包括特殊的{\_format}参数，你不应该对允许斜杠的参数使用 .+ requirement。例如，如果模式是/share/{token}.{_format}，而{token}允许任何字符，那么/share/foo/bar.json URL将认为foo/bar.json是token，格式将是空的。这可以通过用\[^.\]+替换 .+的要求来解决，即允许除点以外的任何字符。



### Route Aliasing

> 5.4 Support for route aliases was introduced in Symfony 5.4.

Route alias allow you to have multiple name for the same route:

路由别名允许你同个路由拥有多个名字。

```yaml
# config/routes.yaml
new_route_name:
    alias: original_route_name
```

In this example, both `original_route_name` and `new_route_name` routes can be used in the application and will produce the same result.

在这里利字中，new_route_name和original_route_name俩个路由可以被用于同个应用中并提供相同的结果。



#### Deprecating Route Aliases

If some route alias should no longer be used (because it is outdated or you decided not to maintain it anymore), you can deprecate its definition:

如果一些路由别名不应该再被使用（因为它已经过时了，或者你决定不再维护它），你可以废除其定义。

```yaml
new_route_name:
    alias: original_route_name

    # this outputs the following generic deprecation message:
    # Since acme/package 1.2: The "new_route_name" route alias is deprecated. You should stop using it, as it will be removed in the future.
    deprecated:
        package: 'acme/package'
        version: '1.2'

    # you can also define a custom deprecation message (%alias_id% placeholder is available)
    deprecated:
        package: 'acme/package'
        version: '1.2'
        message: 'The "%alias_id%" route alias is deprecated. Do not use it anymore.'
```

In this example, every time the `new_route_name` alias is used, a deprecation warning is triggered, advising you to stop using that alias.

在这个例子中，每次使用new_route_name这个别名时，都会触发一个废弃警告，建议你停止使用这个别名。

The message is actually a message template, which replaces occurrences of the `%alias_id%` placeholder by the route alias name. You **must** have at least one occurrence of the `%alias_id%` placeholder in your template.

该消息实际上是一个消息模板，它用路由别名替换了%alias_id%占位符的出现。你的模板中必须至少有一个%alias_id%占位符的出现。



### Route Groups and Prefixes

It's common for a group of routes to share some options (e.g. all routes related to the blog start with `/blog`) That's why Symfony includes a feature to share route configuration.

一组路由共享一些选项是很常见的（比如所有与博客相关的路由都以/blog开头）这就是为什么Symfony包含一个共享路由配置的功能。

When defining routes as attributes or annotations, put the common configuration in the `#[Route]` attribute (or `@Route` annotation) of the controller class. In other routing formats, define the common configuration using options when importing the routes.

当把路由定义为属性或注解时，把共同配置放在控制器类的#[Route]属性（或@Route注解）中。在其他路由格式中，在导入路由时使用选项定义共同配置：

```yaml
# config/routes/annotations.yaml
controllers:
    resource: '../../src/Controller/'
    type: annotation
    # this is added to the beginning of all imported route URLs
    prefix: '/blog'
    # this is added to the beginning of all imported route names
    name_prefix: 'blog_'
    # these requirements are added to all imported routes
    requirements:
        _locale: 'en|es|fr'

    # An imported route with an empty URL will become "/blog/"
    # Uncomment this option to make that URL "/blog" instead
    # trailing_slash_on_root: false

    # you can optionally exclude some files/subdirectories when loading annotations
    # exclude: '../../src/Controller/{DebugEmailController}.php'
```

In this example, the route of the `index()` action will be called `blog_index` and its URL will be `/blog/{_locale}`. The route of the `show()` action will be called `blog_show` and its URL will be `/blog/{_locale}/posts/{slug}`. Both routes will also validate that the `_locale` parameter matches the regular expression defined in the class annotation.

在这个例子中，index()动作的路由将被称为blog_index，其URL将是/blog/{\_locale}。show()动作的路由将被称为blog_show，其URL将是/blog/{\_locale}/posts/{slug}。这两个路由也将验证\_locale参数是否与类注解中定义的正则表达式相匹配。

> If any of the prefixed routes defines an empty path, Symfony adds a trailing slash to it. In the previous example, an empty path prefixed with `/blog` will result in the `/blog/` URL. If you want to avoid this behavior, set the `trailing_slash_on_root` option to `false` (this option is not available when using PHP attributes or annotations):
>
> 如果任何一个前缀的路由定义了一个空路径，Symfony会给它加上一个尾部斜杠。在前面的例子中，一个以/blog为前缀的空路径会导致/blog/的URL。如果你想避免这种行为，把trailing_slash_on_root选项设置为false（这个选项在使用PHP属性或注释时不可用）。
>
> ```yaml
> # config/routes/annotations.yaml
> controllers:
>  resource: '../../src/Controller/'
>  type:     annotation
>  prefix:   '/blog'
>  trailing_slash_on_root: false
>  # ...
> ```
>



> Symfony can [import routes from different sources](https://symfony.com/doc/5.4/routing/custom_route_loader.html) and you can even create your own route loader.
>
> 链接：Symfony可以从不同源导入路由（ [import routes from different sources](https://symfony.com/doc/5.4/routing/custom_route_loader.html) ），你甚至可以创建你自己的路由加载器。



### Getting the Route Name and Parameters

The `Request` object created by Symfony stores all the route configuration (such as the name and parameters) in the "request attributes". You can get this information in a controller via the `Request` object:

Symfony创建的Request对象在 "请求属性 "中存储了所有的路由配置（如名称和参数）。你可以在控制器中通过Request对象获得这些信息。

```php
// src/Controller/BlogController.php
namespace App\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;

class BlogController extends AbstractController
{
    /**
     * @Route("/blog", name="blog_list")
     */
    public function list(Request $request): Response
    {
        $routeName = $request->attributes->get('_route');
        $routeParameters = $request->attributes->get('_route_params');

        // use this to get all the available attributes (not only routing ones):
        $allAttributes = $request->attributes->all();

        // ...
    }
}
```

You can get this information in services too injecting the `request_stack` service to [get the Request object in a service](https://symfony.com/doc/5.4/service_container/request.html). In templates, use the [Twig global app variable](https://symfony.com/doc/5.4/templates.html#twig-app-variable) to get the request and its attributes:

你也可以在服务中获得这些信息，在服务中注入request_stack服务来获得Request对象（[get the Request object in a service](https://symfony.com/doc/5.4/service_container/request.html)）。在模板中，使用Twig全局应用变量（[Twig global app variable](https://symfony.com/doc/5.4/templates.html#twig-app-variable)）来获取request和它的属性。

```php
{% set route_name = app.request.attributes.get('_route') %}
{% set route_parameters = app.request.attributes.get('_route_params') %}

{# use this to get all the available attributes (not only routing ones) #}
{% set all_attributes = app.request.attributes.all %}
```





### Special Routes

Symfony defines some special controllers to render templates and redirect to other routes from the route configuration so you don't have to create a controller action.

Symfony定义了一些特殊的控制器来渲染模板，并从路由配置中重定向到其他路由，所以你不必创建一个控制器动作。



#### Rendering a Template Directly from a Route

Read the section about [rendering a template from a route](https://symfony.com/doc/5.4/templates.html#templates-render-from-route) in the main article about Symfony templates.

请阅读关于Symfony模板的主要文章中关于从路由渲染模板（[rendering a template from a route](https://symfony.com/doc/5.4/templates.html#templates-render-from-route)）的部分。



#### Redirecting to URLs and Routes Directly from a Route

Use the `RedirectController` to redirect to other routes and URLs:

使用RedirectController去重定向到其他路由和URLs。

```yaml
# config/routes.yaml
doc_shortcut:
    path: /doc
    controller: Symfony\Bundle\FrameworkBundle\Controller\RedirectController
    defaults:
        route: 'doc_page'
        # optionally you can define some arguments passed to the route
        page: 'index'
        version: 'current'
        # redirections are temporary by default (code 302) but you can make them permanent (code 301)
        permanent: true
        # add this to keep the original query string parameters when redirecting
        keepQueryParams: true
        # add this to keep the HTTP method when redirecting. The redirect status changes
        # * for temporary redirects, it uses the 307 status code instead of 302
        # * for permanent redirects, it uses the 308 status code instead of 301
        keepRequestMethod: true
        # add this to remove the original route attributes when redirecting
        ignoreAttributes: true

legacy_doc:
    path: /legacy/doc
    controller: Symfony\Bundle\FrameworkBundle\Controller\RedirectController
    defaults:
        # this value can be an absolute path or an absolute URL
        path: 'https://legacy.example.com/doc'
        permanent: true
```

> Symfony also provides some utilities to [redirect inside controllers](https://symfony.com/doc/5.4/controller.html#controller-redirect)
>
> 提示：Symfony还提供了一些实用工具来重定向控制器内部（[redirect inside controllers](https://symfony.com/doc/5.4/controller.html#controller-redirect)）。



#### Redirecting URLs with Trailing Slashes

Historically, URLs have followed the UNIX convention of adding trailing slashes for directories (e.g. `https://example.com/foo/`) and removing them to refer to files (`https://example.com/foo`). Although serving different contents for both URLs is OK, nowadays it's common to treat both URLs as the same URL and redirect between them.

历史上，URLs遵循UNIX的惯例，即在目录中加入尾部斜线（例如：https://example.com/foo/），在引用文件时去掉斜线（https://example.com/foo）。尽管为两个URL提供不同的内容是可以的，但现在通常把两个URL当作同一个URL，并在它们之间重定向。

Symfony follows this logic to redirect between URLs with and without trailing slashes (but only for `GET` and `HEAD` requests):

Symfony遵循这个逻辑，在有尾部斜线和无尾部斜线的URL之间重定向（但只针对GET和HEAD请求）：

| Route URL | If the requested URL is `/foo`       | If the requested URL is `/foo/`     |
| :-------- | :----------------------------------- | :---------------------------------- |
| `/foo`    | It matches (`200` status response)   | It makes a `301` redirect to `/foo` |
| `/foo/`   | It makes a `301` redirect to `/foo/` | It matches (`200` status response)  |



### Sub-Domain Routing

Routes can configure a `host` option to require that the HTTP host of the incoming requests matches some specific value. In the following example, both routes match the same path (`/`) but one of them only responds to a specific host name:

路由可以配置一个主机选项，要求传入请求的HTTP主机与某些特定值相匹配。在下面的例子中，两个路由都匹配相同的路径（/），但其中一个只响应特定的主机名:

```yaml
# config/routes.yaml
mobile_homepage:
    path:       /
    host:       m.example.com
    controller: App\Controller\MainController::mobileHomepage

homepage:
    path:       /
    controller: App\Controller\MainController::homepage
```

The value of the `host` option can include parameters (which is useful in multi-tenant applications) and these parameters can be validated too with `requirements`:

host选项的值可以包括参数（这在多租户应用中很有用），这些参数也可以用requirements进行验证：

```yaml
# config/routes.yaml
mobile_homepage:
    path:       /
    host:       "{subdomain}.example.com"
    controller: App\Controller\MainController::mobileHomepage
    defaults:
        subdomain: m
    requirements:
        subdomain: m|mobile

homepage:
    path:       /
    controller: App\Controller\MainController::homepage
```

In the above example, the `subdomain` parameter defines a default value because otherwise you need to include a subdomain value each time you generate a URL using these routes.

在上面的例子中，子域参数定义了一个默认值，因为否则你每次使用这些路由生成URL时都需要包含一个子域值。

> You can also set the `host` option when [importing routes](https://symfony.com/doc/5.4/routing.html#routing-route-groups) to make all of them require that host name.
>
> 提示：你也可以在导入路由时设置host选项，使所有的路由都需要该host名。



> When using sub-domain routing, you must set the `Host` HTTP headers in [functional tests](https://symfony.com/doc/5.4/testing.html) or routes won't match:
>
> 注：当使用子域路由时，你必须在功能测试中设置Host HTTP头信息，否则路由将不匹配。
>
> ```php
> $crawler = $client->request(
>     'GET',
>     '/',
>     [],
>     [],
>     ['HTTP_HOST' => 'm.example.com']
>     // or get the value from some configuration parameter:
>     // ['HTTP_HOST' => 'm.'.$client->getContainer()->getParameter('domain')]
> );
> ```

> You can also use the inline defaults and requirements format in the `host` option: `{subdomain<m|mobile>?m}.example.com`
>
> 提示：你也可以在host选项中使用内置defaults和requirements。{subdomain<m|mobile>?m}.example.com

> Inline parameter default values support in hosts were introduced in Symfony 5.2. Prior to Symfony 5.2, they were supported in the path only.



### Localized Routes (i18n)

If your application is translated into multiple languages, each route can define a different URL per each [translation locale](https://symfony.com/doc/5.4/translation.html#translation-locale). This avoids the need for duplicating routes, which also reduces the potential bugs:

如果你的应用程序被翻译成多国语言，每个路由可以为每个翻译地区定义一个不同的URL。这就避免了重复路由的需要，这也减少了潜在的错误。

```yaml
# config/routes.yaml
about_us:
    path:
        en: /about-us
        nl: /over-ons
    controller: App\Controller\CompanyController::about
```

> When using PHP attributes for localized routes, you have to use the `path` named parameter to specify the array of paths.
>
> 注：当使用PHP属性进行本地化路由时，必须使用path命名参数来指定路径数组。

When a localized route is matched, Symfony uses the same locale automatically during the entire request.

当匹配本地化路由时，Symfony会在整个请求过程中自动使用相同的区域设置。

> When the application uses full "language + territory" locales (e.g. `fr_FR`, `fr_BE`), if the URLs are the same in all related locales, routes can use only the language part (e.g. `fr`) to avoid repeating the same URLs.
>
> 注：当应用程序使用完整的 "语言+地域 "地域（如fr_FR、fr_BE）时，如果URL在所有相关地域中都是相同的，路由可以只使用语言部分（如fr），以避免重复相同的URL。

A common requirement for internationalized applications is to prefix all routes with a locale. This can be done by defining a different prefix for each locale (and setting an empty prefix for your default locale if you prefer it):

国际化应用程序的一个常见要求是在所有的路由中加入一个地区性的前缀。这可以通过为每个地区定义一个不同的前缀来实现（如果你喜欢，可以为你的默认地区设置一个空的前缀）。

```yaml
# config/routes/annotations.yaml
controllers:
    resource: '../../src/Controller/'
    type: annotation
    prefix:
        en: '' # don't prefix URLs for English, the default locale
        nl: '/nl'
```

Another common requirement is to host the website on a different domain according to the locale. This can be done by defining a different host for each locale.

另一个常见的要求是，根据不同的地区，将网站托管在不同的域名上。这可以通过为每个地区定义一个不同的主机来实现。

> 5.1 The ability to define an array of hosts was introduced in Symfony 5.1.
>
> 5.1 在Symfony 5.1中引入了定义主机数组的能力。

```yaml
# config/routes/annotations.yaml
controllers:
    resource: '../../src/Controller/'
    type: annotation
    host:
        en: 'https://www.example.com'
        nl: 'https://www.example.nl'
```



### Stateless Routes

> 5.1 The `stateless` option was introduced in Symfony 5.1.

Sometimes, when an HTTP response should be cached, it is important to ensure that can happen. However, whenever a session is started during a request, Symfony turns the response into a private non-cacheable response.

有时，当一个HTTP响应应该被缓存时，必须确保能够发生。然而，只要在请求过程中启动了会话，Symfony就会把响应变成一个不可缓存的私有响应。

For details, see [HTTP Cache](https://symfony.com/doc/5.4/http_cache.html).

Routes can configure a `stateless` boolean option in order to declare that the session shouldn't be used when matching a request:

路由可以配置一个stateless布尔选项，以声明在匹配请求时不应该使用会话。

```yaml
# config/routes.yaml
homepage:
    controller: App\Controller\MainController::homepage
    path: /
    stateless: true
```

Now, if the session is used, the application will report it based on your `kernel.debug` parameter:

现在，如果会话被使用，应用程序将根据你的kernel.debug参数来报告它。

- `enabled`

  will throw an [UnexpectedSessionUsageException](https://github.com/symfony/symfony/blob/5.4/src/Symfony/Component/HttpKernel/Exception/UnexpectedSessionUsageException.php) exception

  将会抛出一个[UnexpectedSessionUsageException](https://github.com/symfony/symfony/blob/5.4/src/Symfony/Component/HttpKernel/Exception/UnexpectedSessionUsageException.php) exception

- `disabled`

  will log a warning，日志会记录一个警告。

It will help you understand and hopefully fixing unexpected behavior in your application.

这将帮助你理解并希望能修复你的应用程序中的意外行为。



### Generating URLs

Routing systems are bidirectional: 1) they associate URLs with controllers (as explained in the previous sections); 2) they generate URLs for a given route. Generating URLs from routes allows you to not write the `<a href="...">` values manually in your HTML templates. Also, if the URL of some route changes, you only have to update the route configuration and all links will be updated.

路由系统是双向的：1）它们将URL与控制器相关联（如前几节所述）；2）它们为给定的路由生成URL。从路由中生成URL可以是你不在HTML模板中手动编写<a href="...">。另外，如果某些路由的URL发生变化，你只需要更新路由配置，所有的链接都会被更新。

To generate a URL, you need to specify the name of the route (e.g. `blog_show`) and the values of the parameters defined by the route (e.g. `slug = my-blog-post`).

要生成一个URL，你需要指定路由的名称（如blog_show）和路由定义的参数值（如slug = my-blog-post）。

For that reason each route has an internal name that must be unique in the application. If you don't set the route name explicitly with the `name` option, Symfony generates an automatic name based on the controller and action.

由于这个原因，每个路由都有一个内部名称，在应用程序中必须是唯一的。如果你没有用name选项明确设置路由名称，Symfony会根据控制器和动作自动生成一个名称。



#### Generating URLs in Controllers

If your controller extends from the [AbstractController](https://symfony.com/doc/5.4/controller.html#the-base-controller-class-services), use the `generateUrl()` helper:

如果你的控制器继承自[AbstractController](https://symfony.com/doc/5.4/controller.html#the-base-controller-class-services)，可以使用generateUrl辅助方法：

```php
// src/Controller/BlogController.php
namespace App\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Routing\Generator\UrlGeneratorInterface;

class BlogController extends AbstractController
{
    /**
     * @Route("/blog", name="blog_list")
     */
    public function list(): Response
    {
        // generate a URL with no route arguments
        $signUpPage = $this->generateUrl('sign_up');

        // generate a URL with route arguments
        $userProfilePage = $this->generateUrl('user_profile', [
            'username' => $user->getUserIdentifier(),
        ]);

        // generated URLs are "absolute paths" by default. Pass a third optional
        // argument to generate different URLs (e.g. an "absolute URL")
        $signUpPage = $this->generateUrl('sign_up', [], UrlGeneratorInterface::ABSOLUTE_URL);

        // when a route is localized, Symfony uses by default the current request locale
        // pass a different '_locale' value if you want to set the locale explicitly
        $signUpPageInDutch = $this->generateUrl('sign_up', ['_locale' => 'nl']);

        // ...
    }
}
```

> If you pass to the `generateUrl()` method some parameters that are not part of the route definition, they are included in the generated URL as a query string:
>
> 提示：如果你传递给generateUrl()方法一些不是路由定义的参数，它们将作为查询字符串包含在生成的URL中。
>
> ```php
> $this->generateUrl('blog', ['page' => 2, 'category' => 'Symfony']);
> // the 'blog' route only defines the 'page' parameter; the generated URL is:
> // /blog/2?category=Symfony
> ```
>

> While objects are converted to string when used as placeholders, they are not converted when used as extra parameters. So, if you're passing an object (e.g. an Uuid) as value of an extra parameter, you need to explicitly convert it to a string:
>
> 警告：当对象作为占位符使用时，会被转换为字符串，而当它们作为额外参数使用时，则不会被转换。因此，如果你传递一个对象（例如Uuid）作为额外参数的值，你需要明确地将其转换为字符串。
>
> ```php
> $this->generateUrl('blog', ['uuid' => (string) $entity->getUuid()]);
> ```

If your controller does not extend from `AbstractController`, you'll need to [fetch services in your controller](https://symfony.com/doc/5.4/controller.html#controller-accessing-services) and follow the instructions of the next section.

如果你的控制器没有从AbstractController扩展，你需要在你的控制器中获取服务，并遵循下一节的指示。



#### Generating URLs in Services

Inject the `router` Symfony service into your own services and use its `generate()` method. When using [service autowiring](https://symfony.com/doc/5.4/service_container/autowiring.html) you only need to add an argument in the service constructor and type-hint it with the [UrlGeneratorInterface](https://github.com/symfony/symfony/blob/5.4/src/Symfony/Component/Routing/Generator/UrlGeneratorInterface.php) class:

在我们的服务中注入Symfony路由服务，并使用其generate()方法。当使用service autowiring时，你只需要在服务构造函数中添加一个参数，并用UrlGeneratorInterface类对其进行类型提示。

```php
// src/Service/SomeService.php
namespace App\Service;

use Symfony\Component\Routing\Generator\UrlGeneratorInterface;

class SomeService
{
    private $router;

    public function __construct(UrlGeneratorInterface $router)
    {
        $this->router = $router;
    }

    public function someMethod()
    {
        // ...

        // generate a URL with no route arguments
        $signUpPage = $this->router->generate('sign_up');

        // generate a URL with route arguments
        $userProfilePage = $this->router->generate('user_profile', [
            'username' => $user->getUserIdentifier(),
        ]);

        // generated URLs are "absolute paths" by default. Pass a third optional
        // argument to generate different URLs (e.g. an "absolute URL")
        $signUpPage = $this->router->generate('sign_up', [], UrlGeneratorInterface::ABSOLUTE_URL);

        // when a route is localized, Symfony uses by default the current request locale
        // pass a different '_locale' value if you want to set the locale explicitly
        $signUpPageInDutch = $this->router->generate('sign_up', ['_locale' => 'nl']);
    }
}
```



#### Generating URLs in Templates

Read the section about [creating links between pages](https://symfony.com/doc/5.4/templates.html#templates-link-to-pages) in the main article about Symfony templates.

在关于Symfony模板的文章中读取[creating links between pages](https://symfony.com/doc/5.4/templates.html#templates-link-to-pages) （在页面中创建links）这一章节。



#### Generating URLs in JavaScript

If your JavaScript code is included in a Twig template, you can use the `path()` and `url()` Twig functions to generate the URLs and store them in JavaScript variables. The `escape()` filter is needed to escape any non-JavaScript-safe values:

如果你的JavaScript代码包含在Twig模板中，你可以使用Twig的path()和url()函数来生成URL并将其存储在JavaScript变量中。需要使用escape()过滤器来转义任何非JavaScript安全的值。

```js
<script>
    const route = "{{ path('blog_show', {slug: 'my-blog-post'})|escape('js') }}";
</script>
```

If you need to generate URLs dynamically or if you are using pure JavaScript code, this solution doesn't work. In those cases, consider using the [FOSJsRoutingBundle](https://github.com/FriendsOfSymfony/FOSJsRoutingBundle).

如果你需要动态地生成URL，或者你使用的是纯JavaScript代码，这个解决方案就不适用了。在这些情况下，考虑使用[FOSJsRoutingBundle](https://github.com/FriendsOfSymfony/FOSJsRoutingBundle).



#### Generating URLs in Commands

Generating URLs in commands works the same as [generating URLs in services](https://symfony.com/doc/5.4/routing.html#routing-generating-urls-in-services). The only difference is that commands are not executed in the HTTP context. Therefore, if you generate absolute URLs, you'll get `http://localhost/` as the host name instead of your real host name.

在命令中生成URL与在服务中生成URL的工作方式相同。唯一的区别是，命令不是在HTTP上下文中执行的。因此，如果你生成绝对的URL，你会得到http://localhost/，而不是你真正的主机名。

The solution is to configure the `default_uri` option to define the "request context" used by commands when they generate URLs:

解决方案是配置default_uri选项来定义命令在生成URL时使用的 "请求环境"。

```yaml
# config/packages/routing.yaml
framework:
    router:
        # ...
        default_uri: 'https://example.org/my/path/'
```

> 5.1 The `default_uri` option was introduced in Symfony 5.1.

Now you'll get the expected results when generating URLs in your commands:

现在当执行命令时你将会得到你预期的结果。

```php
// src/Command/SomeCommand.php
namespace App\Command;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
use Symfony\Component\Routing\RouterInterface;
// ...

class SomeCommand extends Command
{
    private $router;

    public function __construct(RouterInterface $router)
    {
        parent::__construct();

        $this->router = $router;
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        // generate a URL with no route arguments
        $signUpPage = $this->router->generate('sign_up');

        // generate a URL with route arguments
        $userProfilePage = $this->router->generate('user_profile', [
            'username' => $user->getUserIdentifier(),
        ]);

        // generated URLs are "absolute paths" by default. Pass a third optional
        // argument to generate different URLs (e.g. an "absolute URL")
        $signUpPage = $this->router->generate('sign_up', [], UrlGeneratorInterface::ABSOLUTE_URL);

        // when a route is localized, Symfony uses by default the current request locale
        // pass a different '_locale' value if you want to set the locale explicitly
        $signUpPageInDutch = $this->router->generate('sign_up', ['_locale' => 'nl']);

        // ...
    }
}
```

> By default, the URLs generated for web assets use the same `default_uri` value, but you can change it with the `asset.request_context.base_path` and `asset.request_context.secure` container parameters.
>
> 默认情况下，为网络资源生成的URL使用相同的default_uri值，但你可以通过asset.request_context.base_path和asset.request_context.secure容器参数来改变它。



#### Checking if a Route Exists

In highly dynamic applications, it may be necessary to check whether a route exists before using it to generate a URL. In those cases, don't use the [getRouteCollection()](https://github.com/symfony/symfony/blob/5.4/src/Symfony/Component/Routing/Router.php#method_getRouteCollection) method because that regenerates the routing cache and slows down the application.

在高度动态的应用程序中，可能有必要在生成URL之前检查它是否存在。在这些情况下，不要使用[getRouteCollection()](https://github.com/symfony/symfony/blob/5.4/src/Symfony/Component/Routing/Router.php#method_getRouteCollection) 方法，因为那会重新生成路由缓存并减慢应用程序的速度。

Instead, try to generate the URL and catch the [RouteNotFoundException](https://github.com/symfony/symfony/blob/5.4/src/Symfony/Component/Routing/Exception/RouteNotFoundException.php) thrown when the route doesn't exist:

相反，尝试生成URL，并捕捉路由不存在时抛出的RouteNotFoundException。

```php
use Symfony\Component\Routing\Exception\RouteNotFoundException;

// ...

try {
    $url = $this->router->generate($routeName, $routeParameters);
} catch (RouteNotFoundException $e) {
    // the route is not defined...
}
```



#### Forcing HTTPS on Generated URLs

By default, generated URLs use the same HTTP scheme as the current request. In console commands, where there is no HTTP request, URLs use `http` by default. You can change this per command (via the router's `getContext()` method) or globally with these configuration parameters:

默认情况下，生成的URL使用与当前请求相同的HTTP scheme。在控制台命令中，如果没有HTTP请求，URL默认使用http。你可以通过每个命令（通过路由器的getContext()方法）或下面这些配置参数在全局范围内改变这一点：

```yaml
# config/services.yaml
parameters:
    router.request_context.scheme: 'https'
    asset.request_context.secure: true
```

Outside of console commands, use the `schemes` option to define the scheme of each route explicitly:

在控制台命令之外，使用 schemes 选项来明确定义每个路由的scheme：

```yaml
# config/routes.yaml
login:
    path:       /login
    controller: App\Controller\SecurityController::login
    schemes:    [https]
```

The URL generated for the `login` route will always use HTTPS. This means that when using the `path()` Twig function to generate URLs, you may get an absolute URL instead of a relative URL if the HTTP scheme of the original request is different from the scheme used by the route:

这里为登录路径生成的URL将始终使用HTTPS。这意味着，当使用Twig函数path()生成URL时，如果原始请求的HTTP scheme 与路由使用的sheme不同，你可能会得到一个绝对URL而不是相对URL。

```twig
{# if the current scheme is HTTPS, generates a relative URL: /login #}
{{ path('login') }}

{# if the current scheme is HTTP, generates an absolute URL to change
   the scheme: https://example.com/login #}
{{ path('login') }}
```

The scheme requirement is also enforced for incoming requests. If you try to access the `/login` URL with HTTP, you will automatically be redirected to the same URL, but with the HTTPS scheme.

scheme requirement也适用于传入的请求，如果你试图用HTTP访问/login URL，你会自动被重定向到相同的URL，但采用HTTPS scheme。

If you want to force a group of routes to use HTTPS, you can define the default scheme when importing them. The following example forces HTTPS on all routes defined as annotations:

如果你想强制一组路由使用HTTPS，你可以在导入它们时定义默认方案。下面的例子在所有定义为注解的路由上强制使用HTTPS。

```yaml
# config/routes/annotations.yaml
controllers:
    resource: '../../src/Controller/'
    type: annotation
    defaults:
        schemes: [https]
```

> The Security component provides [another way to enforce HTTP or HTTPS](https://symfony.com/doc/5.4/security/force_https.html) via the `requires_channel` setting.
>
> 提示：Security件提供了另一种方式（[another way to enforce HTTP or HTTPS](https://symfony.com/doc/5.4/security/force_https.html) ），通过request_channel设置强制执行HTTP或HTTPS。



### Troubleshooting

Here are some common errors you might see while working with routing:

下面是你在使用路由时可能看到的一些常见错误。

```
Controller "App\\Controller\\BlogController::show()" requires that you
provide a value for the "$slug" argument.
```

This happens when your controller method has an argument (e.g. `$slug`):

当你的控制器方法有一个参数（例如$slug）时，就会发生这种情况。

```php
public function show(string $slug): Response
{
    // ...
}
```

But your route path does *not* have a `{slug}` parameter (e.g. it is `/blog/show`). Add a `{slug}` to your route path: `/blog/show/{slug}` or give the argument a default value (i.e. `$slug = null`).

但你的路径没有{slug}参数（例如，它是/blog/show）。在你的路由路径中添加一个{slug}。/blog/show/{slug}或给参数一个默认值（即$slug = null）。

```
Some mandatory parameters are missing ("slug") to generate a URL for route
"blog_show".
```

This means that you're trying to generate a URL to the `blog_show` route but you are *not* passing a `slug` value (which is required, because it has a `{slug}` parameter in the route path). To fix this, pass a `slug` value when generating the route:

这意味着你试图生成一个指向blog_show路由的URL，但你没有传递一个slug值（这是必须的，因为它在路由路径中有一个{slug}参数）。要解决这个问题，在生成路由时要传递一个slug值。

```php
$this->generateUrl('blog_show', ['slug' => 'slug-value']);
```

or, in Twig:

或者在Twig：

```
{{ path('blog_show', {slug: 'slug-value'}) }}
```



### Learn more about Routing

- [How to Create a custom Route Loader](https://symfony.com/doc/5.4/routing/custom_route_loader.html)
- [Looking up Routes from a Database: Symfony CMF DynamicRouter](https://symfony.com/doc/5.4/routing/routing_from_database.html)



