## 模块文件

动物园模快有以下文件：

- animal_rpc.erl

  动物园协议入口文件。

- animal_mgr.erl

  动物园管理进程文件。

- animal.erl





## 协议文件



### 进入动物园

```erlang
handle(1301, #m_1301_tos{type = Type}, Role = #role{role_id = _RoleID}) ->
    case animal_mgr:enter_room(Role, Type) of
        {ok, Data, NewRole} ->
            {ok, Data, NewRole};
        {false, Reason} ->
            {false, Reason}
    end;
```





### 退出动物园



### 打动物

```erlang
handle(1303, #m_1303_tos{id = Id, coin = Coin}, Role = #role{hit_num = Num}) ->
    case animal:hit(Role, Id, Coin) of
        {ok, NewRole} ->
            case Coin < 1000 of
                true ->
                    {ok, #m_1303_toc{}, NewRole#role{hit_num = Num + 1}};
                _ ->
                   {ok, #m_1303_toc{}, NewRole}
            end;
        {false, Reason} ->
            {false, Reason}
    end;
```

- Id：动物Id
- Coin：炮值，消耗的金币值

该协议主要调用animal房间进程来处理玩家打动物。





### 使用技能（道具）

```erlang
%% 使用道具技能
handle(1304, #m_1304_tos{type = Type}, Role = #role{room_type = experience}) ->
    case animal_experience:use_item(Role, Type) of
        {ok, NewRole} ->
            {ok, #m_1304_toc{}, NewRole};
        {false, Reason} ->
            {false, Reason}
    end;
handle(1304, #m_1304_tos{type = Type}, Role) ->
    case animal:use_item(Role, Type) of
        {ok, NewRole} ->
            {ok, #m_1304_toc{}, NewRole};
        {false, Reason} ->
            {false, Reason}
    end;
```







## animal_mgr进程

animal_mgr.erl是房间管理进程，它会随着游戏启动时而启动。它的state如下：

```erlang
-record(state, {
	id = 0,
	list = []
}).
```

- id：房间id，用于标识房间

- list

  一个元组列表，键是房间类型，值是房间列表。

  类似 [{Type, [Room...]}, {Type, [Room...]}]，Room是animal_room record







### 初始化

```erlang
init([]) ->
    ?INFO("[~w] 正在启动", [?MODULE]),
    process_flag(trap_exit, true),
    erlang:process_flag(min_bin_vheap_size, 1024*1024),
    erlang:process_flag(min_heap_size, 1024*1024),
    erlang:process_flag(priority, high),
    State = #state{},
    ?INFO("[~w] 启动完成", [?MODULE]),
    {ok, State}.
```

只是把自己设置为系统进程，并调整了进程优的先级和堆大小。



### get_room_pid

get_room_pid消息是从进程状态的房间列表中，根据房间类型寻找到一个可以加入的房间（房间进程）。

代码如下：

```erlang
handle_call({get_room_pid, Type = single, TaskId}, _From, State = #state{id = NextId}) ->
    case start_room({Type, TaskId}, NextId) of
        #animal_room{pid = Pid} ->
            {reply, {ok, Pid}, State#state{id = NextId + 1}};
        _ ->
            {reply, false, State}
    end;


handle_call({get_room_pid, Type, _}, _From, State = #state{id = NextId, list = List}) ->
    %% 根据房间类型寻找对应的房间列表
    case lists:keyfind(Type, 1, List) of
        {Type, RoomList} ->
            case find_room(RoomList) of
                %% 找到空位房间
                Room = #animal_room{id = Id, pid = Pid, num = Num} ->
                    NewList = lists:keydelete(Id, #animal_room.id, RoomList),
                    NewList1 = [Room#animal_room{num = Num + 1} | NewList],
                    {reply, {ok, Pid}, State#state{list = lists:keyreplace(Type, 1, List, {Type, NewList1})}};
                %% 未找到空位房间
                _ ->
                    case start_room(Type, NextId) of
                        Room = #animal_room{pid = Pid} ->
                            NewList = [Room | RoomList],
                            {reply, {ok, Pid}, State#state{id = NextId + 1, list = lists:keyreplace(Type, 1, List, {Type, NewList})}};
                        _ ->
                            {reply, false, State}
                    end
            end;
        _ ->
            %% 开启一个房间
            case start_room(Type, NextId) of
                Room = #animal_room{pid = Pid} ->
                    {reply, {ok, Pid}, State#state{id = NextId + 1, list = [{Type, [Room]} | List]}};
                _ ->
                    {reply, false, State}
            end
    end;


```

寻找可以加入房间的主体逻辑。



```erlang
%% 寻找有空位的房间
find_room([]) -> false; 
find_room([Room = #animal_room{num = Num}| _L]) when Num < ?animal_max_num->
    Room;
find_room([_Room | L]) ->
    find_room(L).
```

从房间列表中寻找是否有空位的房间。



```erlang
start_room(Type, Id) ->    
    case catch animal:start_link(Type, Id) of        
        {ok, Pid} ->            
            #animal_room{id = Id, type = Type, num = 1, pid = Pid};        
        _ ->            
            false    
    end.
```

开启一个房间，其实就是创建一个房间进程。

Type是房间类型，Id是房间标识，这里animal_mgr进程会与animal进程建立一个链接关系。





## animal_mgr方法

### 进入房间

寻找可以加入的房间由房间管理进程来负责。

```erlang
%% 进入房间
enter_room(Role = #role{status = ?status_normal, use_coin = Coin, guide_task = #guide_task{id = TaskId}}, Type) ->
    %% 获取房间最小炮值
    Need = animal:get_min_coin(Type, TaskId),
    
    %% 玩家已解锁的炮等级
    {Max, _, _} = zoo_room_power_setting:get_data(Coin),
    
    %% 这里应该是判断玩家的最大炮值是否大于房间要求的最小炮值
    case Max >= Need of
        true ->
            %% 寻找一个可以加入的房间
            case catch gen_server:call(?MODULE, {get_room_pid, Type, TaskId}) of
                {ok, Pid} ->
                    %% 向房间进程发生一个enter信息
                    case catch gen_server:call(Pid, {enter, role_conver:to_animal_role(Role)}) of
                        {ok, Data} ->
                            {ok, Data, Role#role{room_type = Type, room_pid = Pid, status = ?status_zone}};
                        _Err ->
                            {false, ?error_busy}
                    end;
                _Err ->
                    {false, ?error_busy}
            end;
        _ ->
            {false, ?error_act}
    end;
enter_room(_, _) ->
    {false, ?error_act}.
```

- status

  表示玩家当前所处状态，值有大厅、动物园等，

- use_coin

  使用的炮等级

- guide_task

  该字段是一个guide_task record，它的id暂时不知道作用

- Type

  房间类型

房间是有不同类型的。

每种房间的最低炮值是不一样的，因此在玩家进入房间时会检查玩家已解锁的最大炮值。

接着寻找一个可以加入的房间，其实就是一个房间进程。在找到房间进程后，就会向房间进程发送一条enter消息，同时把玩家数据传递过去，由该房间进程处理玩家信息。



寻找一个可以加入的房间代码：

```erlang
handle_call({get_room_pid, Type, _}, _From, State = #state{id = NextId, list = List}) ->
    %% 根据房间类型寻找对应的房间列表
    case lists:keyfind(Type, 1, List) of
        {Type, RoomList} ->
            case find_room(RoomList) of
                %% 找到空位房间
                Room = #animal_room{id = Id, pid = Pid, num = Num} ->
                    NewList = lists:keydelete(Id, #animal_room.id, RoomList),
                    NewList1 = [Room#animal_room{num = Num + 1} | NewList],
                    {reply, {ok, Pid}, State#state{list = lists:keyreplace(Type, 1, List, {Type, NewList1})}};
                %% 未找到空位房间
                _ ->
                    case start_room(Type, NextId) of
                        Room = #animal_room{pid = Pid} ->
                            NewList = [Room | RoomList],
                            {reply, {ok, Pid}, State#state{id = NextId + 1, list = lists:keyreplace(Type, 1, List, {Type, NewList})}};
                        _ ->
                            {reply, false, State}
                    end
            end;
        _ ->
            %% 开启一个房间
            case start_room(Type, NextId) of
                Room = #animal_room{pid = Pid} ->
                    {reply, {ok, Pid}, State#state{id = NextId + 1, list = [{Type, [Room]} | List]}};
                _ ->
                    {reply, false, State}
            end
    end;
```

房间管理进程的State存储了房间列表。

首先寻找空位房间，如果找不到则创建房间进程，再加入到房间管理进程State的列表中；

如果寻找到可用房间进程，会判断房间是否满人。房间如果不满人，那么加入房间并更新房间列表。房间满人则新创建房间，加入到房间列表。









## animal进程

animal.erl是房间进程

### State

```erlang
-record(state, {
    id = 0,
    type = 0,			%% 房间类型
    role_list = [],		%% 玩家列表
    animal_list = [],	%% 动物列表
    pre_list = [],		%% 动物预警列表
    skill = [],			%% 技能列表
    num = 1,			%% 动物id，从1开始
    guide_task = 0
}).
```

- id

  房间id，房间的标识

- type

  房间类型

- role_list

  玩家列表

- animal_list

  产生的动物列表

- pre_list

  动物预警列表

- guide_task

- num

  猜测是动物id，从1开始

- skill

  当前进程已使用的技能列表。



### 初始化

```erlang
init([Type, Id]) ->
    process_flag(trap_exit, true),
    
    State = case Type of
        {Type1, TaskId} ->
            #state{id = Id, type = Type1, guide_task = TaskId};
        _ ->
            #state{id = Id, type = Type}
    end,
    
    %% 初始化进程状态
    NewState = do_init(State),
    
    %% 每隔1秒向自身发送一条check_animal_out消息
    erlang:send_after(1000, self(), check_animal_out),
    {ok, NewState}.

```

- Id

  房间Id，唯一的值，由animal_mgr分发。

- Type

  房间类型。

  它也可能是一个元组，这种情况一般是单人场才会发生。可以在animal_mgr的get_room_pid消息处理中看到这种情况的发生。

主要的初始化逻辑在do_init函数中，该函数会调用init_animal()函数，主要用于产生动物。同时会触发一个定时器，向自身发送一条check_animal_out消息，用于检查动物退出。



```erlang
do_init(State) ->
    init_animal(20, State).

init_animal(0, State) -> State;
init_animal(N, State = #state{animal_list = List, role_list = RoleList, num = Num, pre_list = PreList, type = Type, guide_task = TaskId}) ->
    %% 产生动物
    {PushList, NewList, NewNum, PreList1} = init_animal(N, [], List, Num, RoleList, PreList, Type, TaskId),
    
    %% 向房间中的玩家推送动物列表
    push_animal_enter(PushList, RoleList),
    NewState = State#state{animal_list = NewList, num = NewNum, pre_list = PreList1},
    NewState.
```

- State

  animal进程状态

该函数主要做了产生动物，向玩家推送动物列表，更新进程状态3个操作。





```erlang
init_animal(0, List1, List, Num, _, PreList, _Type, _) -> {List1, List, Num, PreList};
init_animal(N, List1, List, Num, RoleList, PreList, Type, TaskId) ->
    %% 随机产生一只动物
    Animal = #animal_base{base_id = BaseId, rate = [Min, Max]} = get_one_annimal(PreList ++ List, TaskId),
    
    %% 确定倍率
    Rate = sys_rand:rand(Min, Max),
    
    %% 创建红包
    RedBag = create_red_bag(Type, BaseId),
    
    %% 初始化路线
    #animal_route{id = RouteId, time = AllTime, post = Post, xy = XY} = init_animal_route(),
    
    %% 预警动物与普通动物的俩种处理
    case lists:member(BaseId, ?animal_pre_notice_list) of
        true ->
            %% 为animal_base record各个字段赋值，这个就是当前动物的属性了
            NewAnimal = Animal#animal_base{id = Num, end_time = AllTime, post = 0, route_id = RouteId, xy = XY, red_bag = RedBag, rate = Rate},
            %% 推送预警信息
            push_pre_animal(BaseId, RoleList),
            %% 预警动物之后再加载
            erlang:send_after(3000, self(), {add_animal, NewAnimal}),   
            %% 预警动物会加入到预警列表中，然后再次递归，产生下一只动物
            init_animal(N -1, List1, List, Num + 1, RoleList, [NewAnimal | PreList], Type, TaskId);
        _ ->
            %% 为animal_base record各个字段赋值
            NewAnimal = Animal#animal_base{id = Num, end_time = AllTime, post = Post, route_id = RouteId, xy = XY, red_bag = RedBag, rate = Rate},
            %% 如果是普通动物，会分别加入到List1和List列表中
            init_animal(N -1, [NewAnimal | List1], [NewAnimal| List], Num + 1, RoleList,  PreList, Type, TaskId)
    end.
```

参数：

- N：表示产生多少只动物
- Num：猜测用于标识产生的动物，Num标识animal进程当前产生动物的最大Id
- List1：要推送的动物列表
- List：animal进程的动物列表
- PreList：animal进程的预警动物列表
- TaskId：引导任务Id？

返回值是一个元组：

- List1：推送给玩家的动物列表
- List：动物列表，用于更新animal进程的animal_list字段
- Num：猜测是动物数量，因为animal进程有更新num字段？但是也看到作为animal_base record的id字段
- PreList：预警动物列表，用于更新animal进程的pre_list字段

init_animal()函数会递归的产生动物，每递归一次就产生一只动物。





```erlang
get_one_annimal(List, _TaskId) ->
    %% OnlyList是只允许出现一次的动物列表，这里面的动物就不要再产生了。
    OnlyList = [Id || #animal_base{base_id = Id} <- List, lists:member(Id, ?animal_only_one_list)],

    %% 可随机产生的动物列表
    NewList = [A||A = #animal_base{base_id = Id} <-get_animal_base(), not lists:member(Id, OnlyList)],

    %% 根据动物的出现概率，随机产生一只动物
    case sys_rand:rand_list(NewList, #animal_base.pre) of
        %% 如果是同类型炸弹人，那么会随机产生一只炸弹类型的动物。
        Animal = #animal_base{base_id = type_bomber, bomber_type = List1} ->
            Type = sys_rand:rand_list(List1),
            #animal_base{rate = Rate} = lists:keyfind(Type, #animal_base.base_id, get_animal_base()),
            Animal#animal_base{bomber_type = Type, rate = Rate};
        _Animal -> _Animal
    end.
```

随机产生产生一只动物。

- List

  预警动物列表与普通动物列表的集合

它的逻辑是：

1. 从已产生的动物列表、预警列表里面找出只允许出现一次的动物，OnlyList就是寻找的结果，这个列表里面的动物是不允许再次产生的。
2. 获取整个动物列表配置，从中排除已出现过的只允许出现一次的动物，得到一个可以随机出动物的列表，即第二行代码。
3. 根据动物产生的概率，随机出一只动物。animal_base的pre字段表示产生的概率。



### enter（加入房间）

房间管理进程在为玩家寻找到合适的房间进程后，就会向其发送一条加入信息，将玩家加入到房间中。

以下是加入房间的代码，主要逻辑是把玩家信息加入到进程的玩家列表中，再向其他人推送进入消息。

```erlang
%% 玩家进入
handle_call({enter, Role = #animal_role{role_id = RoleId}}, _From, State = #state{type = Type, role_list = RoleList, animal_list = AnimalList}) ->
    %% 将当前玩家加入房间玩家列表中
    NewList = lists:keystore(RoleId, #animal_role.role_id, RoleList, Role),

    %% 向其他玩家推送进入消息
    push_in(Role, RoleList),
    
    %% 新的玩家列表
    NewList1 = to_p_animal_role(NewList),
    
    %% 动物列表
    NewList2 = to_p_animal(AnimalList),
    
    %% 响应数据并更新进程状态
    Data = #m_1301_toc{animals = NewList2, role_list = NewList1, type = Type},
    {reply, {ok, Data}, State#state{role_list = NewList}};
```



以下是向其他玩家推送有玩家进入房间，代码逻辑很简单，List是要推送的玩家列表，Role是进入房间的玩家。

```erlang
%% 推送玩家进入信息
push_in(Role = #animal_role{}, List) ->
    Role1 = to_p_animal_role(Role),
    
    %% 向其他玩家推送有玩家进入的信息
    [sys_conn:pack_send(Pid, 1307, #m_1307_toc{role = Role1}) || #animal_role{socket_pid = Pid} <- List].
```

- Role

  当前玩家

- List

  其他玩家





### hit

```erlang
%% 打动物
handle_call({hit, RoleId, Id, Coin, Luck, Flag}, _From, State = #state{role_list = RoleList, animal_list = AnimalList}) ->
    %% 根据RoleId取出房间中的玩家数据
    case lists:keyfind(RoleId, #animal_role.role_id, RoleList) of
        Role = #animal_role{vip = Vip} -> 
            %% 根据动物id从动物列表中取出打中的动物
            case lists:keyfind(Id, #animal_base.id, AnimalList) of
                %% self_id =:= 0表示普通动物，self_id =:= RoleId表示私有动物
                %% 满足这俩种情况才执行代码
                Animal = #animal_base{self_id = SelfId} when SelfId =:= 0 orelse SelfId =:= RoleId ->
                    %% 向房间中的所有玩家推送 我 打动物的信息
                    push_hit(RoleId, Id, RoleList),
                    
                    %% 计算是否打爆
                    case do_hit(Animal, AnimalList, Coin, Vip, Luck, Flag, RoleId) of 
                        {HitList, NewAnimalList, Skill, ItemList, CreateNum, NewLuck} ->
                            %% 向房间中的玩家推送动物死亡信息
                            push_die(HitList, Skill, RoleId, RoleList),
                            
                            %% 根据CreateNum创建新的动物
                            NewState = init_animal(CreateNum, State#state{animal_list = NewAnimalList}),
                            %% 全服推送当前玩家打中的动物和掉落的物品
                            do_broadcast(Animal, Role, ItemList),
                            {reply, {ok, HitList, ItemList, NewLuck}, NewState};
                        _ ->
                            {reply, ok, State}
                    end;
                %% 该私有动物不属于该玩家
                #animal_base{} ->
                    {reply, {false, ?error_animal_self}, State};
                %% 动物不存在
                _ ->
                    {reply, {false, ?error_animal_exit}, State}
            end;
        _ ->
            {reply, {false, ?error_act}, State}
    end;
```

玩家打中动物的消息处理，参数如下：

- RoleId：当前打动物的玩家id

- Id：动物Id

- Coin：消耗金币

- Luck：幸运次数

- Flag：动物园标记，99是白名单，98是撸羊毛

hit消息的返回结果有：

- ok：没打中动物
- {ok, HitList, ItemList, NewLuck}：打中动物，HitList是打中动物的列表，ItemList是掉落的物品列表，NewLuck是幸运次数。
- {false, error}：false标识执行失败，error是错误结果。

同时还更新了进程状态，即新增了动物。



```erlang
%% 是否打爆
%% 特殊处理皮卡丘和炸弹人
do_hit(Animal = #animal_base{base_id = pikachu},  AnimalList, Coin, Vip, Luck, Flag, RoleId) ->
    NewList = lists:delete(Animal, AnimalList),
    {Rate, HitList0} = do_hit_pikachu([Animal | NewList], 0, []),
    case do_rate(Rate/10, Coin, Flag) of
        true ->
            Active = get_acitve(),
            {HitList, NewAnimalList, ItemList, CreateNum, NewLuck} = do_drop(HitList0, AnimalList, Coin, Vip, [], [], 0, Luck, Active, RoleId),
            {HitList, NewAnimalList, 1, ItemList, CreateNum, NewLuck};
        _ ->
            false
    end;
%% 全屏炸弹
do_hit(_Animal = #animal_base{base_id = bomber},  AnimalList, Coin, Vip, Luck, Flag, RoleId) ->
    {Rate, HitList0} = do_hit_bomber(AnimalList, 0, [], RoleId),
    case do_rate(Rate/10, Coin, Flag) of
        true ->
            Active = get_acitve(),
            {HitList, NewAnimalList, ItemList, CreateNum, NewLuck} = do_drop(HitList0, AnimalList, Coin, Vip, [], [], 0, Luck, Active, RoleId),
            {HitList, NewAnimalList, 2, ItemList, CreateNum, NewLuck};
        _ ->
            false
    end;
%% 同类型炸弹人
do_hit(_Animal = #animal_base{base_id = type_bomber, bomber_type = Type}, AnimalList, Coin, Vip, Luck, Flag, RoleId) ->
    {Rate, HitList0} = do_hit_type_bomber(AnimalList, 0, [], Type),
    case do_rate(Rate/10, Coin, Flag) of
        true ->
            Active = get_acitve(),
            {HitList, NewAnimalList, ItemList, CreateNum, NewLuck} = do_drop(HitList0, AnimalList, Coin, Vip, [], [], 0, Luck, Active, RoleId),
            {HitList, NewAnimalList, 2, ItemList, CreateNum, NewLuck};
        _ ->
            false
    end;
%% 局部炸弹
do_hit(_Animal = #animal_base{base_id = area_bomber, route_id = Id, post = Post},  AnimalList, Coin, Vip, Luck, Flag, RoleId) ->
    Point = get_xy(Id, Post),
    {Rate, HitList0} = do_hit_area_bomber(AnimalList, Point, [], 0, RoleId),
    case do_rate(Rate/10, Coin, Flag) of
        true ->
            Active = get_acitve(),
            {HitList, NewAnimalList, ItemList, CreateNum, NewLuck} = do_drop(HitList0, AnimalList, Coin, Vip, [], [], 0, Luck, Active, RoleId),
            {HitList, NewAnimalList, 2, ItemList, CreateNum, NewLuck};
        _ ->
            false
    end;
%% 普通动物
do_hit(Animal = #animal_base{rate = Rate}, AnimalList, Coin, Vip, Luck, Flag, RoleId) ->
    %% Rate是倍率，这里除以10再传入
    case do_rate(Rate/10, Coin, Flag) of
        true ->
            Active = get_acitve(),
            {HitList, NewAnimalList, ItemList, CreateNum, NewLuck} = do_drop([Animal], AnimalList, Coin, Vip, [], [], 0, Luck, Active, RoleId),
            {HitList, NewAnimalList, 0, ItemList, CreateNum, NewLuck};
        _ ->
            false
    end.
```

do_hit函数会计算动物是否被打爆，不同类型的动物打爆的效果是不同的。

- Animal

  打中的动物数据，它是一个animal_base record

- AnimalList

  当前房间的动物列表

- Coin

  消耗金币

- Vip

- Luck

  幸运次数

- Flag

  动物园标记，99是白名单，

- RoleId

  当前打动物的玩家id


如果打中动物，返回值是一个元素，除了第三个元素，其他元素的意义参考do_drop()函数。如果没有打中动物返回false。



```erlang
do_rate(Rate, _Coin, 99)->
    Pre1  = case setting_mgr:get(?setting_animal_white_pre) of
        {ok, Value} -> Value/1000;
        _ -> ?animal_white_pre
    end,
    N = sys_rand:rand(?animal_rand_num),
    Pre = 1/Rate * Pre1,
    Num = Pre * ?animal_rand_num,
    N =< Num;
%% 黑名单
do_rate(Rate, _Coin, 97)->
    Pre1  = case setting_mgr:get(?setting_animal_black_pre) of
        {ok, Value} -> Value/1000;
        _ -> ?animal_black_pre
    end,
    N = sys_rand:rand(?animal_rand_num),
    Pre = 1/Rate * Pre1,
    Num = Pre * ?animal_rand_num,
    N =< Num;
%% 薅羊毛的党处理，金币大于1000， 倍数高于50（会有红包产出）98标识为薅羊毛
do_rate(Rate, Coin, Flag)->
    case Rate >= 50 andalso Coin >= 1000 andalso Flag =:= 98 of
        %% 羊毛党处理
        true -> 
            false;
        %% 正常玩家处理
        _ ->
            %% 获取返奖率
            Pre1  = case setting_mgr:get(?setting_animal_pre) of
                {ok, Value} -> Value/1000;
                _ -> ?animal_pre
            end,
            
            %% ?animal_rand_num：动物园随机数，值1,0000,0000
            N = sys_rand:rand(?animal_rand_num),
            
            %% Rate：倍率，比如小鸡的范围是8-15，假设是15，那么在这里是1.5
            Pre = 1/Rate * Pre1,
            Num = Pre * ?animal_rand_num,
            N =< Num
    end.
```

根据倍率计算是否打中动物。

- Rate

  倍率，动物的倍率传递进来前已经被除以10了。
  
  在动物基本配置中，倍率的大小似乎乘以10了，所以传递进来该方法的时候要除以10。不知道为啥这样子设计。

假设一只大象，他的倍率是1000，在不在抽水的情况下，那么它的概率就是1/1000，代码应该这样写：

```erlang
N   = sys_rand:rand(?animal_rand_num).
Num = 1/Rate * ?animal_rand_num.
N <= Num; 
```

1至1/1000 * ?animal_rand_num这部分数字对应的概率就是1/1000，所以Num代表着概率对应?animal_rand_num的最大值。

所以N <= Num就表示本次概率是否触发。



```erlang
%% 计算掉落
do_drop([Animal = #animal_base{is_horn = Horn} | L], AnimalList, Coin, Vip, HitList, ItemList, CreateNum, Luck, Active, RoleId) ->
    %% 在动物列表中删除死亡的动物
    NewAnimalList = lists:delete(Animal, AnimalList),
    
    NewCreateNum = case Horn of
        %% 非召唤动物则CreateNum+1
        0 -> CreateNum + 1;
        %% 召唤动物的特殊处理?
        _ -> 
            self() ! {delete_skill, Horn},
            CreateNum
    end,
    %% NewAnimal是#animal_base record，其中的drop_list是一个列表，保存了掉落物品，
    {NewAnimal, NewItemList, NewLuck} = do_drop_item(Animal, ItemList, Coin, Vip, Luck, Active, RoleId),
    
    do_drop(L, NewAnimalList, Coin, Vip, [NewAnimal | HitList], NewItemList, NewCreateNum, NewLuck, Active, RoleId);

do_drop([], AnimalList, _Coin, _Vip, HitList, ItemList, CreateNum, Luck, _Active, _) ->
    {HitList, AnimalList, ItemList, CreateNum, Luck}.
```

请求参数说明：

- 参数1：死亡的动物列表
- AnimalList：当前房间进程中的动物列表
- Coin：消耗的金币
- Vip：
- HitList：默认[]，表示打中的动物列表。
- ItemList：默认[]，掉落的物品列表，它是一个同类型物品数量已经合并过的列表。
- CreateNum：默认0，指要创建多少只动物，基本等同于死亡动物数量（因为有召唤动物处理）。
- Luck：幸运次数
- RoleId：玩家Id

这个函数做了俩件事情，一是从进程的动物列表中删除了死亡的动物，二是分别计算每只死亡的动物掉落的道具数量。

返回参数说明：

HitList是打中的动物列表，AnimalList是删除了打中动物的列表，ItemList是掉落的道具列表，CreateNum是要创建新动物的数量。



```erlang
%% 计算所有掉落 
do_drop_item(Animal = #animal_base{base_id = BaseId, rate = Rate, item_list = List, red_bag = RedBag}, ItemList, Coin, Vip, Luck, Active, RoleId)->
    %% 列表，掉落的红包金额和金币
    Coins  = calc_coin_red(BaseId, Rate, Coin, RedBag),
    
    {Lollipops,NewLuck} = calc_lollipop(Coin, Rate, Vip, Luck),
    Items = calc_item(Coin, List, Vip),
    ActiveItems = calc_active_item(Coin, Rate, Active, RoleId),
    Active1 = get_acitve1(),
    ActiveItems1 = calc_active_item1(Coin, Rate, Active1, RoleId),
    DropList = Coins ++ Lollipops ++ Items ++ ActiveItems ++ ActiveItems1,
    NewItemList = do_sort_item(DropList, ItemList),
    {Animal#animal_base{drop_list = DropList}, NewItemList, NewLuck}.
```

- Animal：当前死亡的动物
- ItemList：默认[]
- Coin：消耗金币
- Vip
- Luck
- Active
- RoleId

返回的是一个元组，第一个元素是死亡的动物，它的drop_list字段保存了掉落的物品，NewItemList是对同类型物品的合并结果，也是一个List。NewLuck是幸运次数。



```erlang
%% 计算所获得的金币和红包
calc_coin_red(_, Rate, Coin, 0) ->
    Win = trunc(Rate * Coin/10),
    [#p_assets{type = coin, num = Win}];

%% 金猪红包的特殊处理
calc_coin_red(gold_pick, Rate, Coin, Red) ->
    Win = trunc(Rate * Coin/10),
    %% 金猪的红包是赢的金币的8成，也就是说抽了2成的水。
    RedBag = trunc(Win * 0.8/100),
    Type = case Red of
        1 -> red_bag;
        2 -> gold
    end,
    %% 掉红包的同时返8888金币
    [#p_assets{type = Type, num = RedBag}, #p_assets{type = coin, num = 8888}];

%% 其他红包动物的处理
calc_coin_red(_, Rate, Coin, Red) ->
    %% 从10-22之间随机出一个数
    N = sys_rand:rand(10, 22),
    
    %% 赢的金币
    Win = trunc(Rate * Coin/10),
    
    %% Win/10000 = 赢的钱
    %% trunc(N * Win/10000) = R，乘以随机数N得到一个红包的随机值
    %% 20000与R其中一个更小的值
    %% 所以要直到能够产生的最大Win是多少，最小Win是多少，这样就能购直到为什么这样设计了。
    RedBag = min(20000, trunc(N * Win/10000)),
    
    %% 猜测RedBag单位是角，
    
    %% 接着将红包的价值乘以1.2呗，在转换成金币，Win - 红包的金币就是剩余玩家要拿到的金币了。
    %% 疑问：如果产生的红包足够大，那么返还的金币岂不是会成负值
    %% 猜测红包的产生的数值跟 炮数（可能限制必须多少炮才能打） 和 房间类型（指定房间才有红包） 相关
    Coin1 = Win - trunc(RedBag * 1.2 * 100),
    Type = case Red of
        1 -> red_bag;
        2 -> gold
    end,
    [#p_assets{type = Type, num = RedBag}, #p_assets{type = coin, num = Coin1}].
```

计算所获得的金币和红包。

- 参数1：动物类型，即#animal_base的base_id字段

- Rate：倍率，Rate来传进来的时候没有被除以10，配置表的值是多少，这里的值就是多少。
- Coin：消耗金币
- 参数3：是否有红包



```erlang
%% 计算棒棒糖掉落
calc_lollipop(_Coin, _, Vip, Luck) when Vip < 2-> {[], Luck};
calc_lollipop(_Coin, 0, _Vip, Luck) -> {[], Luck};
calc_lollipop(Coin, _, _Vip, Luck) when Coin < 1000 -> {[], Luck};
calc_lollipop(Coin, Rate, _, Luck) ->
    %% 随机要掉落的糖果类型
    Type = sys_rand:rand_list([candy, lolly, lollipop]),
    
    Rate1 = get_lollipop_pre(Type, Coin, Rate),
    case do_rate(Rate1, Coin, 1) of
        true ->
            {[#p_assets{type = Type, num = 1}], Luck};
        _ ->
            {[], Luck}
    end.
```

计算棒棒糖的掉落概率。

- Coin：消耗金币
- Rate：倍率
- Vip
- Luck

前面三个模式匹配是限制掉落糖果的条件，vip小于2的不掉落，炮值低于1000的不掉落，倍率为0不掉落。

```erlang
%% 棒棒糖掉落几率
get_lollipop_pre(Type, Coin, Rate) when is_integer(Rate) andalso Rate > 0 andalso is_integer(Coin) andalso Coin > 0->
    %% 返奖率
    Pre  = case setting_mgr:get(?setting_animal_pre) of
        {ok, Value1} -> Value1/1000;
        _ -> ?animal_pre
    end,
    %% 棒棒糖掉落概率，?lollipop_pre=0.02
    LPre  = case setting_mgr:get(?setting_lollipop_pre) of
        {ok, Value2} -> Value2/1000;
        _ -> ?lollipop_pre
    end,
    %% 糖果价值多少金币，4就是4万金币。
    Value = case Type of
        %% 大
        lollipop -> 200;
        %% 中
        lolly -> 40;
        %% 小
        candy -> 4
    end,
    %% Rate/10 = 动物死亡概率
    %% 掉落概率/返奖率 * 消耗金币 = 本次点击抽水的金币价值
    %% 抽水金币/棒棒糖价值
    1/(Rate/10 * (Coin * (LPre/Pre) / (Value * 10000))).
```

- Type：糖果类型
- Coin：消耗金币
- Rate：倍率









```erlang
%% 合并所有道具数量,并且转换人物所需要的格式
do_sort_item([], ItemList) -> ItemList;
do_sort_item([#p_assets{type = Type, num = Num} | L], ItemList) ->
    case lists:keyfind(Type, 1, ItemList) of
        {Type, Num1} ->
            NewList = lists:keyreplace(Type, 1, ItemList, {Type, Num + Num1}),
            do_sort_item(L, NewList);
        _ ->
            do_sort_item(L, [{Type, Num} | ItemList])
    end.
```

参数1是掉落的物品列表，可能会有重复的物品，因为需要进行合并。

ItemList是空列表，代码逻辑是将DropList中的元素移动到ItemList，在移动的同时检查ItemList是否有重复的元素。





### use_item(使用技能)

```erlang
%% 玩家使用道具
handle_call({use_item, RoleId, Item}, _From, State = #state{role_list = RoleList, skill = SkillList, type = Type}) ->
    case lists:keyfind(RoleId, #animal_role.role_id, RoleList) of
        Role = #animal_role{skill_id = IdList} ->
            %% 判断技能是否在玩家已使用的技能列表中
            case lists:member(Item, IdList) of
                true ->
                    {reply, {false, ?error_item_use}, State};
                _ ->
                    %% 判断技能是否在 房间 已使用的技能列表中
                    case lists:member(Item, SkillList) of
                        true ->
                            {reply, {false, ?error_item_repeat}, State};
                        _ ->
                            case Item =:= self_horn orelse Item =:= gold_pick of
                                %% 私有大象和金猪的处理
                                true ->
                                    case Type =/= 100 of
                                        true ->
                                            case do_use_skill(Role, Item, State) of
                                                {ok, NewState} ->
                                                    {reply, ok, NewState};
                                                {ok, Reply, NewState} ->
                                                    {reply, Reply, NewState};
                                                {false, Reason} ->
                                                    {reply, {false, Reason}, State}
                                            end;
                                        _ ->
                                            {reply, {false, ?error_act}, State}
                                    end;
                                %% 其他道具的处理
                                _ ->
                                    case do_use_skill(Role, Item, State) of
                                        {ok, NewState} ->
                                            {reply, ok, NewState};
                                        {ok, Reply, NewState} ->
                                            {reply, Reply, NewState};
                                        {false, Reason} ->
                                            {reply, {false, Reason}, State}
                                    end
                            end
                    end
            end;
        _ ->
            {reply, {false, ?error_act}, State}
    end;
```

房间进程处理玩家使用道具的逻辑。每一种道具对玩家、房间的影响都是不同的，这里就是处理这些不同的逻辑。

返回值有ok、Reply和{false, Reason}。Reply是要返回处理的结果，do_use_skill/3函数在处理，私有道具（狂暴、锁定、自动）就会返回数据。

Reason是错误原因。





以下是使用冰冻技能的处理：

```erlang
do_use_skill(_Role = #animal_role{role_id = RoleId, icon = Icon}, Item = ice, State = #state{role_list = RoleList, animal_list = AnimalList, skill = Skill}) ->
    %% 将所有动物的状态改为冰冻
    NewAnimal = [A#animal_base{status = 1}||A = #animal_base{} <- AnimalList],
    
    %% 10秒后触发定时器，删除技能
    erlang:send_after(10000, self(), {delete_skill, Item}),
    
    %% 向所有玩家推送使用技能的信息
    push_use_skill(RoleId, Icon, Item, RoleList),
    %% 向所有玩家推送动物被冰冻的状态
    pus_animal_status(NewAnimal, RoleList),
    
    %% 将使用的技能加入State的skill字段
    {ok, State#state{animal_list = NewAnimal, skill = [Item | Skill]}};
```

- Role：房间进程中的玩家信息，animal_role record。
- Item：道具类型，原子。
- State：房间进程的状态。skill跳过的意思，这里代表房间内已经使用的技能，是一个列表。比如这里是冰冻，房间任意一个玩家使用冰冻后，其他玩家不允许使用，因此会加入到skill中。

do_use_skill/3是处理技能效果的正在逻辑，这里是处理冰冻效果技能。









关于State中的skill字段说明：

该字段应该是存储对整个房间（动物园）有效果的技能列表，已知冰冻会存储进来。skill列表中的元素类型是原子。



关于玩家信息（animal_role）的skill_id字段说明：

该字段应该是存储动物园玩家使用的技能列表，已知狂暴、锁定、自动会存储进来，skill_id字段存储的元素是role_skill record，结构如下：

```erlang
-record(role_skill, {
	var = 0,
	type = 0,		%% 技能类型
	end_time = 0,	%% 结束时间
	effect = 0		%% 狂暴倍数
}).
```















## animal进程方法

### 房间类型

```erlang
get_min_coin(civilian, _) -> 5;
get_min_coin(petty, _) -> 100;
get_min_coin(rich, _) -> 1000;
get_min_coin(gold, _) -> 10000;
get_min_coin(diamond, _) -> 20000;
get_min_coin(ticket, _) -> 1000;
get_min_coin(single, TaskId) ->
    case TaskId =< 5 of
        true -> 5;
        _ -> 1000
    end.
```



### 打动物

```erlang

%% 打动物
hit(Role = #role{role_id = RoleId, status = ?status_zone, room_pid = Pid, room_type = Type, use_coin = CoinLev, skill_list = SkillList, luck_num = LuckNum, animal_flag = Flag, guide_task = #guide_task{id = TaskId}}, Id, Coin) when is_pid(Pid)->
    %% 根据房间类型获取房间的最小炮值
    Min = get_min_coin(Type, TaskId),
    
    %% 获取玩家的最大炮值
    {Max, _, _} = zoo_room_power_setting:get_data(CoinLev),
    
    %% 技能列表里面有rage类型的技能，就需要消耗的金币？
    NewCoin = case lists:keyfind(rage, #role_skill.type, SkillList) of
        #role_skill{effect = Effect} ->
            trunc(Coin/Effect);
        _ ->
            Coin
    end,
    
    %% 消耗金币值要在Min（房间最小炮值）和Max（玩家的最大炮值）之间
    case NewCoin >= Min andalso NewCoin =< Max of
        true ->
            role_lib:send_buff_begin(),
            case role_lib:do_cost_coin(Role, Coin) of
                {ok, NewRole} ->
                    %% 向房间进程发送一条hit消息
                    case catch gen_server:call(Pid, {hit, RoleId, Id, Coin, LuckNum, Flag}) of
                        %% 打死动物的处理
                        {ok, HitList, List, NewLuck} ->
                            %% 为玩家新增资产
                            {ok, NewRole1} = role_lib:do_add(NewRole, List),
                            
                            %% 增加彩金，这部分在捕牛这边是注释掉了
                            %% NewRole2 = do_bonus(HitList, NewRole1, 0),
                            %% 发送缓冲区的消息
                            role_lib:send_buff_flush(),
                            
                            %% Flag=99是羊毛党的处理，否则更新pw值
                            case Flag of
                                99 -> ok;
                                _ ->
                                    animal_account_mgr:update_animal_pw(Coin, List)
                            end,
                            %% 由任务进程处理动物死亡事件
                            NewRole3 = task:handle(NewRole2, animal_die, Type, HitList),
                            %% 每日击杀任务的处理?
                            NewRole4 = do_daily_kill(NewRole3, List),
                            
                            NewRole5 = task:do_pet_task(NewRole4,4, HitList ),

                            %% 返回新的Role record
                            {ok, NewRole5#role{luck_num = NewLuck}};
                        %% 没有打死动物的处理
                        ok ->
                            role_lib:send_buff_flush(),
                            case Flag of
                                99 -> ok;
                                _ ->
                                    %% 更新动物园pw值
                                    animal_account_mgr:update_animal_pw(Coin, 0)
                            end,
                            {ok, NewRole};
                        %% 操作失败，返回错误
                        {false, Reason} -> 
                            role_lib:send_buff_clean(),
                            {false, Reason};
                        %% 未知错误
                        _ -> 
                            role_lib:send_buff_clean(),
                            {false, ?error_busy}
                    end;
                _ ->
                    role_lib:send_buff_clean(),
                    {false, ?error_coin}
            end;
        _ ->
            {false, ?error_act}
    end;
hit(_, _, _) ->
    {false, ?error_act}.
```

点击一次动物时，便向房间进程发送一条hit消息，根据击中结果来进行处理。



整理下打击一次动物的逻辑：

1. 判断炮值是否正常
2. 扣除玩家金币
3. 向房间进程发送一条hit消息。
4. 根据hit消息结果，如果打中动物，那么增加玩家资产，处理玩家任务结果，最后更新玩家进程状态；如果没有打中则计算pw值，更新玩家进程状态。

hit消息的处理逻辑如下：

1. 寻找房间中的玩家

2. 寻找房间进程中玩家击中的动物

3. 推送玩家点击动物信息

4. 执行点击处理，这里的逻辑比较复杂。有些动物需要特殊处理，我们用普通动物举例。

   首先根据动物的倍率计算概率，判断是否打中。

   如果打中动物，会将动物从进程的动物列表中删除，接着计算掉落的物品。当处理完毕后，会返回死亡的动物，掉落的物品，房间进程中剩余的动物，最后更新房间进程的状态；

   如果没打中动物，不做特殊处理，只更新进程状态。

   







### 使用技能

```erlang
%% 使用技能
use_item(Role = #role{role_id = RoleId, status = ?status_zone, room_pid = Pid, skill_list = List}, Item) when is_pid(Pid)->
    %% 在技能列表中查找玩家使用的技能，如果不存在才允许往下执行。
    case lists:keyfind(Item, #role_skill.type, List) of
        false ->
            case is_process_alive(Pid) of
                true ->
                    role_lib:send_buff_begin(),
                    %% 检查道具数量，并扣除道具
                    case check_item_num(Role, Item) of
                        {ok, NewRole} ->
                            %% 向房间进程发送use_item消息
                            case catch gen_server:call(Pid, {use_item, RoleId, Item}) of
                                ok ->
                                    role_lib:send_buff_flush(),
                                    %% 使用技能后，相关任务需要处理下。
                                    NewRole1 = task:handle(NewRole, use_skill, 0, Item),
                                    %% 更新玩家进程的State
                                    {ok, NewRole1};
                                {ok, Skill} ->
                                    %% 看看返回的Skill有什么作用。
                                    role_lib:send_buff_flush(),
                                    Now = date:unixtime(),
                                    do_skill(Skill, Now),
                                    NewRole1 = task:handle(NewRole, use_skill, 0, Item),
                                    {ok, NewRole1#role{skill_list = [Skill | List]}};
                                {false, Reason} ->
                                    role_lib:send_buff_clean(),
                                    {false, Reason};
                                _ ->
                                    role_lib:send_buff_clean(),
                                    {false, ?error_busy}
                            end;
                        {false, Reason} ->
                            role_lib:send_buff_clean(),
                            {false, Reason}
                    end;
                _ ->
                    {false, ?error_act}
            end;
        _ ->
            {false, ?error_act}
    end;
use_item(_, _) ->
    {false, ?error_act}.
```

- Item：道具类型。

这时使用技能的主体逻辑，在扣除玩家进程的道具后，向所在的房间进程发送一条使用道具消息，由该进程来处理使用道具的相关逻辑。

use_item消息返回的某些技能需要特殊处理：狂暴、锁定、自动都需要处理。



```erlang
check_item_num(Role = #role{vip = Vip}, Item = locking) when Vip < 1->
    do_cost_item(Role, Item);
check_item_num(Role = #role{vip = Vip}, Item = ice) when Vip < 2->
    do_cost_item(Role, Item);
check_item_num(Role = #role{vip = Vip}, Item = auto) when Vip < 3->
    do_cost_item(Role, Item);
check_item_num(Role = #role{vip = Vip}, Item = horn) when Vip < 4->
    do_cost_item(Role, Item);
check_item_num(Role = #role{vip = Vip}, Item = rage) when Vip < 5->
    do_cost_item(Role, Item);
check_item_num(Role = #role{vip = Vip}, Item = gold_pick) when Vip < 6->
    do_cost_item(Role, Item);
check_item_num(Role = #role{vip = Vip}, Item = self_horn) when Vip < 7->
    do_cost_item(Role, Item);
%% 当使用的不是上述的道具且不满足VIP条件时，程序执行这里的代码。
check_item_num(Role, Item) ->
    %% 获取该类型道具的默认值，如果>=3则扣除该道具，否则新增该道具。
    N = role_lib:get_value(Role, Item),
    case N >= 3 of
        true -> 
            do_cost_item(Role, Item);
        _ ->
            NewRole = role_lib:add_value(Role, Item),
            {ok, NewRole}
    end.
```

check_item_num/2，根据玩家的VIP等级，检查玩家可使用的道具。



```erlang
do_cost_item(Role, Item) ->
    case role_lib:do_cost(Role, [{Item, 1}]) of
        %% 道具扣减公告的情况
        {ok, NewRole} ->
            {ok, NewRole};
        %% 没有道具，则根据道具的价格去扣除金币
        _ ->
            Gold = get_item_gold(Item),
            role_lib:do_cost_coin(Role, Gold * 1000)
    end.
```

扣除道具。



```erlang
%% 获取道具价格
get_item_gold(ice) -> 2;
get_item_gold(horn) -> 10;
get_item_gold(self_horn) -> 88;
get_item_gold(gold_pick) -> 99;
get_item_gold(rage) -> 20;
get_item_gold(trumpet) -> 20;
get_item_gold(locking) -> 2;
get_item_gold(auto) -> 50.
```

获取道具的价格，单位未知？





```erlang
%% 批量扣除资产
do_cost(Role, []) -> {ok, Role};
do_cost(Role, List) -> 
    do_cost(Role, List, []).
```

资产的扣除是调用role_lib.erl模块的do_cost/2函数。do_cost/2主要是通过do_cost/3递归的去扣除资产。

- List：要扣除的资产列表，每个元素都是{Type, Num}的元组，Type是物品类型，Num是待扣除数量。



```erlang
do_cost(Role, [], []) -> {ok, Role};、
do_cost(Role, [], List) -> 
    sys_conn:pack_send(1101, #m_1101_toc{list = [#p_assets{type = Type, num = Value}||{Type, Value} <-List]}),
    {ok, Role};

%% 
do_cost(Role = #role{item = Item = #role_item{ice = OldValue}}, [{ice, Value} | L], List) when OldValue >= Value -> 
    do_cost(Role#role{item = Item#role_item{ice = OldValue - Value}}, L, [{ice, OldValue - Value} | List]);
```

参数2是待扣除的资产列表。

参数3是已经扣除的资产列表，每个元素也是{Type, Num}的元组，不同的是Num是扣除的数量。参数3是要通知客户端扣除的资产列表。

role_lib的do_cost/3主要是扣除玩家背包中的道具。





这里需要针对玩家物品字段做下说明：

```erlang
-record(role, {
	...,
	item = #role_item{},	%% 玩家物品，该结构如下。
	daily_value = [],		%% 每日数据，每个元素都是{Type, Val}的元组
}).
```

- daily_value

  玩家的每日默认数据，比如每日提现次数。



```erlang
%% 物品结构版本号
-define(role_item_var, 0).

-record(role_item, {
        var = ?role_item_var
        ,ice = 0          %% 冰冻
        ,horn = 0         %% 号角
        ,rage = 0         %% 狂暴
        ,trumpet = 0      %% 喇叭
        ,locking = 0      %% 锁定
        ,auto = 0         %% 自动
        ,lollipop = 0     %% 棒棒糖
        ,tel_fare = 0     %% 话费
        ,red_bag = 0      %% 红包
    }
).
```







## 相关结构体



### animal_room

```erlang
-record(animal_room, {
    id = 0,
    type = 0,
    num = 0,
    pid			%% 房间进程id
}).
```

房间信息。存储人数和房间进程pid，由房间管理进程使用。

- pid：房间进程id
- num：



### animal_role

```erlang
-record(animal_role, {
    role_id = 0,
    name = "",
	icon = "",
	vip = 0,
    pid,		%% 房间进程pid
    socket_pid,	%% 连接进程pid
    skill_id = [],
    effect = 1,		%% 狂暴倍数
    vip_effect = 0	%% vip特效
}).
```

房间的玩家信息。

- skill_id

  玩家已使用的技能列表，元素是技能类型。





### animal_base

动物基本信息

```erlang
-record(animal_base, {
    id = 0,		%% 唯一id
    base_id = 0,	%% 基础id，其实就是动物类型
    name,		%% 动物名字

    rate = 0,	%% 倍率
    pre = 0,	%% 出现概率

    end_time = 0,	%% 剩余总步数
    post = 0,		%% 当前位置
    xy = {0, 0},		%% 当前坐标

    is_notice = 0,		%% 0不广播，1广播
    status = 0,			%% 0正常，1冰冻
    drop_item = [],		%% 掉落列表
    item_list = [],		%% 可以掉落的列表
    red_bag = 0,		%% 是否有红包
    bomber_type = 0,	%% 同类型炸弹类型

    self_id = 0,		%% 私有大象人物id
    self_name = 0,		%% 私有大象人物名字
})
```



### 相关配置

```erlang
get_animal_base() ->
    [
        #animal_base{base_id = turtle,   name = "蝙蝠", rate = [8, 15],        pre = 2000}
        ,#animal_base{base_id = cock,    name = "鬼火", rate = [12, 12],       pre = 1500}
        ,#animal_base{base_id = dog,     name = "南瓜妖", rate = [20, 20],       pre = 1500}
        ,#animal_base{base_id = monkey,  name = "幽灵", rate = [40, 40],       pre = 1500}
        ,#animal_base{base_id = horse,   name = "巫婆", rate = [60, 60],         pre = 1500}
        ,#animal_base{base_id = ox,      name = "怪人", rate = [100, 100],     pre = 1000}
        ,#animal_base{base_id = panda,   name = "木乃伊", rate = [200, 200],     pre = 800, item_list = [{ice, 1, 500}, {locking, 1, 500}, {gold, 2, 200}]}
        ,#animal_base{base_id = area_bomber,   name = "局部炸弹", rate = [300, 300], pre = 800, item_list = [{ice, 1, 500}, {locking, 1, 500}, {gold, 2, 200}]}
        ,#animal_base{base_id = xsx,   name = "四兄弟", rate = [400, 400],     pre = 800, item_list = [{ice, 1, 500}, {locking, 1, 500}, {gold, 2, 200}], bonus = 1}
        ,#animal_base{base_id = dsy,   name = "三胞胎", rate = [600, 600],     pre = 800, item_list = [{ice, 1, 500}, {locking, 1, 500}, {gold, 2, 200}], bonus = 1}
        ,#animal_base{base_id  = hippo,  name = "狼人", rate = [1000, 1000],   pre = 500, is_notice = 1, item_list = [{ice, 1, 500}, {locking, 1, 500}, {gold, 2, 200}], bonus = 1}
        ,#animal_base{base_id = lion,    name = "吸血鬼", rate = [2000, 2000],   pre = 300, is_notice = 1, item_list = [{ice, 1, 500}, {locking, 1, 500}, {gold, 2, 200}], bonus = 1}
        ,#animal_base{base_id = elephant,name = "舞王", rate = [10000, 10000], pre = 100, is_notice = 1, item_list = [{ice, 1, 500}, {locking, 1, 500}, {gold, 2, 200}]}
        ,#animal_base{base_id = self_elephant,name = "粉色舞王", rate = [10000, 10000], pre = 0, is_notice = 1, item_list = [{ice, 1, 500}, {locking, 1, 500}, {gold, 2, 200}]}
        ,#animal_base{base_id = gold_pick,name = "赏金鼠", rate = [10000, 10000], pre = 0, is_notice = 1, item_list = [{ice, 1, 500}, {locking, 1, 500}, {gold, 2, 200}]}
        ,#animal_base{base_id = pikachu, name = "雷僵尸", rate = [500, 500],     pre = 500, is_notice = 1, item_list = [{ice, 1, 500}, {locking, 1, 500}, {gold, 2, 200}], bonus = 1}
        ,#animal_base{base_id = bomber,  name = "炸弹人", rate = [0, 0],         pre = 200}
        ,#animal_base{base_id = type_bomber,  name = "同类型炸弹人", rate = [0, 0], bomber_type = [cock, dog, monkey, horse, ox, panda], pre = 800}
    ].
```







## Problems

了解房间进程是如何初始化的？

1. init_animal()函数中List1、List一个用于推送，一个是普通的，都存储了普通动物，为什么要用变量来存储呢？
2. 为什么预警动物要晚点加载：add_animal消息怎么处理的？
3. 动物是怎么推送的？
4. 同类型炸弹有什么特殊处理。

这些是查看动物初始化留下来的问题。

目前知道房间进程初始化后会产生动物，进程的State会发生变化。



了解打动物的过程？

先看看普通动物、局部炸弹是怎么爆的。



动物路线怎么处理？

动物消失后发生什么？

检测动物越界？











