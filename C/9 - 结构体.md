## 结构

结构是一种复合类型，它由不同的成员组成，每个成员可以有自己的名字和类型。



### 声明与初始化

```c
struct {
    element1,
    element2,
    ...
} var1, var2, ...;
```

结构通过struct关键字来进行声明，大括号中是各个成员，大括号后面跟着结构变量，表示该变量是结构类型。



```c
struct {
    element1,
    element2,
    ...
} var1 = {...},
  var2 = {...}；
```

结构变量的初始化原则类似于数组初始化的原则，在初始化中结构成员与初始化的值是相对应的。



### 结构的操作

访问一个结构变量的成员可以通过 . 运算符。比如：

```c
struct {
    char name[100];
    int age;
} var1, var2, var3;

var1 = {"zhangsan", 20};
printf("%s %d\n", var1.name, var1.age);
```



结构是支持赋值操作的，赋值操作会把结构中每个成员的值都赋值给指定的对象。

```c
var2 = var1;
```

var2结构中的所有成员都会被var1结构赋值。

由于结构之间可以进行赋值，并且赋值拷贝的是所有成员的副本，因此结构变量作为函数参数或返回值时，也是拷贝所有成员的副本，这对于内存资源是很浪费的。

在作为函数参数或返回值时，一般都是传递或返回结构变量的指针，以节省内存资源。



### 结构类型

声明结构变量的方式不是一种良好的实践，因为无法确定程序需要声明多少个结构变量。因此需要定义结构类型的名字，C语言提供了俩种定义结构类型的方法。



结构标记的声明：结构标记是用于标识某种特定结构的名字，比如定义一个part结构标记。

```c
struct part {
    int number;
    char name[NAME_LEN];
    int on_hand;
};

struct part part1, part2;
```

注意part是一种结构标记，不是类型名，因此必须配合struct关键字来使用。



结构类型的定义：使用typedef关键字可以定义真实的类型名。比如定义一个Part结构类型：

```c
typedef struct {
    int number;
    char name[NAME_LEN];
} Part;

Part part1, part2;
```

由于Part是一种类型，因此使用时不需要struct关键字。







### 箭头操作符

该操作符用于简化访问结构指针变量的成员。

```c
struct Part {
    char name[30];
    int age;
};

int age = 0;

struct Part part1 = {"wangwu", 100}, *part2;
part2 = &part1;

age = (*part2).age;
//间接寻址part2结构，然后使用点操作符来访问成员变量

age = part2->age;
//简化访问操作
```

箭头操作符的左操作数必须是一个指向结构的指针，它会对左操作数执行间接访问取得指针指向的结构体，然后再想点操作符一样通过右操作数去访问结构的成员。

注：间接访问操作是内建与箭头操作符中的。



### 自引用

结构体的自引用指成员变量的类型是该结构体本身，比如声明一个Node结构标记：

```c
struct Node {
    int a;
    int b;
    struct Node *n;
};
```

声明的自引用结构体成员变量必须是一个指针，这是因为编译器能够确定指针的长度，所以能够通过编译。如果成员变量是结构体本身，将会造成死循环声明。



### 不完整声明

不完整声明主要用于解决俩个结构体相互依赖，例如A结构的成员是B结构体，而B结构体的成员是A结构体。

```c
struct A;

struct B {
    struct A *a1;
};

struct A {
    struct B b1;
};
```

在B的成员列表里需要结构A的不完整声明，并且是一个指针。而在A的结构体中，声明结构体B并不需要是指针类型。



### 存储分配

编译器在为结构体分配内存空间时，会按照成员列表的顺序分别为每个成员分配内存，只有当某些成员需要满足正确的边界对齐要求时，成员之间才可能出现用于填充的额外内存空间。



内存边界对齐

```c
struct ALIGN {
    char a;
    int b;
    char c;
};
```

假设某个机器的整型长度是4个字节，并且起始存储位置必须能够被4整除。成员a会存储在一个能够被4整除的内存地址，结构的下一个成员是b，它必须跳过3个字节到达合适的边界才能存储，在整型值之后是最后一个字符。



原因：系统禁止编译器在一个结构的起始位置跳过几个字节来满足边界对齐要求，所有结构的起始存储位置必须是结构中边界要求最严格的数据类型所要求的位置。



你可以通过调整成员的位置来节省内存空间，上述的例子可以把成员a与b放在一起，它们将会共用4个字节的内存空间。





## 联合

联合也是由一个或多个成员构成的，而且这些成员具有不同的类型。

但是编译器只会为联合中最大的成员分配足够的内存空间，并且联合的成员都共用该内存空间，这意味着改变某个成员的值等于改变其他成员的值。



### 声明与初始化

union关键字用于声明联合，而初始化一个成员时，值必须是第一个成员的类型。比如：

```c
//不允许把初始化为浮点型或字符串，如果初始化值的类型不匹配就会发生类型转换。
union {
    int a;
    float b;
    char c[4];
}x = {5};
```



example：同一个值的不同输出

```c
union Demo{
    float f;
    int i;
};

int main(int argc, char const *argv[])
{
    union Demo fi = {3.14};

    printf("%d\n", fi.i);
    printf("%x\n", fi.i);
    
    return 0;
}
```



example：脚本语言变量的实现结构。

```c
struct VARIABLE {
    enum {INT, FLOAT, STRING} type;
    union {
        int i;
        float f;
        char *s;
    } value;
};
```

在VARIABLE结构体中使用了联合来存储变量的值，比起在结构体中分别定义不同类型的成员来存储变量，定义联合成员更加节省内存空间。





## 枚举

枚举是由多个常量值组成的类型，声明的枚举变量只允许是枚举类型中的值。

它遵循C语言的作用域规则，如果枚举声明在函数中，那么对于函数外部是不可见的。



### 声明

可以使用俩种方法来命名枚举，通过声明标记的方法：

```c
//定义枚举标记
enum suit {CLASS, DIAMCONDS, HEARTS};

//声明枚举变量
enum suit s1, s2;
```

也可以使用typedef来创建枚举类型：

```c
//定义枚举类型
typedef enum {CLASS, DIAMCONDS, HEARTS} Suit;

// 声明枚举变量
Suit s1, s2;
```



在系统内部，C语言会把枚举常量作为整数来赋值给枚举中的常量。默认第一个枚举常量的值是0，后面的枚举常量将会依次进行递增。当然也可以在声明枚举类型时进行赋值。

```c
enum Unit {Money_Unit = 1, Coin_Unit = 2};
```



example：

```c
typedef enum {Sun, Tun, Mon} DAY;

DAY d1 = Sun;
printf("%d\n", d1);
```



如何在结构体中使用枚举?



