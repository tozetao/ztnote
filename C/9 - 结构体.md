## 结构

C语言提供了俩种聚合数据类型，数组和结构。数组是相同类型值的集合，而结构是不同类型值的集合。

结构是一些值的集合，这些值被称为成员，在结构中成员可以有不同的类型



### 声明

```c
struct tag { mumber-list } variable-list;
```

tag是标签名，可以认为是结构体的名字；member-list是成员列表，成员由类型与变量名组成；variable-list是结构变量列表，即所声明结构的变量名。



- tag的声明方式

  ```c
  struct SIMPLE {
      int a;
      float b;
      char c;
  };
  ```

  这种声明方式将标签与成员列表绑定在一起了，我们可以通过标签来创建变量。

  ```c
  struct SIMPLE x;
  struct SIMPLE y[20], *z;
  //x,y,z都是同一种类型的结构变量
  ```


- typeof的声明方式

  ```c
  typedef struct {
      int a;
      char b;
      float c;
  }Simple;
  ```

  这种声明方式相当于创建了一种新的类型，这是Simple是一种类型而不是个结构标签。

  ```c
  Simple x;
  Simple y[20], *z;
  ```



### 初始化

结构体的初始化与数组一样，在一对大括号中编写初始值的列表。

这些值根据成员列表的顺序进行初始化，如果初始列表的值不够，剩余成员变量将使用默认值进行初始化。

```c
struct INIT_EX {
    int a;
    short b[10];
    Simple c;
} x = {
    100,
    {1,2,3,4,5,6},
    {1, 10.85, 'c'}
};
```



### 成员的访问

结构成员不仅可以是标量类型，也可以是数组或其他结构体类型。

访问结构体成员是通过点操作符，点操作符接受俩个操作数，左操作数是结构体变量名，右操作数是要访问的成员的名字。

注：点操作符与下标操作符的优先级是相同的，因此结合性是从左往右的

```c
typedef struct {
    int i;
    float f;
}Simple;

typedef struct {
    float f;
    int i;
    Simple sa[10];
    Simple *sp;
}Complex;

Complex comp;

//直接访问
comp.i;

//访问结构体数组类型的成员变量
comp.sa[4].f;
```



箭头操作符

箭头操作符的左操作数必须是一个指向结构的指针，它会对左操作数执行间接访问取得指针指向的结构体，然后再想点操作符一样通过右操作数去访问结构的成员。

注：间接访问操作是内建与箭头操作符中的。

```c
(*comp.sp).i;
//首先对指针执行间接访问操作获得该结构，然后使用点操作符来访问成员变量，由于点操作符的优先级高于间接访问操作符，因此需要加小括号。

//上述的访问很繁琐，因此C提供箭头操作符来访问成员变量
comp->sp->i;
```





### 自引用

结构体的自引用指成员变量的类型是该结构体本身。

```c
struct Node {
    int a;
    int b;
    struct Node *n;
};
```

要注意的是自引用结构体必须是指向结构的指针而不是一个结构体，对于指向结构的指针在编译阶段可以确定该结构指针的长度，如果成员变量是结构体类型将会形成死循环声明，这是错误的。

example：

```c
typedef struct {
    int a;
    SELF_REF *b;
} SELF_REF;
//错误的声明方式，该类型名直到声明的末尾才定义，对于结构体内部是未知的，因此错误。

typedef struct SELF_REF_TAG {
    int a;
    struct SELF_REF_TAG *b;
} SELF_REF;
//正确的声明方式
```



### 不完整声明

不完整声明主要用于解决俩个结构体相互依赖，例如A结构的成员是B结构体，而B结构体的成员是A结构体。

```c
struct A;

struct B {
    struct A *parent;
};

struct A {
    struct B *parent;
};
```

在B的成员列表里需要标签A的不完整声明，B在声明之后，就可以在A的成员列表里声明。



### 结构与指针

指向结构的指针作为左值和右值的情况：

```c
typedef struct {
    int a;
    short b[2];
}Child;

typedef struct  Ex{
    int a;
    char b[3];
    Child c;
    struct Ex *p;
}Ex;

Ex ex = {
    100,
    "Hi",
    {1, {-1, 35}},
    0
};
Ex *px = &ex;

px;
//px是一个指针变量，作为右值时值是px的内容，作为左值时表示px的旧值会被新的值代替

*px;
//作为右值时，*px表示整个结构体，等价于变量ex；
//作为左值时，表示该结构会接收一个新值，更准确的说是所有成员会接收新的值，作为左值重要的是内存地址。

px->b;
//成员b是一个数组，作为右值是指针常量，作为左值是非法的。

px->c;
//c成员是结构类型，作为右值时表示整个结构体，作为左值时表示接受一个新的结构体的赋值


px->d;
//d成员是一个指向结构的指针，作为右值是该指针的内容，作为左值表示指向一个新的地址

*px->d;
//作为右值是指针所指向的结构体，作为左值是接收一个新的结构体

//example:
(*px).a;
//输出100

*(*px).b;
//输出H

*px->b;
//输出H

px->c.b[0];
//输出-1

(*px->d).a;
px->d->a;
```



example

```c
Child c1 = {
    100,
    "ab"
};

Child c2 = {
    200,
    "cd"
};

c1 = c2;
//允许的赋值方式

Child *pc = &c1;
//right

*pc = c1;
//right

c1 = {20, 'de'};
//错误的赋值方式
```



### 存储分配

编译器在为结构体分配内存空间时，会按照成员列表的顺序分别为每个成员分配内存，只有当某些成员需要满足正确的边界对齐要求时，成员之间才可能出现用于填充的额外内存空间。



内存边界对齐

```c
struct ALIGN {
    char a;
    int b;
    char c;
};
```

假设某个机器的整型长度是4个字节，并且起始存储位置必须能够被4整除。成员a会存储在一个能够被4整除的内存地址，结构的下一个成员是b，它必须跳过3个字节到达合适的边界才能存储，在整型值之后是最后一个字符。



原因：系统禁止编译器在一个结构的起始位置跳过几个字节来满足边界对齐要求，所有结构的起始存储位置必须是结构中边界要求最严格的数据类型所要求的位置。



你可以通过调整成员的位置来节省内存空间，上述的例子可以把成员a与b放在一起，它们将会共用4个字节的内存空间。



### 函数参数

结构是一个标量，它可以作为函数参数来进行传递。

```c
typedef struct {
    char *product;
    float amount;
    float price;
}Transaction;

void print_receipt(Transaction trans)
{
    printf("%s\n", trans.product);
    printf("%f\n", trans.price);
}
```

把结构作为参数传值效率是不高的，因为参数传值会把整个结构拷贝一份传递给参数，一般一个结构占用的内存空间是比较大的。相反使用结构指针效率会高很多，只需要指针变量占用的空间大小就可以访问到整个结构体了。

在使用指针访问结构时如果不希望对外部的结构体进行更改，可以使用const关键字。

```c
void printf_rectipt(Transaction const *tran) {
    printf("%s\n", tran->product);
}
```



位段，bit field，位段与结构类似，但是成员是一个或多个位的字段，这些不同长度的字段存储在一个或多个整型变量中。该特性的实现有依赖，暂时不看。





## 联合

联合的声明与结构类似，但是行为不同。联合的所有成员引用的内存中的相同位置，如果要在不同时刻把不同的东西存储在同一个位置时，就可以使用联合。

- 成员的类型决定数据是如何存储到内存中以及内存中的数据是如何解释的。



### 初始化

联合初始化的值必须是第一个成员的类型，例如：

```c
union {
    int a;
    float b;
    char c[4];
}x = {5};

//不允许把初始化为浮点型或字符串，如果初始化值的类型不匹配就会发生类型转换。
```



```c
union Demo{
    float f;
    int i;
};

int main(int argc, char const *argv[])
{
    union Demo fi = {3.14};

    printf("%d\n", fi.i);
    printf("%x\n", fi.i);
    
    return 0;
}
```





### 联合与结构

联合的成员也可以是结构，在一个成员长度不同的联合中，分配给联合的内存数量取决于内存最长的成员。

如果不同成员的内存占用长度相差多大，当存储内存较短的成员会造成内存空间浪费，因此建议使用指针，指针的长度都是相同的，而当决定使用哪个成员时就需要分配正确数量的内存来存储它。



### example

需求：BASIC解释器的功能之一是记住变量的值，变量假设有三种类型，那么该功能的结构设计如下：

```c
struct VARIABLE {
    enum {INT, FLOAT, STRING} type;
    int int_value;
    float float_value;
    char *string_value;
};
```

该结构的低效在于，变量只能是某一种类型，因此使用该结构时只会使用到其中一个成员，另外俩个成员未使用造成空间浪费。使用union可以很好的解决这个问题：

```c
struct VARIABLE {
    enum {INT, FLOAT, STRING} type;
    union {
        int i;
        float f;
        char *s;
    } value;
};
```



