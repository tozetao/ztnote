任何语言大体可以分为4块：数据成分、运算成分、控制成分、输入输出成分。
 

内存：
将内存想象成一系列块的集合，每一块都是一个存储单元，它有8位bit大小，也就是一个byte字节大小。
每一块存储单元都有一个对应的地址，一般是用内存地址来表现。


### 变量的定义
在C语言中变量必须是先定义，然后才能使用的。

当你在程序中定义了一个变量，计算机会在内存中找到几个连续的存储单元，将这片存储空间定义成变量名，将值放到存储空间，并且记下变量名与这片连续的存储单元的起始地址，将它们的对应关系记录下来。

## 整数
### 整型的分类
整数就是整型，在C语言中，整型能够分为：
- int
- short
- long

int型变量会在内存中占用4个字节，short型变量会占用2个字节，long型至少会占用32位类型，这3种类型因为占用的字节长度不同，所以能表达的数值大小也不同。

其实C语言标准并没有明确定义每种整数类型占用的字节长度，它的标准是int型长度不能短于short型，long型不能短于int型，所以在不同编译器下它们的长度可能会不同，如果要知道某种数据类型的长度，可以使用sizeof运算符来计算。

又因为正负数的关系，整型能分为有符号型和无符号型，例如：
- signed short
- unsigned short
- signed int
- unsigned int
- signed long
- unsigned long

unsigned是无符号的意思，表示不能使用负数，一个无符号的数据类型长度是从0开始起算的。
在C语言中，定义变量时默认是有符号型的，所以在程序中定义变量不需要写signed。

### 整型的存储方式
根据符号位的不同，整型在内存中的存储方式是不同的，有符号型的整型会用最高位来表示正负，0表示正数，1表示负数，无符号性则没有符号位。

例如：
```c
unsigned int i = 123;
// 假设该int型占32位，在内存中大体表现如下
// 0000 0000 0000 0000 0000 0000 0111 1011

int i = -123;
// 有符号int型也占32位，在内存中表现如下
// 1111 1111 1111 1111 1111 1111 1000 0101   
```
对于有符号位的整数，正整数与负整数的二进制方式在内存中表示是不同的，对于一个正整数23存储的是它的原码，对于一个负整数存储的是它的补码。

原码和补码之间有对应关系，正123的原码 取反+1 等于负123的补码，-123的补码 取反+1 等于 正123的原码

求一个负整数的补码：
- 先确定符号位为1
- 求出绝对值的原码
- 对原码每一位取反
- 在原码取反的基础上加1，就能得到该负数的补码了

### 整数的范围
```c
int main(){
	signed int a = 0x7FFFFFFFF;
	a = a + 1;
	cout << dec << a << endl;
	return 0;
}
```
0x7FFFFFFFF表示成2进制是0111 1111 1111 1111 1111 1111 1111 1111，
当它加1时则变成1000 0000 0000 0000 0000 0000 0000 0000；

最高位是1，直观的看该数字是一个负数，后面都是0所以是-0，但是0是没有正负区分的，所以C语言规定，当最高位是1其他位是0时，最高位既表示符号位也是数字为，所以0x7FFFFFFF+1 = -2^32，这也是无符号32位int型的最小表示。

### 整数的输入输出
将一个整数转换成8进制或16进制，可以很方便看出该整数的二进制表现，例如：0x7ff1等于0111 1111 1111 0001

原因：
- 2进制转8进制是每3位每3位的转换，同时2进制的0111对应8进制的7，0110对应8进制的6；
- 2进制转16进制是每4位4位的转换，1111对应F，1000对应8

整数的书写形式，0开头的数值是8进制形式，0x开头的数值时16进制形式。

## 浮点型
浮点型是小数类型，又被称为实数xing型。
浮点型可以分为：
- float：单精度浮点型，占4个字节，32位，7位有效数
- double：双进度浮点型，占8个字节，64位，15位有效数
- long double：长双进度浮点型，64位，15位有效数

### 浮点型的精度
```c
#include <iostream>
#include <iomainop>
using namespace std;

float a = 3.123456789987456;
double b = 3.123456789987456;

cout << a << endl;	//3.12345
cout << b << endl;	//3.12345
//cout默认输出6位精度，精度是包含整数位的

cout << setprecision(100) << a << endl;		//
cout << b << endl;			//
//将打印精度设置为100，输出：
return 0;

```
有效数位指的是整数与小数的位数，上述的例子就能看出因为类型不同，保存的有效位也不同，
这里要知道超出有效位后浮点型是不能正确保存小数点额。

### 浮点型的存储
使用float类型举例来说，float是用32位来存储的。

- 最高位是符号位，表示数值的正负；
- 后8位是指数位，含一位符号位；
- 后的23位是小数位，它是一个二进制小数位，默认为1.xxxxx。

假设数值-314.12，将其表示成科学计数法是-3.1412 * 10^2，最高位是正负号，后8位表示10^2，后23位表示3.1212(转二进制小数存储)。


指数位是用8位来表示，除去1位符号位，能够表示的最大数字是2^127次方，由于跟10的N次幂有对应关系，
也即是求以10为底2^127的指数，大约是38。

小数位是用23位来表示，省略到默认的1，它能够表示的数字是2^24(我觉得是2^24-1)，转成10进制的位数即是求log10(2^14)，大约是7.225，
所以能够表示的有效位是7位，最大数是约是10^38次方

```
int main(){
	float a = 0, b = 0;
	a = 123456.789e5;
	b = a + 20;
	
	cout << setprecision(20) << b << endl;
	return 0;
}
```
注：避免将一个很大的数与一个很小的数直接相加或相减，否则就会丢失小的数字。

## 字符型
一个字符型占一个字节；
因为是以一个字节来存储，所以知道一个字符是转换成对应的数字来进行存储；

- 字符型的值可以是"任何在C/C++语言中的字符"
- 最多可用表示2^8个字符个字符(包括0)

注：允许在C/C++出现的字符集指的是ASCII字符集。

使用说明：
- 可以与整型相互赋值
- 可以参数整数运算

转移字符
一些特殊字符，类似换行符、制表符、一般以\开头，例如：\n，\t等等


## 布尔型
布尔型是用于存储"真"和"假"的类型，它占用一个字节，其值只能为1或0，1代表true，0代表false。
在计算机中，字节是计算机程序能控制的最小单位，即使是位运算，也是以字节来运算。

布尔值也能存储其他值，0是表示1，非0则表示false。
```c

bool b1 = true, b2 = false;

cout << b1 << end;
cout << b2 << end;

b1 = 7>3;
b2 = -100;
cout << b1 << end;	//0
cout << b2 << end;	//1
```

### 常量
在程序运行中其值保存不变的值。
- 字面常量：类似-1、0、3.14，写在程序中数的变量
- 符号常量：用一个标识符代表一个常量

```c
const double PI = 3.14159;
# 定义一个符号常量
```

常量也是有类型的，常量的类型是通过后缀来定义的。
整型常量的后缀：
- L：长整型，例如 n = 10000L；m = -0x88abl;
- U：无符号整型常量，例如 k = 1000U
- LU：无符号长整型常量

浮点型后缀：
- F：单进度浮点型
- L：长双进度浮点型

如果没有后缀，则是普通变量，例如 m = 10000L，缺少后缀是整型。

注：浮点型常量默认是double型，U/F/L均可以小写。