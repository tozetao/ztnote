当一个数组声明时，它所需要的内存空间在编译阶段就确定了。



malloc、free，这俩个函数用于执行动态内存的分配与释放。

它们会维护一个可用的内存池，分配内存会调用malloc函数，从内存中获取一块合适的内存，并向程序返回指向这块内存起始地址的指针；当某块之前分配的内存不使用时，需要调用free函数来释放这块内存。



### malloc

```c
void *malloc(size_t size);
```

分配的是一块内存的内存，例如分配100个字节的内存就是100个连续的字节。

如果可用内存池是空的或者可用内存无法满足分配的大小时，malloc函数会向操作系统请求得到更多的内存，并会在这块新内存上执行分配任务。要注意的是分配的内存是未初始化的。

如果操作系统无法提供更多的内存，malloc就会返回一个NULL指针，因此malloc函数的返回结果是需要进行NULL类型检查的。

对于要求边界对齐的机器，malloc所返回的内存的起始位置将满足边界对齐要求最严格的类型的要求。



### free

```c
void free(void *pointer);
```

free的参数可以是NULL，或者是malloc、calloc或relloc返回的值。



### calloc

```c
void *calloc(size_t num_elements, size_t element_size);
```

calloc也是用于分配内存，但是它在返回内存的指针之后会将内存初始化为0。

num_elements表示所需元素的数量，element_size表示每个元素的大小，函数会根据所需元素的数量和每个元素的大小来计算出所需要的内存空间的。



### realloc

```c
void relloc(void *ptr, size_t new_size);
```

realloc用于修改一个已经分配的内存块的大小，如果用于扩大一个内存块，那么原先的内容会先保存，新增加的内存会添加到原先内存块的后面。如果用于缩小一个内存块，超出的内存会被截取掉，剩余的内容会被保留。

如果原先的内存块无法改变大小，realloc将分配另外一块正确大小的内存，并把原来的内容复制到新的内存上。因此使用realloc不能再使用指向旧内存的指针，而是应该使用realloc()函数返回的指针。

如果realloc函数的第一个参数是NULL，那么它的行为和malloc一样。



example：

 ```c
int *pi, i;

pi = malloc(sizeof(int) * 25);
//分配4个int型大小的内存空间

if(pi == NULL) {
    exit(1);
}

for(i=0; i<25; i++){
    *(pi+i) = i;
}

printf("%d\n", pi[10]);
printf("%d\n", *(pi+10));
 ```

NULL符号定义与stdio.h，实际上是字面值常量0，主要用于声明一个空指针，起着提醒的作用。





### 常见错误

对NULL指针进行解引用

在申请一块动态内存时需要判断是否指针是否为NULL，或者定义一个不易发生错误的内存分配器

```c
#include <stdio.h>
#define malloc
#define MALLOC(num, type) (type*)alloc((num) * sizeof(type))
extern void *alloc(size_t size);
```



- 对分配的内存进行越界操作

  这里的越界值访问下标小于0或大于分配的内存地址的间接引用操作，越界操作会引发各种未知异常，这是要避免的操作。



- 释放并非动态分配的内存

  传给free函数一个指针，让它释放一块并非动态分配的内存可能导致程序立即终止或晚点终止；试图释放一块动态内存的一部分也有可能引起类似的问题，例如：

  ```c
  int *pi;
  pi = malloc(10 * sizeof(int));
  free(pi + 5);
  ```

  因此动态分配的内存必须整块一起释放，当然可以使用realloc函数可以缩小一块动态分配的内存，有效的释放它尾部的部分内存。



- 不要访问已经被释放的内存

  假定你对一个指向动态内存的指针进行多次拷贝，如果这多个拷贝的指针散落在程序各处，那么使用时要小心。你必须保证所有使用这块内存的程序在内存释放之后停止对它的使用。





内存泄露

当动态分配的内存不在使用时，它应该被正确释放，这样该内存便可以重复使用。

如果一致分配内存而不进行释放将会引起内存泄露。







### example

使用动态分配内存拷贝一个字符串

```c
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

char *strdup(char const *string)
{
    char *new_string = NULL;
    
    new_string = malloc(strlen(string) + 1);
    
    if(new_string != NULL) {
        strcpy(new_string, string);
    }
    
    return new_string;
}
```



