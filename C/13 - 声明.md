声明具有下列形式：

> 声明说明符 声明符

声明说明符分为三类：

- 存储类型

  存储类型包含4种：auto、static、extern和register。在声明中最多可以出现一种存储类型。如果存储类型存在，则必须放置在声明的最前面。

- 类型限定符

  包含const、volatile

- 类型说明符

  即变量的类型，关键字void、int、short等都是类型说明符。

声明符包括变量名和一些符号，比如数组符号[]、指针符号*，可以用都好分隔声明多个声明符。



```c
int i*, array[], result;
```

在上面的声明中，int属于声明说明符，int后面部分属于声明符。



### 存储类型

C程序中的每个变量都具有以下3个性质。

- 存储期限

  变量的存储期限决定了变量的内存被释放的时间。

  具有自动存储期限的变量在所属块被执行时获得内存单元，并在块终止时释放内存单元，从而会使变量失去值；具有静态存储期限的变量在程序运行期间占有同一个存储单元，也就是允许变量无限期的保留它的值。

- 作用域

  变量的作用域是指可以应用变量的那部分程序文本。变量可以有块作用域和文件作用域。

  块作用域是指变量从声明的地方一直到所在块的末尾都是可见的，而文件作用域是指整个文件内都是可见的。

- 链接

  变量的链接确定了程序的不同部分能够共享此变量的范围。

  具有外部链接的变量可以被程序中的几个或全部文共享；具有内部链接的变量只能独享一个文件；无链接的变量属于单独的函数，而且不能被共享。

变量的默认存储期限、作用域和链接都依赖于声明的位置。

在块（包括函数体）内部声明的变量具有自动存储期限、块作用域，而且无链接。在程序的最外层（任意块外部）声明的变量具有静态存储期限、文件作用域和外部链接。



### auto

auto存储类型只对块的变量有效。auto变量具有自动存储期限、块作用域且无链接。在块的内部声明中，auto是默认的。



### static

static可用于任何位置的变量，作用于块外部声明的变量和块内存声明的变量效果不同。

```c
int x;				//静态存储期限、文件作用域、外部链接
static int i;		//静态存储期限、文件作用域、内部链接

void f(void)
{
    static int j;	//静态存储期限、块作用域、无链接。
}
```

块内声明的变量在程序执行期间会驻留在同一存储单元内，并且程序离开所在块该变量是不会丢失值的。在块内声明的静态变量具有以下属性：

- static变量只在程序执行前初始化依次，而auto变量在每次执行时都会初始化。
- 函数被递归调用时，它会获取一组新的auto变量，但是如果函数含有static变量，那么此函数的所有调用都共享这个statis变量
- 函数不应该返回指向auto变量的指针，但是可以返回指向static变量的指针。



### extern

extern存储类型可以使几个源文件共享同一个变量，但是它会导致编译器不会为该变量分配存储单元，即只进行了声明但是未定义。

```c
extern int i;		//静态存储期限、文件作用域、外部链接

void f(void)
{
    extern int j;	//静态存储期限、内部作用域、内部链接
}
```

extern声明的变量具有静态存储期限，变量的作用域依赖于声明的位置，如果在函数内部声明那么具有内部链接，如果在块外部声明具有外部链接。

注：变量在程序中可以有多次声明，但是只能有一次定义。



### register

register声明的变量会要求编译器把变量存储在寄存器中。寄存器是驻留在计算机CPU的存储单元。

指明变量的存储类型为register是一种请求，而不是命令。编译器也可能选择把register型变量存储在内存中。

```c
int sum()
{
    register int i;
    return 0;
}
```

register只允许在块内声明，它的存储期限、作用域和链接都与auto存储类型相同，只不过变量的值是存储在寄存器中的。

注：由于存储在寄存器中，所有无法取地址。



函数的存储类型

函数可以使用extern和static存储类型。如果函数是extern存储类型声明，将具有外部链接；如果是static存储类型声明，将具有内部链接；如果不指明函数的存储类型，函数会有外部链接。

函数声明为extern存储类型就如同变量声明为auto一样，一般是不在函数声明中使用extern。把函数声明为static的好处是，该函数只在文件内部是可见的，便于维护和减少名字污染。



### const

const声明的变量是不可修改的，但是可以访问。比如：

```c
const int n = 10;
```

const声明的变量不能用于常量表达式中，比如数组长度：

```c
int a[n];	//wrong
```



### volatile





### 解释复杂声明

声明符包含符号*、())和[]。

- 用[]结尾的声明符表示数组。
- 用()结尾的声明符表示函数
- 用*开头的声明符表示指针

无论声明符有多复杂，始终按照以下规则来进行解释：

- 从标识符（变量名）处开始解释。
- 遵循符号的优先级：() 大于 [] 大于 *

example：

```c
int *ap[10];
//一个int型的指针数组。

int (*bp)[10];
//一个指针，指向元素类型是int，长度是10的数组。bp是一个数组指针。

void (*point)(int);
//由于*point包含在括号中，所以point是一个指针，后面跟着(int)，会被解释为一个int函数，它有一个int型参数，返回值为void，因此point是一个指针函数的指针。

int *(*cp[10])(void);
//cp是一个指针数组，指针指向的数据类型是函数(void)，它的返回类型是int型指针。

void (*signal(int signo, void(*func)()))(int);
//singal是一个函数，第一个参数是int型，第二个参数是一个函数指针。signal函数的返回值是一个带有int参数的函数指针
```

对于复杂声明可以使用类型定义来进行简化。

```c
int *(*x[10])(void);

//定义Func函数类型
typedef int *Func(void);

//定义一个指向Func函数的指针类型
typedef Func *FuncPoint;

//定义一个FuncPoint型的数组，数组元素是FuncPoint类型
FuncPoint parray[10];
```
