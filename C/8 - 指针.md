## 指针

把一个变量的起始内存地址保存在另外一个内存单元中，保存地址的这个变量被称为指针。

- &：取址运算符，获取一个变量的内存地址
- *：用于定义指针类型，也可以用于取指针所指向变量的值

```c
int i = 10;
int *pi = &i;

char c = 'A';
//定义一个char型的指针，存储c变量的内存地址
char *pc = &c;

char *pi = *pi + 10;
//取pi
```

全局变量只能用常量表达式来初始化，&是取值运算符，配合变量使用就构成了一个表达式。例如&i，因为可以在编译阶段确定变量的内存地址，所以允许全局初始化



### 指针变量的内容

一个变量的值就是分配给该变量的内存地址所存储的值，即使是指针也不例外。

```c
int a = 10, b = 35;
float f = 3.15;

int *pa = &a;
int *pb = &b;
// pa变量存储的是a变量的起始内存地址
```



### 指针的大小

指针的内存单元都占据4个字节，因为要保存32位的虚拟地址，同理在64位平台占据8个字节。



### 指针的类型

指针的类型决定编译器是如何解引用的，char型的指针，编译器在取值的时候会从指向的内存地址读取一个字节的数据，其他类型的数据同理。

```c
char c = 'a';
int i  = 100;

char *pc = &c;
int *pi = &i;

pi = (int *)pc;
//pi和pc都指向同一个地址，但是pi是int型指针，它会访问4个字节，除非你确定变量c和后面的3个字节组合而成的int是有效的，否则不能这样做
```





### 未初始化指针

如果只是声明了指针，那么该指针指向一个未知的地址。

```c
int *a;
*a = 10;
//a指针虽然是int型，但是并未指向任何地址，因此对*a所指向的内存地址赋值会发生错误。
```

- NULL

  NULL主要用于表示某个指针并未指向任何东西，要使一个指针变量为NULL，可以给它赋值为0。

- NULL的定义

  定义在stddef.h头文件中，即把地址0转换成指针类型，叫做空指针；

  操作系统是不会把数据保存在0地址附近，也不会把0 - 0xffff的页面映射到物理内存，任何对地址0的访问都会直接抛出错误。

  ```c
  define NULL ((void *)0)
  ```

- 在定义指针时建议初始化确定的值或者初始化为NULL



### 左值

指针变量是可以作为左值的。

对指针进行间接访问表示访问指针所指向的位置，由于间接访问指定了一个特定的内存位置，因此可以把间接访问表达式的结果作为左值使用。

```c
int a = 5;
int *d = &a;
*d = 10 - *d;
//右边的间接访问作为右值使用，它的值是d所指向的位置所存储的值，即a的值；
//左边的间接访问作为左值使用，*d是a的内存地址，所以d所指向的地址会把右边表达式的结果作为新的值存储

d = 10 - *d;
//该语句是非法的，它表示把右边表达式计算的整数结果存储到指针变量d中，因为类型不一致所以会发生编译错误。

int c = 20;
d = &c;
//该语句就是正确的

*&a = 25;
//&a计算出a的内存地址，*运算符针访问该内存地址，所以是针对a进行赋值。
```



### 指针的指针

一个指向指针类型的指针被称为指针的指针。

```c
int a = 10;
int *b = &a;
int **c = &b;
//变量c是一个指针，它是一个指针int型指针的指针，简称指针的指针。
//以下是表达式的等价对比
/*
b = &a
*b = a
c  = &b
*c = b, &a
**c = *b, a
*/
```

\*c表达式访问c所指向的位置，即变量b，而\*(\*c)等价于\*b，即访问b所指向的位置，即访问变量a。



### example

```c
char ch = 'a';
char *cp = &ch;

// ch作为右值时是表达式的值，ch作为左值时是该变量的内存地址
// &ch作为右值时是ch变量的内存地址，作为左值时是非法的，当&ch表达式求值时，它的结果是需要存储在内存中的，然后这个表达式并未标识任何机器内存的特定位置，所以非法。

// cp作为左值时是cp所处的内存地址，作为右值时是cp的值
// &cp作为左值时非法，作为右值时表示cp变量的内存地址。
// *cp作为右值时表示访问cp所指向的位置，即变量ch，作为左值时表示cp指向的内存地址会把右边表达式的结果作为它的新值

*cp + 1;
// *cp获取变量ch的值a，加1后该表达式的结果为b
// 作为左值时是非法的，因为存储位置未定义，作为右值时表示b

*(cp + 1);
// cp是一个char型的指针，加1会把cp存储的地址进行相加，因此该表达式会指向ch变量下一个字节的内存地址。
// 该表达式的右值是这个位置的值，左值时内存地址本身。

++cp;
// 前缀++是先增加它的操作数再返回结果，该表达式的右值时增值后的指针的一份拷贝，作为左值时是非法的。

cp++;
// 后缀++是先返回值的一份拷贝，再对值进行自增操作，因此该表达式的右值是cp值的拷贝，作为左值是非法的。

*++cp;
// 间接访问操作符作用于增值后的指针的拷贝上，该表达式的右值是ch后面那个内存地址的那个值，左值是那个内存地址。

*cp++;
// 由于是后缀++，该表达式的右值是cp本身的拷贝，左值是cp指向的内存地址。

++*cp;
// 在该表达式中，操作符的结合性是从右向左的，所以先执行间接访问操作，然后cp的值增加1，表达式的结果是这个增值后的一份拷贝。
// 该表达式作为左值是非法的。
```



```c
++*++cp;
// 从右向左进行计算，++cp表示cp所指向的内存地址加1，*++cp则会取++cp所指向的内存地址的值，最后再进行++表示该内存地址的值加1
// 该表达式作为左值是非法的

++*cp++;
// 从右向左进行计算，cp++是先返回cp操作数再进行自增，*cp++会取cp所指向内存地址的值，最后再对*cp所指向的值进行前缀自增操作。
```



### 指针运算

指针运算支持算出运算和关系运算。



指针的算数运算只支持俩种形式：

- 指针+/-整数

  当一个指针与一个整数进行算数运算时，C会根据指针类型的大小来进行调整，C会把整数值与指针类型的大小相乘后再进行计算。

  例如一个int型指针加1，该指针会后移4个字节大小的地址。

- 指针 - 指针

  只有俩个指针都指向同一个数组中的元素时，才允许一个指针减另外一个指针。俩个指针相减的结果是俩个指针在内存中的距离，该距离是以数组元素的长度为单位，而非字节，因为运算的结果会除以数组元素类型的长度。

  例如p1指向array[i]，p2指向array[j]，p2-p1相当于j-i


注：数组是连续的内存地址，因此后面元素的地址大于前面元素的地址。

指针的关系运算只支持以下运算符：

- 













### void *

一种通用指针类型，该类型的指针可以用于转换成任何类型的指针，并且是隐式转换，

void *指针也是分配4个字节单元的，一般用于函数接口，但是void *是不能直接访问的，必须先转换成其他类型的指针再访问。

```c
void func(void *pc)
{
    char *pchar = pv;
    *pchar = 'A';
}

int main(void)
{
    char c;
    func(&c);
    printf("%c\n", c);
}
```





总结：

每个bit位都由一个地址标识，通常会将临近的多个bit位合并成一组，这样可以表示更大范围的数。而指针就是值是内存地址的变量。





107的案例回头再来看。