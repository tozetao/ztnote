## 指针

把一个变量的起始内存地址保存在另外一个内存单元中，保存地址的这个变量被称为指针。

- &：取址运算符，获取一个变量的内存地址
- *：用于定义指针类型，也可以用于取指针所指向变量的值

```c
int i = 10;
int *pi = &i;

char c = 'A';
//定义一个char型的指针，存储c变量的内存地址
char *pc = &c;

char *pi = *pi + 10;
//取pi
```

全局变量只能用常量表达式来初始化，&是取值运算符，配置变量使用就构成了一个表达式，例如&i，因为可以在编译阶段确定变量的内存地址，所以允许全局初始化



### 指针的大小

指针的内存单元都占据4个字节，因为要保存32位的虚拟地址，同理在64位平台占据8个字节。



### 指针的类型

指针的类型决定编译器是如何取值的，char型的指针，编译器在取值的时候会从指向的内存地址读取一个字节的数据，其他类型的数据同理。

```c
char c = 'a';
int i  = 100;

char *pc = &c;
int *pi = &i;

pi = (int *)pc;
//pi和pc都指向同一个地址，但是pi是int型指针，它会访问4个字节，除非你确定变量c和后面的3个字节组合而成的int是有效的，否则不能这样做
```



### NULL

NULL是空指针的意思，用于解决野指针的问题

- 野指针

  在未初始化时指针变量的初始值是不确定的，这种指针被称为野指针；

  在访问一个野指针是会产生不确定的结果的，所以定义指针时建议初始化确定值或者初始化为NULL

  ​

- NULL的定义

  定义在stddef.h头文件中，即把地址0转换成指针类型，叫做空指针；

  操作系统是不会把数据保存在0地址附近，也不会把0 - 0xffff的页面映射到物理内存，任何对地址0的访问都会直接抛出错误。

  ```c
  define NULL ((void *)0)
  ```





- void *

  一种通用指针类型，该类型的指针可以用于转换成任何类型的指针，并且是隐式转换，

  void *指针也是分配4个字节单元的，一般用于函数接口，但是void *是不能直接访问的，必须先转换成其他类型的指针再访问。

  ```c
  void func(void *pc)
  {
      char *pchar = pv;
      *pchar = 'A';
  }

  int main(void)
  {
      char c;
      func(&c);
      printf("%c\n", c);
  }
  ```

  ​


### 指针与数组

```c
int a[10]；
int *pa = &a[0];
pa++;
pa = pa + 2;
```

后缀运算符[]的优先级高于单目运算符，所以指针pa是指向a[0]的地址，而不是a的地址。



- 指针与++/--

  指针自增的时候是指向下一个元素，因为int是占据4个字节，因此pa++会使pa指向的地址加4。

  除了自增自减指针也能进行加减运算，例如pa指向a[1]，pa + 2就指向a[3]。

- E1[E2] = \*(E1+E2)

  E1是数组名，E2是索引，在C语言中，E1[E2]是等价于 \*(E1+E2)的，所以指针\*(pa+2)等于pa[2]，数组名与指针数组名是没有区别的，pa[2]就相当于a[2]在访问元素，本质上都是通过指针间接寻址\*来访问元素的。



- 数组名与指针名

  指针在做右值得时候会转换成首元素的指针，在做左值的时候是表示整个存储空间，而不是首元素的存储空间。

  example：

  ```c
  int a[10];

  int *pa = a + 1;	//right

  int a = pa + 1;		//error

  pa++;	//right

  a++;	//error
  ```

  example:

  ```c
  function demo(char c[])
  {
      //body
  }
  //char c[]是一个指针，函数原型中数组[]表示的是指针而不表示数组
  //之所以写成c[]这种形式，主要说明该参数是指向数组第一个元素的首地址
  ```





### 指针与const

const与指针结合使用有几种情况：

```c
const int *a;
int const *a;
```

这俩种写法都一样，a是指向一个const int型的指针，a指向的内存单元是不可修改，所以(\*a)++报错，但是a++允许；意思就是a指针所指向的内存地址的值是不可以修改的，但是可以修改指针本身存储的内存地址。



```c
int * const a;
```

定义一个int型的const指针，*a可以被改写，但是a是不允许改写；

指针a存储的内存单元不可以修改，但是可以修改指针a指向的内存单元的值。



```c
int const * int a;
```

a是指向一个const int的const指针，*a和a都不可以被改写；无法修改指针存储的内存地址，也无法修改该指针指向的内存地址的值。



- 类型转换

  非const变量的指针或非const变量的地址可以传递给const变量的指针，编译器会自动转换，

  但是指向const变量的指针或const变量的地址不可以传递给非const变量的指针，避免意外改变const变量指针所指向的内存单元。

  ```c
  char c1 = 'a';
  char const * pc = &c1;

  char *c2 = &c1；
  char const * pc = c2;
  ```

  ​

### 指针与结构体

```c
struct unit {
    char c;
    int num;
};

struct unit u;

//定义一个结构体类型的指针
struct unit *pu = &u;

//访问结构体成员
(*pu).c;
(*pu).num;

//快捷访问
pu->c;
pu->num;
```



### 指向指针的指针

指针可以指向基本类型，也可以指向复合类型，因此指针也可以指向指针类型，称为指向指针的指针。

```c
int i = 100;
int *pi = &i;
int **ppi = &pi;

printf("", *ppi);
//取指针pi的值

printf("%d\n", **ppi);
//相当于取i的值
```



### 指针数组

数组的元素可以是指针类型。

```c
int *a[10];

*a[1];	
//访问第一个指针元素指向的内存单元

int **pa = &a[0];
//指向指针数组中第一个指针元素的内存地址

//a[0]和pa[0]取的都是数组中第一个元素，不同的是该元素是一个指针类型
```



### 指向数组的指针

- 定义一个指向数组的指针

```c
int (*a)[10];
```

[]运算符的优先级是比\*高的，a与[]结合表示一个数组，a与\*结合表示一个指针，这是指针数组与指向数组的指针定义不同的地方。



- 使用

```c
int a[10];
int (*pa)[10] = &a;
```

&a表达式中，数组a做右值使用取的是整个数组的首地址赋值给指针pa，注意&a[0]取得是数组第一个元素的首地址，&a取得是整个数组的首地址，虽然俩个地址是相同的，但是俩个表达式返回的类型是不同的。

&a[0]返回的是一个int \*的指针，&a返回的是一个数组指针int  (\*)[10]，*pa表示的是整个数组a，所以取数组的a[0]元素可以用表达式(\*pa)[0]。

因为e1[e2] = \*(e1+e2)，所以\*pa等价于pa[0]，(\*pa)[0]也等价于pa\[0][0]。



- 指向数组的指针与二维数组

```c
int a[5][10];
int (*pa)[10] = &a[0];
```

int a\[5][10];和int (\*pa)[10]的关系就想int a[10];和int *pa关系一样，a是由int元素组成的数组，pa则是指向这种元素的指针；

当前pa指向的是二维数组中的一个元素（数组），a[0]与pa[0]取的都是同一个元素，只不过这个元素是由10个int型组成的数组。

注：数组名是不支持被赋值，自增等运算，而指针则允许，所以指针pa使用起来就要灵活多了。



example：

```c
int a[5] = {1, 2, 3, 4, 5};
int (*pa)[5] = &a;

printf("%d\n", (*pa)[0]);	//1
printf("%d\n", pa[0][0]);	//1

int b[2][3] = {{1,2,3}, {4,5,6}};
int （*pb)[3] = &b[0];

printf("%d\n", (*pb)[1]);	//2
printf("%d\n", pb[0][1]);	//2

pb++;

printf("%d\n", (*pb)[1]);	//5
```



### 函数指针

函数也是一种类型，可以定义指向函数的指针。指针存储的是一个地址值，而函数指针存储的是一个函数的入口地址。

```c
#include <stdio.h>

void foo(const char *c){
    printf("%s\n", c);
}

int main(void)
{
    void (*f)(const char *c) = foo;
    f("Guue");
    
    (*f)("hello world");
    return 0;
}
```

void (\*f)(const  char *c)，这是一个函数原型的格式。

f与*	结合在一起表示一个指针，const char *c是函数的参数，void返回没有返回值。正式这种格式的函数原型，因此foo函数才能赋值成功。

foo是一种函数类型，在作右值使用时自动转换成函数指针类型，当然也可以显示的使用&foo赋值。



- 函数类型与函数指针类型是不同的。

  ```c
  //定义一个函数类型Foo
  typedef int Foo(void);

  Foo foo_a, foo_b;
  //相当于int foo_a(void); int foo_b(void);

  Foo foo_c(void);
  //错误的，因为foo_c函数返回一个函数类型

  Foo* foo_d(void);
  //正确的，因为返回的是一个函数指针类型，相当于返回函数的内存入口地址
  ```

  ​

