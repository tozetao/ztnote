## 一维数组

数组也是一种复合类型，它是由一系列相同类型的元素组成，数组的存储空间也是相连的。



### 初始化

一般数组初始化有俩种方式：

- 指定长度的数组初始化

  ```c
  int numbers[4] = {1, 2, 3, 4};
  
  //对于未赋值的元素，默认初始化未0
  int months[12] = {1, 2, 3, 4, 5};
  ```

- 由编译器根据初始化列表中的元素自动匹配数组大

  ```c
  int numbers[] = {1, 2, 3};
  ```

数组是通过下标来访问和赋值的，下标是从0开始的；下标允许是表达式，但是表达式的值必须是整型的。

```c
printf("%d", numbers[0]);	//打印下标0的元素
numbers[1] = 10;	//给下标1的元素赋值
```



### 数组名的本质

数组名的值是一个常量指针，它就是指向数组第一个元素的地址，它的类型取决于数组元素的类型。

由于数组名是常量指针，因此是不可修改的，也就不能赋值。

```c
int a[10];
//该表达式是相等的
a == &a[0];
```

当数组名作为sizeof和&操作符的操作数时，它才不用常量指针表示，sizeof会返回该数组的长度，&操作符会返回一个指向数组的指针。



### 下标的本质

下标引用本质上与间接访问是等价的，因此可以通过指针来方式数组元素，也可以通过下标来访问元素。

> array[subscript] = *(array + (subscript))。

example：使用指针来访问数组

```c
int array[10] = {1, 2, 3, 4, 5, 6, 7};
int *pa = array;

pa + 2 == &array[2];
//指向下标2的内存地址

*(pa + 2) == array[2];
//访问下标2的值

int **ppa = &pa;
//指向指针的指针
```

example：俩种不同的遍历方式

```c
int array[] = {1, 2, 3, 4, 5};
int i, length;

length = sizeof(array) / sizeof(array[0]);
for(i = 0; i < length; i++) {
    printf("point: %d; index: %d\n", *(array + i), array[i])
}
```



### 数组与指针的区别

声明一个数组会在内存中根据数组大小开辟一块内存空间，而数组名就是指向这块内存空间的首地址。而声明一个指针，也会在内存中开辟一块指针类型大小的内存空间，但是指针并未初始化，指向的内存地址是未知的。

example：数组名与指针的运算区别

```c
int array[10];
int *p;

*p;
//非法的，指针变量b并未初始化

*array;
//合法的，a指向数组第一个元素的地址

array++;
//非法的，数组名a是一个指针常量，不能被改变;

b++;
//可以通过编译，但是结果未知
```



### 声明数组参数

因为数组名是指向第一个元素的指针，所以需要声明一个与数组元素匹配的指针。比如一个int型数组，C语言允许把int *array和int array[]作为数组参数。

注：只有声明参数时，int array[]才是作为一个数组参数，否则是作为声明一个数组来对待。

example：

```c
#include "stdio.h"

void mstrcopy(char *buffer, char const *string)
{
    while((*buffer = *string++) != '\0'){
        buffer++;
    }
}

int main(int argc, char const *argv[])
{
    char buffer[30];
    char content[] = "this is my demo.";
    mstrcopy(buffer, content);
    printf("%s\n", buffer);
    return 0;
}
```



## 二维数组

包含二个维数的数组为称为二维数组。无论数组有多少唯，它在内存中存储的数据都是从左到右连续存储的。



### 初始化

二维数组的初始化是建立在一维数组上的，因此需要指定二维数组中有多少个一维数组，并指定每个一维数组的大小。对于元素个数少于数组大小的情况，编译器会自动把剩余的元素初始化为0。

```c
// 未明确指定的元素会被初始化为0
int sq[2][3] = {
    {1, 2}，
    {4, 5}
};

// 这种初始化方式，编译器会根据1维数组大小，自动划分元素
int sp[2][2] = {1, 2, 3};
```



### 二维数组名

一维数组名的值是一个指针常量，它的类型是指向元素类型的指针，即指向数组的第一个元素。二维数组名也是指向第一个元素的指针，不同的是该元素是一个数组。

```c
int matrix[3][10];
```

matrix的值是一个指向包含10个整型元素的数组的指针，因此在进行运算时单位是以10个整型元素的数组作为单位，例如：

```c
matrix;
//指向第一个数组元素

matrix + 1;
//指向第二个数组元素

*(matrix + 1);
//该表达式是一个包含10个元素的数组，一维数组名是一个常量指针，因此该表达式也是一个常量指针。

*(matrix + 1) + 5;
//前一个表达式是指向一个int型的指针，加5则表示在当前指针后移5个整型元素

*(*(matrix + 1) + 5);
//作为右值时，可以取得存储地址的值，作为左值时，该位置将存储一个新值
```



与一维数组一样，下标引用其实是间接引用表达式的另外一个形式。

```c
matrix[1];
//指向第2个数组元素，因此是一个int型的常量指针，相当于*(matrix + 1)

matrix[1][5];
//*(*(matrix + 1) + 5)
```

总结：数组名是指向第一个数组元素的指针，所以下标值会根据该元素的长度进行调整。它的结果是一个指向那一维中对应元素的指针；

总结2：使用数组名进行算术运算时，其实就是在做指针运算，并且运算单位是以该数组的元素大小来计算的。



### 指向数组的指针

声明指向数组的指针

```c
int (*name)[length];
```

name是指针的名字，length是数组的长度。

下标引用的优先级高于间接访问符\*，但是因为有小括号会优先执行(\*name)表达式，所以name是一个指针，接下来执行下标引用，所以name是一个指向长度为length的int类型数组。

example：

```c
int vector[10], *vp = vector;
//合法的表达式

int matrix[3][10], *mp = matrix;
//*mp = matrix是非法的表达式，matrix是指向数组的指针，mp是int型指针，类型不匹配。

int (*mp)[10] = matrix;
//正确的赋值

//matrix似乎不等价与*matrix，回去验证下

matrix;
//等价于*matrix，数组名是指向数组第一个元素的指针，对matrix进行间接访问也是指向数组第一个元素的指针
//该元素是一个包含10个元素的数组，作为右值时是一个常量指针。

(*matrix)[1];
//*matrix就是取matrix第一个元素的值，它是一个包含10个元素的数组，也是一个常量指针，下标1表示访问数组的第二个元素。
//该表达式等价于*((*matrix)+1)

matrix[0][9];
//等价于*(*(matrix + 0) + 9)

int *pi = &matrix[0][0];
int *pa = matrix[0];

int (*p)[] = matrix;
//视编译器，该数组指针的大小为0，如果进行指针运算可能会造成错误的结果。
```



### 声明二维数组参数

一维数组指向的是元素类型的指针，函数参数的原型可以是下面俩种：

```c
void func(int *element);
void func(int element[]);
```

而二维数组指向的是数组的指针，函数参数的原型也是数组指针，可以按照如下定义：

```c
void func(int (*element)[length]);
void func(int element[][length]);
```

length是数组长度，编译器需要知道第二个以及各维的长度才能进行求值，因此原型必须声明这些维的长度。







### example

```c
#include <stdio.h>
#include <stdlib.h>

void base_demo() 
{
    int matrix[3][10] = {
        {1, 2, 3},
        {4, 5, 7},
        {11, 12, 13, 14, 15}
    };

    int *m = &(*(*(matrix + 1) + 1));
    int *s = (*(matrix + 1) + 1);

    printf("m = %d\n", *m);
    printf("s = %d\n", *s);
    
    m--;
    s++;

    printf("m = %d\n", *m);
    printf("s = %d\n", *s);
}

// 多维数组名的测试
void array_name_demo()
{
    printf("example2: \n");

    int matrix[3][10] = {
        {1, 2, 3},
        {4, 5, 7},
        {11, 12, 13, 14, 15}
    };

    int (*mp)[10] = matrix;
    // 数组名指向第一个元素的指针，类型取决于元素类型，因此matrix是一个数组指针

    int *sp = *matrix;
    // 对matrix进行间接引用则获取到的第一个元素的值，它是一个数组，因此表达式的值是一个常量指针

    printf("%d\n", *sp);
    printf("%d\n", *(sp+2));

    printf("%d\n", mp[0][2]);   //输出2
    printf("%d\n", *(*mp + 2));

    printf("%d\n", *mp[2]);     //输出11
    printf("%d\n", **(mp + 2));
}
```





## 指针数组

数组元素是指针类型的数组叫做指针数组。

```c
int *api[10];
```

假定这是个表达式，对其求值。

下标引用的优先级高于间接引用，先执行下标引用，因此api[10]表示某种类型的数组；再执行间接访问操作，它的结果是一种整型值，所以api是一个指针类型的数组。

example：

```c
int main(int argc, char const *argv[])
{
    char const *keyword[] = {
        "do",
        "for",
        "if",
        "return",
        NULL
    };

    char const **t = keyword;
    //t等价于keyword，数组名是指向第一个元素的指针常量，而第一个元素又是一个指针，因此是一个指向指针的指针类型。
	
    t;
    //指向第一个元素
    
    t++;
    //指向第二个元素
    
    *t;
    //间接引用第二个指针元素，*t是一个指针常量，指向字符串"for"的首地址，printf()会打印字符串"for"

    *t + 1;
    //等价于"for" + 1
    //该表达式指向在第二个指针元素的地址向后移动一个字节的地址

    *(*t + 1);
    //作为右值时，可以取得该内存地址的值，作为左值会该地址会存储一个新值。

    char const *k = keyword[0];
    //指向第一个指针元素

    return 0;
}
```



指针数组每个指针元素都是指向各个不同的字符串常量，如果是一个矩阵的字符串数组，它每一行的长度是刚好容纳最长的字符串常量(包括NULL字节)。

```c
//矩阵数组
int const keyword[][10] = {
    "do",
    "for",
    "if"
};

//指针数组
int const *keyword[] = {
    "do",
    "for",
    "if"
};
```



example:

```c
#include <stdlib.h>
#include <stdio.h>

void size_demo()
{
    char const *keys[] = {
        "dasheng",
        "xiaoli",
        "name",
        "ab"
    };

    int i, size, length;
    char const **ele = keys;
    
    size = sizeof(keys[0]);     // 指针的大小
    length = sizeof(keys) / size;

    printf("size = %d\n", size);
    printf("length = %d\n", length);

    for(i = 0; i < length; i++) {
        printf("%s\n", keys[i]);
    }
}

void loop()
{
    char const *keys[] = {
        "a",
        "abc",
        "abcd",
        NULL
    };

    char const **val;

    // printf each element.
    for(val = keys; *val != NULL; val++) {
        printf("%s\n", *val);
    }

    // printf the second element
    char const *ele = *(keys + 2);
    char t;
    while((t = *ele++) != '\0') {
        printf("%c\n", t);
    }
}

int main(int argc, char const *argv[])
{
    size_demo();
    return 0;
}
```






