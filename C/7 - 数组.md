## 数组
数组也是一种复合类型，它是由一系列相同类型的元素组成。与结构体类似，数组的存储空间也是相连的。

- 定义数组

  ```c
  int numbers[];
  ```


- 访问数组

  数组是通过下标来访问的，下标是从0开始的；下标允许是表达式，但是表达式的值必须是整型的。

  ```c
  printf("%d", numbers[0]);	//打印第一个元素
  ```

- 初始化

  ```c
  int numbers[4] = {1, 2 ,3 ,4};	//指定数组长度的初始化

  int ages[] = {1,2,3};			//不指定数组长度的初始化

  int numbers[4] = {1,2};			//对于未赋值的元素，默认初始化为0，这点与结构体是一样的
  ```



### 数组赋值

数组类型不允许相互赋值或初始化

```c
int a[5] = {1,2,3};
int b[5] = a;		//error

a = b; 	//error
```



由于不能相互赋值，所以不能用数组类型作为函数的参数或返回值。

```c
void foo(int a[5])
{
    //body
}

int array[5] = {0};
foo(array);
```

上面的代码虽然编译器不会报错，但并不是传递一个数组类型参数的意思。

数组类型被当做右值使用，是自动转换成指向数组首元素的指针，所以上面的代码是传递一个指针类型的参数。这也解释了为什么数组类型不能相互赋值，因为数组被转换成指针类型后，进行赋值的变量仍然是数组类型，这就发生错误了。



### 多维数组

数组是可以嵌套的，一个数组元素包含另外一个数组就构成了多维数组。

定义一个二维数组：

```c
int a[3][2] = {1, 2, 3, 4, 5};

int a[][2]  = {{1,2}, {3, 4}, {5}};
```

从模型上看这是一个3行2列的数组，但是这6个元素在内存中是连续存储的，相当于把多个一维数组串连起来了。

注：第一位的长度可以由编辑器自动计算，但是其他唯必须指定元素长度。



### 字符串

字符串可以看作是一个char类型的数组，每个字符串最后一个字符是"\0"，对应ASCII码为null的字符，代表着该字符串的结束。

- 初始化

  ```c
  char str[] = "hello";	//通过字符串字面值初始化字符数组
  char str[] = {'h', 'e', 'l', 'l', 'o', '\n'};	//没有指定的元素为0，即null字符
  ```

字符串字面值可以像数组一样的使用，例如：

```c
char c =  "hello"[0];
```







- ​

### 指针与数组

```c
int a[10]；
int *pa = &a[0];
pa++;
pa = pa + 2;
```

后缀运算符[]的优先级高于单目运算符，所以指针pa是指向a[0]的地址，而不是a的地址。



- 指针与++/--

  指针自增的时候是指向下一个元素，因为int是占据4个字节，因此pa++会使pa指向的地址加4。

  除了自增自减指针也能进行加减运算，例如pa指向a[1]，pa + 2就指向a[3]。

- E1[E2] = \*(E1+E2)

  E1是数组名，E2是索引，在C语言中，E1[E2]是等价于 \*(E1+E2)的，所以指针\*(pa+2)等于pa[2]，数组名与指针数组名是没有区别的，pa[2]就相当于a[2]在访问元素，本质上都是通过指针间接寻址\*来访问元素的。



- 数组名与指针名

  指针在做右值得时候会转换成首元素的指针，在做左值的时候是表示整个存储空间，而不是首元素的存储空间。

  example：

  ```c
  int a[10];
  
  int *pa = a + 1;	//right
  
  int a = pa + 1;		//error
  
  pa++;	//right
  
  a++;	//error
  ```

  example:

  ```c
  function demo(char c[])
  {
      //body
  }
  //char c[]是一个指针，函数原型中数组[]表示的是指针而不表示数组
  //之所以写成c[]这种形式，主要说明该参数是指向数组第一个元素的首地址
  ```





### 指针与const

const与指针结合使用有几种情况：

```c
const int *a;
int const *a;
```

这俩种写法都一样，a是指向一个const int型的指针，a指向的内存单元是不可修改，所以(\*a)++报错，但是a++允许；意思就是a指针所指向的内存地址的值是不可以修改的，但是可以修改指针本身存储的内存地址。



```c
int * const a;
```

定义一个int型的const指针，*a可以被改写，但是a是不允许改写；

指针a存储的内存单元不可以修改，但是可以修改指针a指向的内存单元的值。



```c
int const * int a;
```

a是指向一个const int的const指针，*a和a都不可以被改写；无法修改指针存储的内存地址，也无法修改该指针指向的内存地址的值。



- 类型转换

  非const变量的指针或非const变量的地址可以传递给const变量的指针，编译器会自动转换，

  但是指向const变量的指针或const变量的地址不可以传递给非const变量的指针，避免意外改变const变量指针所指向的内存单元。

  ```c
  char c1 = 'a';
  char const * pc = &c1;
  
  char *c2 = &c1；
  char const * pc = c2;
  ```

  ​

### 指针与结构体

```c
struct unit {
    char c;
    int num;
};

struct unit u;

//定义一个结构体类型的指针
struct unit *pu = &u;

//访问结构体成员
(*pu).c;
(*pu).num;

//快捷访问
pu->c;
pu->num;
```



### 指向指针的指针

指针可以指向基本类型，也可以指向复合类型，因此指针也可以指向指针类型，称为指向指针的指针。

```c
int i = 100;
int *pi = &i;
int **ppi = &pi;

printf("", *ppi);
//取指针pi的值

printf("%d\n", **ppi);
//相当于取i的值
```



### 指针数组

数组的元素可以是指针类型。

```c
int *a[10];

*a[1];	
//访问第一个指针元素指向的内存单元

int **pa = &a[0];
//指向指针数组中第一个指针元素的内存地址

//a[0]和pa[0]取的都是数组中第一个元素，不同的是该元素是一个指针类型
```



### 指向数组的指针

- 定义一个指向数组的指针

```c
int (*a)[10];
```

[]运算符的优先级是比\*高的，a与[]结合表示一个数组，a与\*结合表示一个指针，这是指针数组与指向数组的指针定义不同的地方。



- 使用

```c
int a[10];
int (*pa)[10] = &a;
```

&a表达式中，数组a做右值使用取的是整个数组的首地址赋值给指针pa，注意&a[0]取得是数组第一个元素的首地址，&a取得是整个数组的首地址，虽然俩个地址是相同的，但是俩个表达式返回的类型是不同的。

&a[0]返回的是一个int \*的指针，&a返回的是一个数组指针int  (\*)[10]，*pa表示的是整个数组a，所以取数组的a[0]元素可以用表达式(\*pa)[0]。

因为e1[e2] = \*(e1+e2)，所以\*pa等价于pa[0]，(\*pa)[0]也等价于pa\[0][0]。



- 指向数组的指针与二维数组

```c
int a[5][10];
int (*pa)[10] = &a[0];
```

int a\[5][10];和int (\*pa)[10]的关系就想int a[10];和int *pa关系一样，a是由int元素组成的数组，pa则是指向这种元素的指针；

当前pa指向的是二维数组中的一个元素（数组），a[0]与pa[0]取的都是同一个元素，只不过这个元素是由10个int型组成的数组。

注：数组名是不支持被赋值，自增等运算，而指针则允许，所以指针pa使用起来就要灵活多了。



example：

```c
int a[5] = {1, 2, 3, 4, 5};
int (*pa)[5] = &a;

printf("%d\n", (*pa)[0]);	//1
printf("%d\n", pa[0][0]);	//1

int b[2][3] = {{1,2,3}, {4,5,6}};
int （*pb)[3] = &b[0];

printf("%d\n", (*pb)[1]);	//2
printf("%d\n", pb[0][1]);	//2

pb++;

printf("%d\n", (*pb)[1]);	//5
```



### 函数指针

函数也是一种类型，可以定义指向函数的指针。指针存储的是一个地址值，而函数指针存储的是一个函数的入口地址。

```c
#include <stdio.h>

void foo(const char *c){
    printf("%s\n", c);
}

int main(void)
{
    void (*f)(const char *c) = foo;
    f("Guue");
    
    (*f)("hello world");
    return 0;
}
```

void (\*f)(const  char *c)，这是一个函数原型的格式。

f与*	结合在一起表示一个指针，const char *c是函数的参数，void返回没有返回值。正是这种格式的函数原型，因此foo函数才能赋值成功。

foo是一种函数类型，在作右值使用时自动转换成函数指针类型，当然也可以显示的使用&foo赋值。



- 函数类型与函数指针类型是不同的。

  ```c
  //定义一个函数类型Foo
  typedef int Foo(void);
  
  Foo foo_a, foo_b;
  //相当于int foo_a(void); int foo_b(void);
  
  Foo foo_c(void);
  //错误的，因为foo_c函数返回一个函数类型
  
  Foo* foo_d(void);
  //正确的，因为返回的是一个函数指针类型，相当于返回函数的内存入口地址
  ```

  ​

