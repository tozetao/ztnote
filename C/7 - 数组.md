## Array

数组也是一种复合类型，它是由一系列相同类型的元素组成。与结构体类似，数组的存储空间也是相连的。

- 定义数组

  ```c
  int numbers[];
  ```


- 访问数组

  数组是通过下标来访问的，下标是从0开始的；下标允许是表达式，但是表达式的值必须是整型的。

  ```c
  printf("%d", numbers[0]);	//打印第一个元素
  ```

- 初始化

  ```c
  int numbers[4] = {1, 2 ,3 ,4};	//指定数组长度的初始化
  
  int ages[] = {1,2,3};			//不指定数组长度的初始化
  
  int numbers[4] = {1,2};			//对于未赋值的元素，默认初始化为0，这点与结构体是一样的
  ```



### 数组名

数组名的值是一个常量指针，也就是数组第一个元素的地址，它的类型取决于数组元素的类型。由于数组名是常量指针，它是不可修改的。

```c
int a[10];
int b[10];
int *c;

c = &a[0];
c = a;
//数组名在表达式中是指向数组第一个元素的指针，因此上述俩个表达式是成立的，在表达式中a是等价于&a[0]。

a = c;
//非法的，数组名会产生一个常量指针，因此是不允许被赋值的。
```

当数组名作为sizeof和&操作符的操作数时，它才不用常量指针表示，sizeof会返回该数组的长度，&操作符会返回一个指向数组的指针。



### 下标引用

下标引用与间接访问是等价的，等价式：array[subscript] = *(array + (subscript))。

example：

```c
int array[10];
int *ap = array + 2;

ap;
//等价array+2, &array[2]

ap[0];
//等价的表达式是*(ap+(0)), 如果ap是指向array[2]的话，等价于上一题

&ap;
//取出指针变量ap的内存地址
//注意不等价于&array[2]，&array[2]是取出索引为2的元素的内存地址

*(ap+6);
//等价于array[8]
```

在正确使用下标与指针时，下标绝对不会比指针效率高，并且有些场景指针的效率高于下标。



### 数组与指针的区别

声明一个数组时，编译器将根据声明所指定的元素数量为数组保留内存空间，然后再创建数组名，它是一个指针常量，指向这片内存空间的起始地址；

而声明指针时，编译器只会为指针变量保留内存空间，而且指针变量并未被初始化为指向任何现有的内存空间。

```c
int a[10];
int *b;

*b;
//非法的，指针变量b并未初始化

*a;
//合法的，a指向数组第一个元素的地址

a++;
//非法的，数组名a是一个指针常量，不能被改变;

b++;
//可以通过编译
```



### 作为函数参数的数组名

数组名是指向数组第一个元素的指针，所以数组名作为函数参数时，传递的是该指针的一份拷贝。函数如果执行了下标引用，实际上是对这个指针执行间接访问操作，通过间接访问函数可以访问和修改该数组元素。

- 要强调的是，参数是通过传值传递的，把数组名作为参数传递也只是传递一份指针的拷贝，但调用程序所传递的实参是不受影响的

```c
#include "stdio.h"

void mstrcopy(char *buffer, char const *string)
{
    while((*buffer = *string++) != '\0'){
        buffer++;
    }
}

int main(int argc, char const *argv[])
{
    char buffer[30];
    char content[] = "this is my demo.";
    mstrcopy(buffer, content);
    printf("%s\n", buffer);
    return 0;
}
```



声明一个数组参数有俩种方式，例如：

- int strlen( char *string ) ;
- int strlen( char string[]);

*string和string[]只在函数声明参数时是等价的，在其他地方不是等价的。







## 多维数组

包含多个维数的数组为称为多维数组。无论数组有多少唯，它在内存中存储的数据都是从左到右连续存储的。例如：

```c
int matrix[3][4];
int *mp;

mp = &matrix[1][3];
//等价于*(*(matrix + 1) + 3)

*mp;
//表示下标1,3元素的值

*++mp;
//表示下标2,0元素的值
```



### 多维数组名

一维数组名的值是一个指针常量，它的类型是指向元素类型的指针，即指向数组的第一个元素。多维数组名也是指向第一个元素的指针，不同的是该元素是一个数组。

```c
int matrix[3][10];
```

matrix的值是一个指向包含10个整型元素的数组的指针，因此在进行运算时单位是以10个整型元素的数组作为单位，例如：

```c
matrix;
//指向第一个数组元素

matrix + 1;
//指向第二个数组元素

*(matrix + 1);
//该表达式是一个包含10个元素的数组，一维数组名是一个常量指针，因此该表达式也是一个常量指针。

*(matrix + 1) + 5;
//前一个表达式是指向一个int型的指针，加5则表示在当前指针后移5个整型元素

*(*(matrix + 1) + 5);
//作为右值时，可以取得存储地址的值，作为左值时，该位置将存储一个新值
```



下标引用其实是间接引用表达式的另外一个形式。

```c
matrix[1];
//指向第2个数组元素，因此是一个int型的常量指针，相当于*(matrix + 1)

matrix[1][5];
//*(*(matrix + 1) + 5)
```

总结：

数组名是指向第一个数组元素的指针，所以下标值会根据该元素的长度进行调整。它的结果是一个指向那一维中对应元素的指针；

间接访问操作随后选择那个特定的元素，由于该元素是一个数组，所以这个表达式的类型是一个指向下一维第一个元素的指针，而下一个下标值根据这个长度进行调整，直到所有下标计算完毕。



### 指向数组的指针

声明指向数组的指针

```c
int (*name)[length];
```

name是指针的名字，length是数组的长度。

下标引用的优先级高于间接访问符\*，但是因为有小括号会优先执行(\*name)表达式，所以name是一个指针，接下来执行下标引用，所以name是一个指向某种类型的数组，它的长度为length。

example：

```c
int vector[10], *vp = vector;
//合法的表达式

int matrix[3][10], *mp = matrix;
//*mp = matrix是非法的表达式，matrix是指针数组的指针，mp是int型指针，类型不匹配。

int (*mp)[10] = matrix;
//正确的赋值

matrix;
//等价于*matrix，数组名是指向数组第一个元素的指针，对matrix进行间接访问也是指向数组第一个元素的指针
//该元素是一个包含10个元素的数组，作为右值时是一个常量指针。

(*matrix)[1];
//matrix是指向数组第一个元素的指针
//matrix是指向一个数组的指针，间接访问的结果是指向该数组第一个元素的指针，下标1表示访问数组的第二个元素。该表达式等价于*((*matrix)+1)，所以表示matrix指向数组的第二个元素

matrix[0][9];
//等价于*(*(matrix + 0) + 9)

int *pi = &matrix[0][0];
int *pa = matrix[0];

int (*p)[] = matrix;
//视编译器，该数组指针的大小为0，如果进行指针运算可能会造成错误的结果。
```



### 作为函数参数

一维数组指向的是元素类型的指针，函数参数的原型可以是下面俩种：

```c
void func(int *element);
void func(int element[]);
```

而二维数组指向的是数组的指针，函数参数的原型也是数组指针，可以按照如下定义：

```c
void func(int (*element)[length]);
void func(int element[][length]);
```

length是数组长度，编译器需要知道第二个以及各维的长度才能进行求值，因此原型必须声明这些维的长度。



### example

```c
#include <stdio.h>
#include <stdlib.h>

void base_demo() 
{
    int matrix[3][10] = {
        {1, 2, 3},
        {4, 5, 7},
        {11, 12, 13, 14, 15}
    };

    int *m = &(*(*(matrix + 1) + 1));
    int *s = (*(matrix + 1) + 1);

    printf("m = %d\n", *m);
    printf("s = %d\n", *s);
    
    m--;
    s++;

    printf("m = %d\n", *m);
    printf("s = %d\n", *s);
}

// 多维数组名的测试
void array_name_demo()
{
    printf("example2: \n");

    int matrix[3][10] = {
        {1, 2, 3},
        {4, 5, 7},
        {11, 12, 13, 14, 15}
    };

    int (*mp)[10] = matrix;
    // 数组名指向第一个元素的指针，类型取决于元素类型，因此matrix是一个数组指针

    int *sp = *matrix;
    // 对matrix进行间接引用则获取到的第一个元素的值，它是一个数组，因此表达式的值是一个常量指针

    printf("%d\n", *sp);
    printf("%d\n", *(sp+2));

    printf("%d\n", mp[0][2]);   //输出2
    printf("%d\n", *(*mp + 2));

    printf("%d\n", *mp[2]);     //输出11
    printf("%d\n", **(mp + 2));
}
```





## 指针数组

数组元素是指针类型的数组叫做指针数组。

```c
int *api[10];
```

假定这是个表达式，对其求值。

下标引用的优先级高于间接引用，先执行下标引用，因此api[10]表示某种类型的数组；再执行间接访问操作，它的结果是一种整型值，所以api是一个指针类型的数组。

example：

```c
int main(int argc, char const *argv[])
{
    char const *keyword[] = {
        "do",
        "for",
        "if",
        "return",
        NULL
    };

    char const **t = keyword;
    //t等价于keyword，数组名是指向第一个元素的指针常量，而第一个元素又是一个指针，因此是一个指向指针的指针类型。
	
    t;
    //指向第一个元素
    
    t++;
    //指向第二个元素
    
    *t;
    //间接引用第二个指针元素，*t是一个指针常量，指向字符串"for"的首地址，printf()会打印字符串"for"

    *t + 1;
    //等价于"for" + 1
    //该表达式指向在第二个指针元素的地址向后移动一个字节的地址

    *(*t + 1);
    //作为右值时，可以取得该内存地址的值，作为左值会该地址会存储一个新值。

    char const *k = keyword[0];
    //指向第一个指针元素

    return 0;
}
```



指针数组每个指针元素都是指向各个不同的字符串常量，如果是一个矩阵的字符串数组，它每一行的长度是刚好容纳最长的字符串常量(包括NULL字节)。

```c
//矩阵数组
int const keyword[][10] = {
    "do",
    "for",
    "if"
};

//指针数组
int const *keyword[] = {
    "do",
    "for",
    "if"
};
```



example:

```c
#include <stdlib.h>
#include <stdio.h>

void size_demo()
{
    char const *keys[] = {
        "dasheng",
        "xiaoli",
        "name",
        "ab"
    };

    int i, size, length;
    char const **ele = keys;
    
    size = sizeof(keys[0]);     // 指针的大小
    length = sizeof(keys) / size;

    printf("size = %d\n", size);
    printf("length = %d\n", length);

    for(i = 0; i < length; i++) {
        printf("%s\n", keys[i]);
    }
}

void loop()
{
    char const *keys[] = {
        "a",
        "abc",
        "abcd",
        NULL
    };

    char const **val;

    // printf each element.
    for(val = keys; *val != NULL; val++) {
        printf("%s\n", *val);
    }

    // printf the second element
    char const *ele = *(keys + 2);
    char t;
    while((t = *ele++) != '\0') {
        printf("%c\n", t);
    }
}

int main(int argc, char const *argv[])
{
    size_demo();
    return 0;
}
```






