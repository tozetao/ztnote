## 进制

- 2进制转16进制
- 16进制转2进制


十六进制是每逢16进1位，二进制是每逢2进一位，且2^4 = 16，说明二进制连续进位4次等效于十六进制进1位。例如十六进制的F+1等于二进制的1111 + 1，所以1位十六进制等效于4位二进制；同理1位八进制等效于3位二进制。



### 2进制小数

10进制小数转2进制小数，主要用10进制小数部分乘以2，取整数部分依次从左到右放在小数点后，直到小数点后为0，例如：

```c
/*
	10进制小数：0.125

	0.125*2=0.25	取0
	0.25*2 =0.5		取0
	0.5*2  =1.0		取1
	
	//2进制小数是0.001


	0.58*2=1.16		1
	0.16*2=0.32		0
	0.32*2=0.64		0
	0.64*2=1.08		1
	0.08*2=0.16		0
	0.16*2=0.32		0
	0.32*2=0.64		0
	0.64*2=1.08		1
	...无线循环小数


	10010001... 舍去隐含的1是00010001....
*/
```

有一些10进制的小数在转换成2进制小数时，它的位数是无穷的，所以在将尾数保留到内存中时就发生了精度丢失，转成10进制的数值只能无限接近该数字，所以不要用浮点数来进行计算和比较。




## 原码与补码

原码和补码是计算机中对数字的二进制表示方法，它在数值前面加了一个符号位，用于表示正负。正数该位为0，负数该位为1。

正整数是以原码存储在内存中的，负整数是以补码存储在内存中的；原码与补码主要用于解决有符号整数的存储。

- 正整数的原码是该数字在内存中的二进制表示，高位是0.

  ```c
  int i = 10;	
  printf("%#x", i);	
  //2进制： 0000 1010
  //16进制：0xa
  ```

- 负整数的补码等于该数字的绝对值的原码取反并加1

  ```c
  signed i = -11;
  printf("%#x", i);	
  //0xffff fff5
  ```


- 原码与补码

  一个正整数的原码取反加1即是该正整数的负数的补码，一个负整数的补码取反加1 等于该负整数的正数的原码。



#### 有符号整型的读取

处理一个有符号整型时，编译器会先根据符号位确定正负，如果符号位是0即正数，则直接读取；如果符号位是1即负数，编译器会将补码取反再加1计算出原码，该原码的相反数就是该负数。



#### 有符号位整数的最小值

```c
int main(){
	signed int a = 0x7FFFFFFF;
	a = a + 1;
    printf("%#x\n", a);
    return 0;
}
```
0x7FFF FFFF加1等于0x8000 000，它的2进制是1000 0000 0000 0000 0000 0000 0000 0000.

由于这是一个有符号位整数，编译器会将其作为补码处理，它的符号位是1，表示该数字是一个负数，但是其他位都是0，0是没有正负区分的，所以最高位的符号位即是符号位也是数字位，因此它是32位signed int型所能表示的最小数字，即-2^32次方。

0x7fff ffff则是signed int型整数所能表示的最大整数，所以signed int表示的区间大小是-2^32至2^32-1.





## 浮点数

浮点型是小数类型，又被称为实数型。
浮点型可以分为：

- float：单精度浮点型，占4个字节，32位，7位有效数
- double：双进度浮点型，占8个字节，64位，15位有效数
- long double：长双进度浮点型，64位，15位有效数



### 浮点型的存储

#### 表现形式

浮点数的存储采用IEEE 754标准，任意一个二进制浮点数V都可以表示成以下形式：

- (-1)^s表示符号位，当s=0，V是正数，当s=1时，V是负数
- M表示有效数字，大于等于1，小于2
- 2^E表示指数位

例如十进制5.0，写成二进制小数是101.0，相等于1.01 * 2^2，对应上面的格式是s=0，E=2，M=1.01



对于32位浮点数来说，最高位是符号位s，接着的8位是指数E，剩下的23位是有效小数位。64位的浮点数，最高位是符号位，接着的11位是指数E，剩下的52位是小数位。



#### 有效数字M的规定

有效数必须大于等于1且小于2，所以需要将二进制小数转换成1.xxxx的形式，xxx表示小数部分。在存储时计算机只存储xxx的小数部分，前面的1是不存储的，这是为了多出一位有效数字。

例如二进制小数1.01只存储01，读取的时候再把第一位的1加上去，以32位浮点数来说，留给M只有23位，去掉1后等于可以保存24位有效数字。



#### 指数E的规定

指数E是一个符号整数，这意味着如果E是8位，所表示的范围是0-255。然而指数位是允许有负数的，所以IEEE规定指数E的真实值必须再减去一个中间值，对于8位的E，该中间值是127，对于11位的E，该中间数是1023。

比如2^2，E是2在保存成32位浮点数时，必须保存成2+127，即1000 1001.

指数E有三种情况：

- E的位数有0有1

  存储时采用上述的规则，即减127（1023）得到真实值，再在有效数字M前加1.

- E的位数全为0

  对于这种情况指数E等于1-127，且有效数字不再前面加1，而是还原成0.xxxxx的小数，这是为了表示接近0的很小的数字。

- E的位数全为1

  这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；如果有效数字M不全为0，表示这个数不是一个数（NaN）



以32位浮点数为例，指数位的最小值是-126，即指数位全部为0,；

指数位的最大值是127，因为指数位不能全部为1，8位能够表示的最大值是254，减去127的真实值是127。







#### example

在将十进制数转换成浮点数时，先转成成二进制的小数，再确定有效小数位，指数位以及符号位，套用IEEE 754标准集合。

1.  浮点数5.0的二进制表示

   5.0的二进制小数是0101.0，即1.01 * 2^2，s=0，E=2，M=1.01，那么第一位符号位是0，有效数M 1.01只存储01，后面加21个0凑足23位，指数E是2+127=129，即1000 0010，由此可以得到二进制数

   > 0 1000 0010 010 0000 0000 0000 0000



2. php中，一个32位int型整数在什么范围内，它转换成float再转换成int不会发生进度丢失。

   只要该整数不超过浮点数所能表示的有效位数，就不会发生精度丢失，例如32位的浮点数，它在内存中表示小数位是23位，加上隐去的1位，一共是24位，所以只要整数小于等于2^24-1，即不会发生精度丢失。



3. 为什么不使用浮点数进行比较

   因为精度的丢失。

   整数是一定能够转换成二进制数的，但是小数是不一定能够完全转换成二进制小数的，十进制小数转换成二进制小数时可能是无限不循环的二进制小数，因为这点一些小数在转换成浮点数会发生进度丢失，所以不建议使用浮点数来进行比较。