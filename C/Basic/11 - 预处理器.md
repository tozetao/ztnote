在编译一个C程序时，预处理器会先执行预处理器指令，然后生成一个修改后的C程序，最后由编译器来编译修改后的C程序。



### 宏

#define指令用于定义宏，该指令允许把一个名称指定成任何所需的文本。在定义宏之后，无论宏在何处使用，预处理器都会将宏替换为指定的文本。



### 简单的宏

```c
#define 宏名称 替换文本
```

宏名称是宏的标志，替换文本可以理解为是要替换宏名称的C程序。当预处理器遇见宏定义时，会使用替换文本来替换宏名称。



### 带参数的宏

```c
#define 宏名称(x1, x2, x3...) 替换文本
```

宏允许定义参数，在宏名称后面使用括号定义所需的参数，注意宏名称和括号之间必须没有空格，否则编译器会认为是定义一个简单的宏。

example：

```c
#define MAX(x, y) ((x) > (y) ? (x) : (y))

int main() {
    int result = MAX(10, 100);
}
```

使用带参数的宏要注意几点：

- 预处理器不会检查宏参数的类型，也不会进行类型转换。

- 无法用一个指针来指向一个宏。

- 宏可能会不止一次的计算它的参数，例如：

  ```c
  #define MAX(x, y) ((x) > (y) ? (x) : (y));
  
  //使用宏
  MAX(i++, j);
  
  //生成的代码
  ((i++) > (j)) ? i++ : j;
  ```

  如果i大于j，i将会自增，会产生我们不希望的结果。



宏定义可以包括俩个专用的运算符：#和##。

#运算符可以在替换文本中，将宏的一个参数转换为字符串字面量。比如：

```c
#define PRINT_INT(n) printf(#n " = %d", n);

PRINT_INT(i/j);
//会被替换为：printf("i/j = %d\n", i/j);
```



### 宏的通用属性

- 宏的替换文本可以包含对其他宏的调用。

  ```c
  #define PI 3.14159
  #define TOW_PI (2*PI)
  ```

- 预处理器在处理宏时，只会替换完整的宏，因此会忽略字符串字面量、宏名字中的宏。比如：

  ```c
  #define SIZE 256;
  
  int BUFFER_SIZE;
  
  if (BUFFER_SIZE > SIZE)
      puts("Error: SIZE exceeded.");
  ```

  预处理器会忽略变量BUFFER_SIZE和字符串中的SIZE的处理。

- 默认宏作用于整个文件，但是可以使用#undef指令来取消定义。比如#undef N将会删除宏N的当前定义。



### 条件编译

条件编译是指根据预处理器执行的测试结果来包含或排除程序片段。

- #if与#endif

  当预处理器碰到#if指令时，会计算常量表达式的值。如果表达式的值为0，那么#if与#endif指令之间的行在预处理过程中会从程序中删除，否则将保留。

- #ifdef与#ifndef

  #ifdef指令测试一个标识符是否定义为宏，而#ifndef指令则测试一个宏是否没有定义为宏。

- #elif与#else

  #elif、#else指令可以与#if、#ifdef和#ifndef指令结合使用。







#include指令

用于打开指定的文件，并把此文件的内容插入到当前文件中。#include指令有俩种书写方式：

```c
#include <filename>
#include "filename"
```

第一种方式用于加载C语言自身库的头文件，编译器会搜寻系统头文件所在的多个目录。第二种方式用于加载自身编写的头文件，编译器会搜寻当前目录，然后搜索系统头文件所在的目录。



保护头文件

如果包含同一个头文件俩次，那么可能产生错误。比如file1.h包含file3.h，file2.h包含file3.h，如果其他源文件包含file1.h和file2.h，那么file3.h将会被编译俩次。

多次包含同一个头文件，共享宏、共享变量或函数定义都不会编译报错，但是如果包含变量定义将会编译错误。

example：file3.h文件

```c
#define LENGTH 1000

void demo(void);

//编译报错
int total = 0;
```









程序构建

按照惯例，源文件的扩展名为.c，头文件的扩展名为.h。

一般头文件会包含宏定义、类型定义、函数原型的声明，而源文件则对应头文件的实现。



共享宏定义、类型定义

头文件中定义共享宏、共享类型。



共享函数原型

头文件中定义函数原型，源码文件负责实现。



共享变量声明

通过关键字extern来声明共享变量，extern声明的变量编译器是不会分配空间的，只有在定义的时候才会分配空间。

```c
//声明变量i并定义
int i;

//只声明而不定义，声明时不会分配内存空间。
extern int i;
```







### 编译与链接

编译

必须对程序中的每个源文件进行编译。对于每个源文件，编译器会产生一个包含目标代码的文件，这些文件称为目标文件（object file），在unix系统扩展名为\.o，在windows系统扩展名为\.obj。

不需要编译头文件，因为编译包含头文件的源文件时会自动编译头文件的内容。

> gcc -c demo.c -o demo

将源文件编译成目标代码。



链接

链接器把编译产生的目标文件和库函数的代码结合在一起生成可执行的程序。gcc编译器允许链接多个目标文件来构建可执行程序。

> gcc -o exec demo.c demo1.c demo2.c

-o是可执行文件的名字，编译器



makefile

描述文件之间的依赖性，用于编译和构建复杂的引用程序。makefile由一组组的规则组成，每一组规则描述目标文件的依赖关系，以及根据依赖关系去编译代码文件。

```ini
demo: demo.o stack.o
	gcc -o demo.o stack.o

demo.o: demo.c stack.h
	gcc -c demo.c

stack.o: stack.c stach.h
	gcc -c stack.c
```

一个可执行程序需要链接多个目标文件才能生成可执行文件。在makefile文件中，每俩行为一组规则。第一行命令描述文件的依赖关系，第二行命令决定是去编译还是链接文件。

在上面这个案例中，第一组规则第一行说明demo程序要链接的目标文件，第二行告诉编译器如何链接文件。

