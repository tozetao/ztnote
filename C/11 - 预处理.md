编译一个C程序的第一个步骤称为预处理(preprocessing)阶段，C预处理器在源代码编译之前会做一些文本性质的操作：

- 删除注释
- 插入#include指令包含的文件内容
- 定义和替换有#define指令定义的符号
- 确定代码的部分内容是否应该根据一些条件编译指令进行编译。



### 预定义符号

由预定义器定义的符号。

- \_\_FILE\_\_：进行编译的源文件名
- \_\_LINE\_\_：文件当前的行号
- \_\_DATE\_\_
- \_\_TIME\_\_
- \_\_STDC\_\_



### #define

> \#define  name  stuff

该指令表示，每当有符号name出现在这条指令的后面时，预处理器就会把它替换成stuff。stuff并不限于数值字面值常量，它可以是任何文本，例如：

```c
#define reg register
#define do_forever for(;;)
```

如果stuff的内容很长，它是可以分行的，每行的末尾需要加上反斜杠，除了最后一行。

```c
#define DEBUG_PRINT pirntf("File %s line %d:" \
					" x=%d, y=%d, z=%d", \
					__FILE__, __LINE__, x, y, z)

x *=2;
y +=x;
z = x * y;
DEBUG_PRINT;
```

### #define替换

- 宏参数和#define定义可以包含其他#define定义的符号，但是宏不可以出现递归。

  ```c
  #define NUMS 100;
  #define Test(x) x * NUMS
  
  printf("%d\n", Test(1));	// 输出100
  ```


- 预处理器在处理#define定义的符号时，对于字符串常量是不进行检查，如果想要把宏参数插入到字符串常量中，可以使用邻近字符串连接特性。

  ```c
  #define PRINT(fotmat, value) printf("The value of " #value " is " format "\n", value);
  
  int x = 10;
  PRINTF("%d", x + 3);
  ```

## 宏

> \#define  name(parameter-list)  stuff

\#define机制允许把参数替换到文本stuff中，这种实现被称为宏或定义宏(define macro)。

在声明时，parameter-list是以逗号分隔的参数列表，而当宏被调用时，parameter-list是一个由逗号分隔的值的列表，每个值与定义的参数对应，并且实际的值会被替换到stuff中。



一般在定义宏时，名字全部大写，方便与函数定义区别。

在使用宏的时候，所有用于对数值表达式进行求值的宏定义，需要对每个参数用小括号包裹起来并且对整个表达式用小括号包裹起来，避免在使用宏时，由于参数中的操作符或临近的操作符之间产生的不可预料的作用。

```c
#define DOUBLE(x) x * x;

int main()
{
    int a = 10;
    printf("%d\n", DOUBLE(a + 1));
    // 输出21，因此替换后的文本为：10 + 1 * 10 + 1，产生的表达式并不是期望的
    return 0;
}
```

在上面的例子中对宏进行修改：#define DOUBLE(x)  ((x) * (x));



### 宏与函数

一般宏用于执行简单的计算，例如俩个数中寻找更大或更小的数。

宏的优点：

- 用于调用和从函数返回来的代码可能比宏的代码量大，使用宏比使用函数在程序规模和速度方面更优一些。

- 函数参数的声明必须是一种特定的类型，而宏则不是，宏的参数可以是任何类型。

  ```c
  #define MAX(a, b) ((a) > (b) ? (a) : (b))
  ```

- 某些任务无法用函数使用，例如把数据的类型作为参数传递

  ```c
  #define MALLOC(n, type) ((type *)malloc((n) * sizeof(type)));
  
  int *pi;
  
  pi = MALLOC(10, int);
  pi = ((int *)malloc((10) * sizeof(int)));
  //上述俩个语句是等价的
  ```

缺陷：

- 宏的缺陷在于使用时宏所定义的代码都将插入到程序中，除非宏特别短，否则使用宏会大幅度的增加程序的长度。



### 副作用的宏参数

当宏参数在宏定义中出现的次数超过一次时，如果该参数具有副作用，那么在使用宏的时候可能会产生意料外的结果。

example：

```c
#define MAX(a, b) ((a) > (b) ? (a) : (b))

int x = 5, y = 6, z;
z = MAX(x++, y++);

//宏替换后的代码为
z = x++ > y++ ? x++: y++;
//z = 7, x = 5, y = 8
```



## include

include指令即文件包含，在执行代码替换时，预处理器会删除这条指令，并用包含文件的内容进行替换。



函数库文件

> \#include  <filename>

函数库文件的包含要使用这种语法声明，对于filename不做限制，按照约定标准库文件已.h结尾。





本地文件包含

> \#include "filename"

处理本地头文件时，编译器会在当前目录进行查找。如果该头文件为找到编译器会像查找函数库头文件一样在标准位置查询该头文件。