C语言的类型分为函数类型，对象类型和不完成类型三大类。



对象类型分为标量类型和非标量类型；指针类型属于标量类型，因此可以做逻辑与、或、非运算的操作数，以及if、fot、while的条件表达式，NULL指针表示假，非NULL指针表示真。



### 不完全类型

指的是暂时没有完全定义的类型，编译器不知道该类型要占据多少字节空间，例如：

```c
struct s;
union u;
char str[];
```



不完全类型是可以通过多次声明组合成完成类型的，例如：

```c
char c[];
char c[10];
```

编译器碰到第一个声明时认为是不完全变量，无法确定内存空间大小，碰到第二个声明时str就组合成完全类型了。如果编译器处理到文件末尾变量仍然是不完全变量时就会报错。

好处：变量的声明可能并不是在同一个文件中的，比如第二个声明可以写到另外一个文件中，这样修改数组的长度就不用去修改主文件了。



####  不完全声明结构体

```c
struct s {
    struct t *pt;
};

struct t {
	struct s *ps;
};
```

编译器在解析结构体s时，认为struct t是不完成类型，但是指针pt是一个完全类型，因为指针占据4个字节；

在解析到结构体struct t {struct s *ps;};时，这时struct  t有了完整定义，变成一个完全结构体，pt的类型就组成了一个指向完全类型的指针；同理struct  s在前面定义了，所以struct  s  *ps也定义了一个指向完全类型的指针。



error example:

```c
struct s {
    struct t pt;
};

struct t {
    struct s ps;
};
```

这种类型的定义是错的，编译器不知道struct  t  pt要占据多少个字节，所以无法定义成员pt。



在结构体中可以递归的定义结构体指针，但是不能递归的定义结构体变量成员。

```c
struct node {
  struct node *next;  
};
```

编译器在解析到struct  node  *next时，struct node是一个不完全类型，所以next指针指向一个不完成类型的指针，当编译结束后知道struct node是一个完全类型，next变成指向了一个完全类型的指针







