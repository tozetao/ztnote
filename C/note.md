任何语言大体可以分为4块：数据成分、运算成分、控制成分、输入输出成分。
 

内存：
将内存想象成一系列块的集合，每一块都是一个存储单元，它有8位bit大小，也就是一个byte字节大小。
每一块存储单元都有一个对应的地址，一般是用内存地址来表现。


### 变量的定义
在C语言中变量必须是先定义，然后才能使用的。

当你在程序中定义了一个变量，计算机会在内存中找到几个连续的存储单元，将这片存储空间定义成变量名，将值放到存储空间，并且记下变量名与这片连续的存储单元的起始地址，将它们的对应关系记录下来。

## 整数
### 整型的分类
整数就是整型，在C语言中，整型能够分为：
- int
- short
- long

int型变量会在内存中占用4个字节，short型变量会占用2个字节，long型至少会占用32位类型，这3种类型因为占用的字节长度不同，所以能表达的数值大小也不同。

其实C语言标准并没有明确定义每种整数类型占用的字节长度，它的标准是int型长度不能短于short型，long型不能短于int型，所以在不同编译器下它们的长度可能会不同，如果要知道某种数据类型的长度，可以使用sizeof运算符来计算。

又因为正负数的关系，整型能分为有符号型和无符号型，例如：
- signed short
- unsigned short
- signed int
- unsigned int
- signed long
- unsigned long

unsigned是无符号的意思，表示不能使用负数，一个无符号的数据类型长度是从0开始起算的。
在C语言中，定义变量时默认是有符号型的，所以在程序中定义变量不需要写signed。

### 整型的存储方式
不同的整型在内存中的存储方式是不同的，有符号型的整型会用最高位来表示正负，0表示正数，1表示负数，无符号性则没有符号位。

例如：
```c
unsigned int i = 123;
// 假设该int型占32位，在内存中大体表现如下
// 0000 0000 0000 0000 0000 0000 0111 1011

int i = -123;
// 有符号int型也占32位，在内存中表现如下
// 1111 1111 1111 1111 1111 1111 1000 0101   
```
正整数与负整数的二进制方式在内存中表示是不同的，在计算机中存储一个整数时并不是将其转换成二进制来存储的，而是存储它的补码。

对于一个正整数23存储的是它的原码，对于一个负整数存储的是它的补码。
原码和补码之间有对应关系，正123的原码 取反+1 等于负123的补码，-123的补码 取反+1 等于 正123的原码

求一个负整数的补码：
- 先确定符号位为1
- 求出绝对值的原码
- 对原码每一位取反
- 在原码取反的基础上加1，就能得到该负数的补码了

### 整数的输入输出
将一个整数转换成8进制或16进制，可以很方便看出该整数的二进制表现，例如：0x7ff1等于0111 1111 1111 0001

原因：
- 2进制转8进制是每3位每3位的转换，同时2进制的0111对应8进制的7，0110对应8进制的6；
- 2进制转16进制是每4位4位的转换，1111对应F，1000对应8

整数的书写形式，0开头的数值是8进制形式，0x开头的数值时16进制形式。

### 整数的范围
```c
int main(){
	signed int a = 0x7FFFFFFFF;
	a = a + 1;
	cout << dec << a << endl;
	return 0;
}
```
0x7FFFFFFFF表示成2进制是0111 1111 1111 1111 1111 1111 1111 1111，
当它加1时则变成1000 0000 0000 0000 0000 0000 0000 0000；

最高位是1，直观的看该数字是一个负数，后面都是0所以是-0，但是0是没有正负区分的，所以C语言规定，当最高位是1其他位是0时，最高位既表示符号位也是数字为，所以0x7FFFFFFF+1 = -2^32，这也是无符号32位int型的最小表示。


## 浮点型
浮点型是小数类型，可以分为：
- float：单精度浮点型，占4个字节，32位，7位有效数
- double：双进度浮点型，占8个字节，64位，15位有效数
- long double：长双进度浮点型，64位，15位有效数

```c
float a = 3.123456789987456;
double b = 3.123456789987456;

cout << a << endl;
return 0;
```

关于精度问题，精度指浮点数可存储的小数位数，超出有效位将会是0，并且要知道可存储的小数是近似的，而不是完全相等的。
