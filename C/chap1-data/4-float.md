
## 浮点型
浮点型是小数类型，又被称为实数型。
浮点型可以分为：
- float：单精度浮点型，占4个字节，32位，7位有效数
- double：双进度浮点型，占8个字节，64位，15位有效数
- long double：长双进度浮点型，64位，15位有效数

### 浮点型的精度
```c
#include <iostream>
#include <iomainop>
using namespace std;

float a = 3.123456789987456;
double b = 3.123456789987456;

cout << a << endl;	//3.12345
cout << b << endl;	//3.12345
//cout默认输出6位精度，精度是包含整数位的

cout << setprecision(100) << a << endl;		//
cout << b << endl;			//
//将打印精度设置为100，输出：
return 0;

```
有效数位指的是整数与小数的位数，上述的例子就能看出因为类型不同，保存的有效位也不同，
这里要知道超出有效位后浮点型是不能正确保存小数点额。



### 浮点型的存储
浮点型的存储跟编译器无关，一般是根据编译器使用的IEEE标准来进行实现的。
使用float类型举例来说，float是用32位来存储的，在内存中是由符号位、指数位加尾数来表示的，

- 符号位：最高位表示数据的正负
- 指数位：以2为底的幂，采用偏移码表示，例如2的35次幂，指数位存储的是35
- 尾数：表示数据小数点后的有效数字，IEEE标准规则尾数要表示成1.xxxxxx的形式，即1<=尾数<2，其中会舍去1，在内存中只保留xxxx的部分。

例如：
```c
// 0/*符号位*/ 10000000001/*指数位*/ 0100000000000000000000000000000000000000000000000000
```

假设数值-314.12，将其表示成科学计数法是-3.1412 * 10^2，最高位是正负号1，后8位表示10^2，后23位表示3.1212，当然在存储时需要将-314.12转换成2进制小数形式1.xxx * 2^n形式在进行存储。

指数位是用8位来表示，除去1位符号位，能够表示的最大数字是2^127次方，由于跟10的N次幂有对应关系，也即是求以10为底2^127的指数，大约是38。

小数位是用23位来表示，省略到默认的1，它能够表示的数字是2^24(我觉得是2^24-1)，转成10进制的位数即是求log10(2^24)，大约是7.225，所以能够表示的有效位是7位，最大数是约是10^38次方

```
int main(){
	float a = 0, b = 0;
	a = 123456.789e5;
	b = a + 20;
	
	cout << setprecision(20) << b << endl;
	return 0;
}
```
注：避免将一个很大的数与一个很小的数直接相加或相减，否则就会丢失小的数字。


### 2进制小数
10进制小数转2进制小数，主要用10进制小数部分乘以2，取整数部分依次从左到右放在小数点后，直到小数点后为0，例如：
```c
/*
	10进制小数：0.125

	0.125*2=0.25	取0
	0.25*2 =0.5		取0
	0.5*2  =1.0		取1
	
	//2进制小数是0.001


	0.58*2=1.16		1
	0.16*2=0.32		0
	0.32*2=0.64		0
	0.64*2=1.08		1
	0.08*2=0.16		0
	0.16*2=0.32		0
	0.32*2=0.64		0
	0.64*2=1.08		1
	...无线循环小数


	10010001... 舍去隐含的1是00010001....
*/
```
有一些10进制的小数在转换成2进制小数时，它的位数是无穷的，所以在将尾数保留到内存中时就发生了精度丢失，转成10进制的数值只能无限接近该数字，所以不要用浮点数来进行计算和比较。


### 浮点数的最大精确范围
比如, 对于整数, 我们知道它的二进制表示是, 101, 现在, 让我们右移俩位, 变成1.01, 舍去高位的隐含有效位1, 我们得到在double中存储5的二进制数值为:
```c
// 0/*符号位*/ 10000000001/*指数位*/ 0100000000000000000000000000000000000000000000000000
```

5的二进制表示, 丝毫未损的保存在了尾数部分, 这个情况下, 从double转会回long, 不会发生精度丢失.
我们知道double用52位表示尾数, 算上隐含的首位1, 一共是53位精度.. 那么也就可以得出, 如果一个long的整数, 值小于:
```c
2^53 - 1 == 9007199254740991; //牢记, 我们现在假设是64bits的long
```