C语言提供了俩种聚合数据类型，数组和结构。数组是相同类型值的集合，而结构是不同类型值的集合。

结构是一些值的集合，这些值被称为成员，在结构中成员可以有不同的类型



### 声明

```c
struct tag { mumber-list } variable-list;
```

tag是标签名，可以认为是结构体的名字；member-list是成员列表，成员由类型与变量名组成；variable-list是结构变量列表，即所声明结构的变量名。



- tag的声明方式

  ```c
  struct SIMPLE {
      int a;
      float b;
      char c;
  };
  ```

  这种声明方式将标签与成员列表绑定在一起了，我们可以通过标签来创建变量。

  ```c
  struct SIMPLE x;
  struct SIMPLE y[20], *z;
  //x,y,z都是同一种类型的结构变量
  ```


- typeof的声明方式

  ```c
  typedef struct {
      int a;
      char b;
      float c;
  }Simple;
  ```

  这种声明方式相当于创建了一种新的类型，这是Simple是一种类型而不是个结构标签。

  ```c
  Simple x;
  Simple y[20], *z;
  ```



### 初始化

结构体的初始化与数组一样，在一对大括号中编写初始值的列表。

这些值根据成员列表的顺序进行初始化，如果初始列表的值不够，剩余成员变量将使用默认值进行初始化。

```c
struct INIT_EX {
    int a;
    short b[10];
    Simple c;
} x = {
    100,
    {1,2,3,4,5,6},
    {1, 10.85, 'c'}
};
```



### 成员的访问

结构成员不仅可以是标量类型，也可以是数组或其他结构体类型。

访问结构体成员是通过点操作符，点操作符接受俩个操作数，左操作数是结构体变量名，右操作数是要访问的成员的名字。

注：点操作符与下标操作符的优先级是相同的，因此结合性是从左往右的

```c
typedef struct {
    int i;
    float f;
}Simple;

typedef struct {
    float f;
    int i;
    Simple sa[10];
    Simple *sp;
}Complex;

Complex comp;

//直接访问
comp.i;

//访问结构体数组类型的成员变量
comp.sa[4].f;
```



箭头操作符

箭头操作符的左操作数必须是一个指向结构的指针，它会对左操作数执行间接访问取得指针指向的结构体，然后再想点操作符一样通过右操作数去访问结构的成员。

注：间接访问操作是内建与箭头操作符中的。

```c
(*comp.sp).i;
//首先对指针执行间接访问操作获得该结构，然后使用点操作符来访问成员变量，由于点操作符的优先级高于间接访问操作符，因此需要加小括号。

//上述的访问很繁琐，因此C提供箭头操作符来访问成员变量
comp->sp->i;
```





### 自引用

结构体的自引用指成员变量的类型是该结构体本身。

```c
struct Node {
    int a;
    int b;
    struct Node *n;
};
```

要注意的是自引用结构体必须是指向结构的指针而不是一个结构体，对于指向结构的指针在编译阶段可以确定该结构指针的长度，如果成员变量是结构体类型将会形成死循环声明，这是错误的。

example：

```c
typedef struct {
    int a;
    SELF_REF *b;
} SELF_REF;
//错误的声明方式，该类型名直到声明的末尾才定义，对于结构体内部是未知的，因此错误。

typedef struct SELF_REF_TAG {
    int a;
    struct SELF_REF_TAG *b;
} SELF_REF;
//正确的声明方式
```



### 不完整声明

不完整声明主要用于解决俩个结构体相互依赖，例如A结构的成员是B结构体，而B结构体的成员是A结构体。

```c
struct A;

struct B {
    struct A *parent;
};

struct A {
    struct B *parent;
};
```

在B的成员列表里需要标签A的不完整声明，B在声明之后，就可以在A的成员列表里声明。



### 结构与指针

指向结构的指针作为左值和右值的情况：

```c
typedef struct {
    int a;
    short b[2];
}Child;

typedef struct  Ex{
    int a;
    char b[3];
    Child c;
    struct Ex *p;
}Ex;

Ex ex = {
    100,
    "Hi",
    {1, {-1, 35}},
    0
};
Ex *px = &ex;

px;
//px是一个指针变量，作为右值时值是px的内容，作为左值时表示px的旧值会被新的值代替

*px;
//作为右值时，*px表示整个结构体，等价于变量ex；
//作为左值时，表示该结构会接收一个新值，更准确的说是所有成员会接收新的值，作为左值重要的是内存地址。

px->b;
//成员b是一个数组，作为右值是指针常量，作为左值是非法的。

px->c;
//c成员是结构类型，作为右值时表示整个结构体，作为左值时表示接受一个新的结构体的赋值


px->d;
//d成员是一个指向结构的指针，作为右值是该指针的内容，作为左值表示指向一个新的地址

*px->d;
//作为右值是指针所指向的结构体，作为左值是接收一个新的结构体

//example:
(*px).a;
//输出100

*(*px).b;
//输出H

*px->b;
//输出H

px->c.b[0];
//输出-1

(*px->d).a;
px->d->a;
```



example

```c
Child c1 = {
    100,
    "ab"
};

Child c2 = {
    200,
    "cd"
};

c1 = c2;
//允许的赋值方式

Child *pc = &c1;
//right

*pc = c1;
//right

c1 = {20, 'de'};
//错误的赋值方式
```



### 存储分配

编译器在为结构体分配内存空间时，会按照成员列表的顺序分别为每个成员分配内存，只有当某些成员需要满足正确的边界对齐要求时，成员之间才可能出现用于填充的额外内存空间。



内存边界对齐

```c
struct ALIGN {
    char a;
    int b;
    char c;
};
```

假设某个机器的整型长度是4个字节，并且起始存储位置必须能够被4整除。成员a会存储在一个能够被4整除的内存地址，结构的下一个成员是b，它必须跳过3个字节到达合适的边界才能存储，在整型值之后是最后一个字符。



原因：系统禁止编译器在一个结构的起始位置跳过几个字节来满足边界对齐要求，所有结构的起始存储位置必须是结构中边界要求最严格的数据类型所要求的位置。



你可以通过调整成员的位置来节省内存空间，例如ALIGN结构体可以把字符成员a、c声明在一起，它们会存储在4个字节的内存块中。



### 作为函数参数

