## 类型转换

在一些场合C语言会发生隐式的类型转换。



### 赋值运算的类型转换

赋值运算符基本功能是给赋值号左边的变量赋值，例如：

```c
int i = 5;
//与其他语言不同，C语言这里是俩条语句，声明int i，再给i赋值
```

在对一个变量赋值时，俩边的数据类型不一致，赋值时就会进行隐式的类型转换，右边操作数的类型将会转换为左边变量的类型。



- 长数赋值给短数时，长数多出的高位将会被剔除掉，剩余的位数赋值给短位。

  ```c
  int main()
  {
  	long int long_i = 0x2AAAAAAA;
  	cout << long_i << endl;

  	short short_i = long_i;
  	cout << hex << short_i << endl;	//aaaa
  	cout << dec << short_i << endl;	//-21846
  	return 0;
  }
  //长数高位被剔除后，程序将解析剩余的位数，因为short是有符号的短整型，解析1010 1010 1010 1010结果是-21846
  ```

  ​


- 短数赋值给长数，值将保持不变

  ```c
  short s = -1;
  long l = s;		//-1

  //1. 短数是无符号数，会将短数的位数直接放到长数的位数，同时长数的高位补0

  //2. 短数是有符号数，会将短数的位数赋值给长数的位数，同时短数的最高位为0，长数的高位全部补0，若短数的最高位是1，那么长数的高位全部补1
  ```

  ​


- 符号位处理

  有符号数和无符号数之间相互转换的话，位数将直接赋值。

  例如一个有符号位的负数赋值到一个无符号位的数字时，最高位的符号位将会变成数字位，转换过程后数值会变大。

  ```c
  unsigend short s = -1;
  cout << s << endls;		//2^16+(-1)
  ```

  ​

### 表达式的类型转换

如果运算符的俩个操作数类型不同，将会发生隐式类型转换。一般的会将"较低"类型的变量转换成"较高"类型的变量，运算结果是较高的类型。

| 高位 | double       | <= float      |
| ---- | ------------ | ------------- |
|      | long         |               |
|      | unsigned int |               |
| 低位 | int          | <= char/short |

转换规则可以简单理解成"低位"类型的数转换成"高位"类型的数。

横向来说

- char/short => int

  表达式有int和char/short不同类型的操作数，char/short将会被转换成int再参与运算

- float  =>  double

纵向来说

- int => unsigned int

  有符号int会被转换成无符号int再进行运算

- unsigned int => long

  unsigned int会被转换成long类型再进行运算

- int => unsigned => long => double

  整型会被转换成浮点型后再进行运算