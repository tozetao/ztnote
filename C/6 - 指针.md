## 指针

把一个变量的起始内存地址保存在另外一个内存单元中，保存地址的这个变量被称为指针。

- &：取址运算符，获取一个变量的内存地址
- *：用于定义指针类型，也可以用于取指针所指向变量的值

```c
int i = 10;
int *pi = &i;

char c = 'A';
//定义一个char型的指针，存储c变量的内存地址
char *pc = &c;

char *pi = *pi + 10;
//取pi
```

全局变量只能用常量表达式来初始化，&是取值运算符，配合变量使用就构成了一个表达式。例如&i，因为可以在编译阶段确定变量的内存地址，所以允许全局初始化



### 指针变量的内容

一个变量的值就是分配给该变量的内存地址所存储的值，即使是指针也不例外。

```c
int a = 10, b = 35;
float f = 3.15;

int *pa = &a;
int *pb = &b;
// pa变量存储的是a变量的起始内存地址
```



### 指针的大小

指针的内存单元都占据4个字节，因为要保存32位的虚拟地址，同理在64位平台占据8个字节。



### 指针的类型

指针的类型决定编译器是如何解引用的，char型的指针，编译器在取值的时候会从指向的内存地址读取一个字节的数据，其他类型的数据同理。

```c
char c = 'a';
int i  = 100;

char *pc = &c;
int *pi = &i;

pi = (int *)pc;
//pi和pc都指向同一个地址，但是pi是int型指针，它会访问4个字节，除非你确定变量c和后面的3个字节组合而成的int是有效的，否则不能这样做
```





### 未初始化指针

如果只是声明了指针，那么该指针指向一个未知的地址。

```c
int *a;
*a = 10;
//a指针虽然是int型，但是并未指向任何地址，因此对*a所指向的内存地址赋值会发生错误。
```

- NULL

  NULL主要用于表示某个指针并未指向任何东西，要使一个指针变量为NULL，可以给它赋值为0。

- NULL的定义

  定义在stddef.h头文件中，即把地址0转换成指针类型，叫做空指针；

  操作系统是不会把数据保存在0地址附近，也不会把0 - 0xffff的页面映射到物理内存，任何对地址0的访问都会直接抛出错误。

  ```c
  define NULL ((void *)0)
  ```

- 在定义指针时建议初始化确定的值或者初始化为NULL



### 左值

指针变量是可以作为左值的。

对指针进行间接访问表示访问指针所指向的位置，由于间接访问指定了一个特定的内存位置，因此可以把间接访问表达式的结果作为左值使用。

```c
int a = 5;
int *d = &a;
*d = 10 - *d;
//右边的间接访问作为右值使用，它的值是d所指向的位置所存储的值，即a的值；
//左边的间接访问作为左值使用，*d是a的内存地址，所以d所指向的地址会把右边表达式的结果作为新的值存储

d = 10 - *d;
//该语句是非法的，它表示把右边表达式计算的整数结果存储到指针变量d中，因为类型不一致所以会发生编译错误。

int c = 20;
d = &c;
//该语句就是正确的

*&a = 25;
//&a计算出a的内存地址，*运算符针访问该内存地址，所以是针对a进行赋值。
```



### 指针的指针

一个指向指针类型的指针被称为指针的指针。

```c
int a = 10;
int *b = &a;
int **c = &b;
//变量a是一个整数，b是一个指向整型的指针，c是一个指向b的指针，所以它是一个指向整型的指针的指针。

b;
//等价于&a

*b;
//等价于a

c;
//等价于&b

*c;
//等价于b, &a

**c;
//等价于*b, a
```

\*c表达式访问c所指向的位置，即变量b，而\*(\*c)等价于\*b，即访问b所指向的位置，即访问变量a。



### 指针运算

指针运算支持算术运算和关系运算。

- 注：数组是连续的内存地址，因此后面元素的地址大于前面元素的地址。



指针的算数运算只支持俩种形式：

- 指针+/-整数

  当一个指针与一个整数进行算数运算时，C会根据指针类型的大小来进行调整，C会把整数值与指针类型的大小相乘后再进行计算。

  例如一个int型指针加1，该指针会后移4个字节大小的地址。

- 指针 - 指针

  只有俩个指针都指向同一个数组中的元素时，才允许一个指针减另外一个指针。俩个指针相减的结果是俩个指针在内存中的距离，该距离是以数组元素的长度为单位，而非字节，因为运算的结果会除以数组元素类型的长度。

  例如p1指向array[i]，p2指向array[j]，p2-p1相当于j-i



指针的关系运算只支持>、>=、 <、<=运算符，并且比较的指针是指向同一个数组中的元素。

example：

```c
#define N_VALUES 5
float values[N_VALUES];
float *vp;

for(vp = &values[0]; vp < &values[N_VALUES];) {
    *vp++ = 0;
}


for(vp = &values[N_VALUES]; vp > &values[0];){
    *--vp = 0;
}


for(vp = &values[N_VALUES]; vp > &values[0]; vp--){
    *vp = 0;
}
// 这里会造成一个问题，在数组第一个元素被置为0之后，vp的值还会减1，而接下去的一次比较运算会出现问题，因为vp已经移动到数组的边界之外。
// 标准允许指向数组元素的指针与指向数组最后一个元素后面的那个内存地址的指针进行比较，但不允许与指向数组第一个元素之前的内存地址的指针进行比较。为了代码的可移植性，上面的代码是不推荐的。
```



### void *

一种通用指针类型，该类型的指针可以用于转换成任何类型的指针，并且是隐式转换，

void *指针也是分配4个字节单元的，一般用于函数接口，但是void *是不能直接访问的，必须先转换成其他类型的指针再访问。

```c
void func(void *pc)
{
    char *pchar = pv;
    *pchar = 'A';
}

int main(void)
{
    char c;
    func(&c);
    printf("%c\n", c);
}
```





### example

```c
char ch = 'a';
char *cp = &ch;

// ch作为右值时是表达式的值，ch作为左值时是该变量的内存地址
// &ch作为右值时是ch变量的内存地址，作为左值时是非法的，当&ch表达式求值时，它的结果是需要存储在内存中的，然后这个表达式并未标识任何机器内存的特定位置，所以非法。

// cp作为左值时是cp所处的内存地址，作为右值时是cp的值
// &cp作为左值时非法，作为右值时表示cp变量的内存地址。
// *cp作为右值时表示访问cp所指向的位置，即变量ch，作为左值时表示cp指向的内存地址会把右边表达式的结果作为它的新值

*cp + 1;
// *cp获取变量ch的值a，加1后该表达式的结果为b
// 作为左值时是非法的，因为存储位置未定义，作为右值时表示b

*(cp + 1);
// cp是一个char型的指针，加1会把cp存储的地址进行相加，因此该表达式会指向ch变量下一个字节的内存地址。
// 该表达式的右值是这个位置的值，左值时内存地址本身。

++cp;
// 前缀++是先增加它的操作数再返回结果，该表达式的右值是增值后的指针的一份拷贝，作为左值时是非法的。

cp++;
// 后缀++是先返回值的一份拷贝，再对值进行自增操作，因此该表达式的右值是cp值的拷贝，作为左值是非法的。

*++cp;
// 间接访问操作符作用于增值后的指针的拷贝上，该表达式的右值是ch后面那个内存地址的那个值，左值是那个内存地址。

*cp++;
// 由于是后缀++，该表达式的右值是cp本身的拷贝，左值是cp指向的内存地址。

++*cp;
// 在该表达式中，操作符的结合性是从右向左的，所以先执行间接访问操作，然后cp的值增加1，表达式的结果是这个增值后的一份拷贝。
// 该表达式作为左值是非法的。
```



```c
++*++cp;
// 从右向左进行计算，++cp表示cp所指向的内存地址加1，*++cp则会取++cp所指向的内存地址的值，最后再进行++表示该内存地址的值加1
// 该表达式作为左值是非法的

++*cp++;
// 从右向左进行计算，cp++是先返回cp操作数再进行自增，*cp++会取cp所指向内存地址的值，最后再对*cp所指向的值进行前缀自增操作。
```



总结：

每个bit位都由一个地址标识，通常会将临近的多个bit位合并成一组，这样可以表示更大范围的数。而指针就是值是内存地址的变量。





## 高级指针

### 高阶声明

> int f();

f被声明为一个函数，它的返回值是整数。

> int *f();

先执行函数调用符()，因为()的优先级高于\*，所以f是一个函数，它的返回值是一个int型指针。

> int (*f)();

第一对小括号()使f成为一个函数指针，因为f是在函数调用之前进行间接引用，第二对小括号()是函数调用符。

> int  \*(\*f)();

该表达式与上个声明基本相同，f是一个函数指针，但是它的返回值是一个int型指针



与数组组合下的声明：

> int f[];

f是一个整型数组

> int *f[];

下标运算符的优先级高于间接引用运算符，因此f是一个数组，它的元素类型是指向int型的指针，所以f是一个指针数组。

> int (*f[])();

首先针对表达式*f[]求值，f是一个指针数组，表达式的末尾是函数调用操作符，所以f是一个元素类型为函数指针的数组，它的返回值是一个整型

> int \*(*f[])();

与上个表达式相同，不同的是返回值是一个int型的指针



example:

```c
int (*f)(int, float);
// f是一个函数指针，它所指向的函数接收俩个参数，分别是一个int型和float型，并返回一个整型值。

int *(*g[])(int, float);
// g是一个元素类型为函数指针的数组，所指向的函数接收俩个参数，分别是int型和float型，并返回一个int型的指针。
```



### 函数指针

函数也是一种类型，可以定义指向函数的指针。指针存储的是一个地址值，而函数指针存储的是一个函数的入口地址，因此函数指针可以作为参数传递或者返回函数指针类型。

```c
//定义一个函数类型Foo
typedef int Foo(void);

Foo foo_a, foo_b;
//相当于int foo_a(void); int foo_b(void);

Foo foo_c(void);
//错误的，因为foo_c函数返回一个函数类型

Foo* foo_d(void);
//正确的，因为返回的是一个函数指针类型，相当于返回函数的内存入口地址
```



声明一个函数指针并不意味着能立刻使用，和其他指针一样，对函数指针执行间接引用之前必须把它初始化为指向某个函数。

```c
// 声明
int f();
int (*pf)(int) = &f;

// 调用
int ans;
ans = f(10);
ans = (*pf)(10);	// 间接引用函数指针，转换为函数名
ans = pf(10);
```

函数名在被使用时，编译器总会把它转换成函数指针。

例如f()函数在执行时，函数名f会被转换成函数指针，该指针指定函数在内存中的位置，然后函数调用操作符调用该函数，执行该内存地址的代码。

而对函数指针执行间接访问操作，编译器会把函数指针转为一个函数名。



### 字符串常量

当一个字符串常量出现在表达式中，它的值就是一个指针常量。编译器会将这些字符存储在内存中的某个位置，并存储一个指向第一个字符的指针。

```c
"xzy" + 1;
// 字符串常量是一个指针，它表示在该指针上加1，因此指向第二个字符。

*"xzy";
// 对一个指针执行间接访问操作，结果是该指针所指向的内存，该表达式的结果是字符x。

"xzy"[1];
*("xzy" + 1);
// 上面俩个表达式是等价的。
```





### 指针与const

const与指针结合使用有几种情况：

```c
const int *a;
int const *a;
```

这俩种写法都一样，a是指向一个const int型的指针，a指向的内存单元是不可修改，所以(\*a)++报错，但是a++允许；意思就是a指针所指向的内存地址的值是不可以修改的，但是可以修改指针本身存储的内存地址。



```c
int * const a;
```

定义一个int型的const指针，*a可以被改写，但是a是不允许改写；

指针a存储的内存单元不可以修改，但是可以修改指针a指向的内存单元的值。



```c
int const * int a;
```

a是指向一个const int的const指针，*a和a都不可以被改写；无法修改指针存储的内存地址，也无法修改该指针指向的内存地址的值。



- 类型转换

  非const变量的指针或非const变量的地址可以传递给const变量的指针，编译器会自动转换，

  但是指向const变量的指针或const变量的地址不可以传递给非const变量的指针，避免意外改变const变量指针所指向的内存单元。

  ```c
  char c1 = 'a';
  char const * pc = &c1;
  
  char *c2 = &c1；
  char const * pc = c2;
  ```