### 指针变量

现在计算机将内存分割为字节，每个字节存储8位信息。每个字节都有唯一的地址，用以区分内存中的其他字节。如果内存中有n个字节，可以把地址看成是0到n-1的数。

可执行程序是由代码和数据（变量）组成，程序中的变量占用多个字节，把第一个字节的地址称为是变量的地址，而指针变量就是可以用于存储地址的变量。



- 指针变量的大小

  指针存储的是内存地址，因此在不同系统上的大小会有所不同。32位操作系统指针大小是4个字节大小，64位操作系统是8个字节大小。



### 声明与初始化

```c
int *pi;
```

pi是指针变量，表示指向int类型对象的指针变量。要注意，声明一个指针变量只是预留出存储空间，但是它没有指向对象。

C语言提供了俩个运算符来操作指针，&是取址运算符，获取一个变量的内存地址，可以为指针初始化。

```c
int i = 10;
int *pi = &i;
```

*是间接取址运算符，可以访问指针指向对象的内容。

```c
int i = 10;
int *pi = &i;

printf("%d", *pi);

*pi = 100;
printf("%d", i);	//100
```

可以认为*pi就是变量i的别名，它们不仅拥有相同的值，同时对\*pi的改变也会改变i的值。\*pi作为左值时间接访问指向对象的内存地址，所以是对变量 i 的赋值。



不要把间接寻址运算符用于未初始化的指针变量，如果指针变量没有初始化，访问指针变量或者是对指针对象赋值，都是很危险的行为。

```c
int i = 10;
int *pi;

printf("%d", *pi);	//wrong
```



### 指针运算符的优先级

指针运算符都是一元运算符，它们的优先级低于自增/自减运算符，比如：

```c
int a[5];
int *pa = a;

*pa++ = 10;
```

该表达式先执行pa++，然后再执行间接取址。由于是后缀++，只有在表达式计算出来后才可以自增，因此\*pa++的值是\*pa，即pa所指向的对象。







### 指针赋值

C语言允许用赋值运算符进行指针的赋值。

```c
int a = 5, b = 10;
int *pa = &a;

pb = pa;
```

比如把指针pa赋值给指针pb，就是把pa指向的地址赋值给pb。

```c
pb = pa;
*pb = *pa;
```

这俩个表达式是不同的，第一个表达式表示把pa指向对象的地址赋值给pb，也就是pa与pb都指向变量a。第二个表达式是把pb指向对象的值赋值给pa指向的对象。









永远不要返回自动局部变量的指针：

```c
function foo() {
    int i;
    return &i;
}
```

因为自动局部变量的声明周期是函数的整个执行期间，一旦函数执行完毕，该变量就被销毁了，所以指向变量i的指针就是无效了。



### 指针的算术运算

内存中的每个字节都是按顺序编号的，即按字节编址，而指针可以指向数组元素，因此指针支持算术运算。

指针支持三种算术运算：指针加上整数、指针减去整数和指针减去指针，比如有以下变量：

```c
int a[10], *p, *q, i;

p = &a[0];
q = p;
```



指针加上整数时，并不是使用地址加上整数，而是根据数组元素类型的字节大小，对这个整数进行换算后再进行计算。比如p指向数组元素a[i]，那么 p + j 指向a[i + j]。

```c
//访问下标2的元素
*(p + 2);

//对下标3的元素赋值
p = &a[2];
*(p + 1) = 10;	
```



当俩个指针相减时，结果为指针之间的距离，这个距离用元素个数来衡量而不是用字节数。比如q指向a[i]，p指向a[j]，那么$q - p$相当于$i -j$。

```c
p = &a[5];
q = &a[1];

i = p - q;	//i is 4
i = q - p;	//i is -1
```



指针也可以使用关系运算符（>, >=, <, <=）和判等运算符（!=, ==）进行比较，但是比较的指针都指向同一个数组才有比较的意义，比如：

```c
int a[10], result;

int *p = &a[5];
int *q = &a[1];

result = p <= q;	//result is 0
result = p > q;		//result is 1
```



### 指针的指针

一个指向指针类型的指针被称为指针的指针。

```c
int a = 10;
int *b = &a;
int **c = &b;
//变量a是一个整数，b是一个指向整型的指针，c是一个指向b的指针，所以它是一个指向整型的指针的指针。

b;
//等价于&a

*b;
//等价于a

c;
//等价于&b

*c;
//等价于b, &a

**c;
//等价于*b, a
```

\*c表达式访问c所指向的位置，即变量b，而\*(\*c)等价于\*b，即访问b所指向的位置，即访问变量a。



### void *

一种通用指针类型，该类型的指针可以用于转换成任何类型的指针，并且是隐式转换，void指针无法直接访问，必须转换成其他指针类型后才允许访问。

```c
void func(void *pc)
{
    char *pchar = pv;
    *pchar = 'A';
}

int main(void)
{
    char c;
    func(&c);
    printf("%c\n", c);
}
```



### 高阶声明

> int f();

f被声明为一个函数，它的返回值是整数。

> int *f();

先执行函数调用符()，因为()的优先级高于\*，所以f是一个函数，它的返回值是一个int型指针。

> int (*f)();

第一对小括号()使f成为一个函数指针，因为f是在函数调用之前进行间接引用，第二对小括号()是函数调用符。

> int  \*(\*f)();

该表达式与上个声明基本相同，f是一个函数指针，但是它的返回值是一个int型指针



与数组组合下的声明：

> int f[];

f是一个整型数组

> int *f[];

下标运算符的优先级高于间接引用运算符，因此f是一个数组，它的元素类型是指向int型的指针，所以f是一个指针数组。

> int (*f[])();

首先针对表达式*f[]求值，f是一个指针数组，表达式的末尾是函数调用操作符，所以f是一个元素类型为函数指针的数组，它的返回值是一个整型

> int \*(*f[])();

与上个表达式相同，不同的是返回值是一个int型的指针



example:

```c
int (*f)(int, float);
// f是一个函数指针，它所指向的函数接收俩个参数，分别是一个int型和float型，并返回一个整型值。

int *(*g[])(int, float);
// g是一个元素类型为函数指针的数组，所指向的函数接收俩个参数，分别是int型和float型，并返回一个int型的指针。
```



### 函数指针

函数也是一种类型，因此可以定义指向函数的指针。

声明一个函数指针并不意味着能立刻使用，和其他指针一样，对函数指针执行间接引用之前必须把它初始化为指向某个函数。

```c
// 声明
int f();
int (*pf)(int) = &f;
```

第一对括号是在第二对括号之前调用，它使pf称为一个函数指针，第二对括号是函数调用符号。



```c
int ans;
ans = pf(10);

ans = f(10);

//(*pf)会被转换为函数名再执行
ans = (*pf)(10);	
```

函数名在被使用时，编译器总会把它转换成函数指针。

例如f()函数在执行时，函数名f会被转换成函数指针，该指针指定函数在内存中的位置，然后函数调用操作符调用该函数，执行该内存地址的代码。

而对函数指针执行间接访问操作，编译器会把函数指针转为一个函数名。



### 指针与const

const与指针结合使用有以下几种情况：

```c
const int *a;
int const *a;
```

这俩种写法都一样，a是指向一个const int型的指针，a指向的内存单元是不可修改，所以(\*a)++报错，但是a++允许；意思就是a指针所指向的内存地址的值是不可以修改的，但是可以修改指针本身存储的内存地址。



```c
int * const a;
```

定义一个int型的const指针，*a可以被改写，但是a是不允许改写；

指针a存储的内存单元不可以修改，但是可以修改指针a指向的内存单元的值。



```c
int const * int a;
```

a是指向一个const int的const指针，*a和a都不可以被改写；无法修改指针存储的内存地址，也无法修改该指针指向的内存地址的值。



const指针的类型转换

非const变量的指针或非const变量的地址可以传递给const变量的指针，编译器会自动转换，

但是指向const变量的指针或const变量的地址不可以传递给非const变量的指针，避免意外改变const变量指针所指向的内存单元。

```c
char c1 = 'a';
char const * pc = &c1;

char *c2 = &c1；
char const * pc = c2;
```