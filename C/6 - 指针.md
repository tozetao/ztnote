## 指针

把一个变量的起始内存地址保存在另外一个内存单元中，保存地址的这个变量被称为指针。

- &：取址运算符，获取一个变量的内存地址
- *：用于定义指针类型，也可以用于取指针所指向变量的值

```c
int i = 10;
int *pi = &i;

char c = 'A';
//定义一个char型的指针，存储c变量的内存地址
char *pc = &c;

char *pi = *pi + 10;
//取pi
```

全局变量只能用常量表达式来初始化，&是取值运算符，配合变量使用就构成了一个表达式。例如&i，因为可以在编译阶段确定变量的内存地址，所以允许全局初始化



### 指针

指针就是一种存储内存地址的变量。

```c
int a = 10, b = 35;
float f = 3.15;

int *pa = &a;
int *pb = &b;
// pa变量存储的是a变量的起始内存地址
```



### 指针的类型

指针的类型决定编译器是如何解引用的，char型的指针，编译器在取值的时候会从指向的内存地址读取一个字节的数据，其他类型的数据同理。

```c
char c = 'a';
int i  = 100;

char *pc = &c;
int *pi = &i;

pi = (int *)pc;
//pi和pc都指向同一个地址，但是pi是int型指针，它会访问4个字节，除非你确定变量c和后面的3个字节组合而成的int是有效的，否则不能这样做
```



### 指针的大小

指针存储的是内存地址，因此在不同系统上的大小会有所不同。32位操作系统指针大小是4个字节大小，64位操作系统是8个字节大小。



### 未初始化指针

如果只是声明了指针，那么该指针指向一个未知的地址。

```c
int *a;
*a = 10;
//a指针虽然是int型，但是并未指向任何地址，因此对*a所指向的内存地址赋值会发生错误。
```

- NULL

  NULL主要用于表示某个指针并未指向任何东西，要使一个指针变量为NULL，可以给它赋值为0。

- NULL的定义

  定义在stddef.h头文件中，即把地址0转换成指针类型，叫做空指针；

  操作系统是不会把数据保存在0地址附近，也不会把0 - 0xffff的页面映射到物理内存，任何对地址0的访问都会直接抛出错误。

  ```c
  define NULL ((void *)0)
  ```

- 在定义指针时建议初始化确定的值或者初始化为NULL



###  间接访问运算符

符号*是间接访问运算符，作为右值时，表示访问指针指向的内存地址的值。作为左值时，由于间接访问的是指向的内存地址，因此会赋值到所指向的内存地址。

```c
int a = 5, b = 10, result = 0;
int *p;

//指针p指向a
p = &a;

//访问a的值
result = *p;

//对a进行赋值
*p = b;

//&a取出a的内存地址，*&a间接访问该内存地址，因此可以进行赋值。该表达式等价于*p（作为左值使用）
*&a = 25;
```



### 指针的指针

一个指向指针类型的指针被称为指针的指针。

```c
int a = 10;
int *b = &a;
int **c = &b;
//变量a是一个整数，b是一个指向整型的指针，c是一个指向b的指针，所以它是一个指向整型的指针的指针。

b;
//等价于&a

*b;
//等价于a

c;
//等价于&b

*c;
//等价于b, &a

**c;
//等价于*b, a
```

\*c表达式访问c所指向的位置，即变量b，而\*(\*c)等价于\*b，即访问b所指向的位置，即访问变量a。



### 指针运算

内存中的每个字节都是按顺序编号的，即按字节编址。而指针指向的是内存地址，因此是支持运算的。

指针运算常用于访问数组元素。



指针的算数运算支持俩种方式：

- 指针加减整数

  当一个指针与一个整数进行算数运算时，会根据指针类型的字节大小来进行换算。比如一个int型在内存中占用4个字节，那么一个int型指针加1表示该指针的内存地址后移4个字节。

  ```c
  int nums[3] = {1, 2, 3};
  printf("%p %p\n", nums, nums + 1);	//0x7ffdf9318880 0x7ffdf9318884
  ```

- 指针与指针的算术运算

  只有俩个指针都指向同一个数组中的元素时，才允许一个指针减另外一个指针。

  俩个指针相减的结果是俩个指针在内存中的距离，该距离是以数组类型的大小为单位，而非字节，因为运算的结果会除以数组元素类型的大小。

  ```c
  int nums[] = {4, 5, 56};
  printf("%d\n", (nums+2) - (nums+1));	//1
  ```



指针的关系运算只支持>、>=、 <、<=运算符，并且比较的指针是指向同一个数组中的元素。

example：指针关系运算的应用

```c
#define N_VALUES 5
float values[N_VALUES];
float *vp;

//&values[N_VALUES]是指向的内存地址是数组最后一个元素后移一位元素类型大小的地址
for(vp = &values[0]; vp < &values[N_VALUES];) {
    *vp++ = 0;
}

for(vp = &values[N_VALUES]; vp > &values[0];){
    *--vp = 0;
}
```



### void *

一种通用指针类型，该类型的指针可以用于转换成任何类型的指针，并且是隐式转换，void指针无法直接访问，必须转换成其他指针类型后才允许访问。

```c
void func(void *pc)
{
    char *pchar = pv;
    *pchar = 'A';
}

int main(void)
{
    char c;
    func(&c);
    printf("%c\n", c);
}
```





### example

```c
char ch = 'a';
char *cp = &ch;

// ch作为右值时是表达式的值，ch作为左值时是该变量的内存地址
// &ch作为右值时是ch变量的内存地址，作为左值时是非法的，当&ch表达式求值时，它的结果是需要存储在内存中的，然后这个表达式并未标识任何机器内存的特定位置，所以非法。

// cp作为左值时是cp所处的内存地址，作为右值时是cp的值
// &cp作为左值时非法，作为右值时表示cp变量的内存地址。
// *cp作为右值时表示访问cp所指向的位置，即变量ch，作为左值时表示cp指向的内存地址会把右边表达式的结果作为它的新值

*cp + 1;
// *cp获取变量ch的值a，加1后该表达式的结果为b
// 作为左值时是非法的，因为存储位置未定义，作为右值时表示b

*(cp + 1);
// cp是一个char型的指针，加1会把cp存储的地址进行相加，因此该表达式会指向ch变量下一个字节的内存地址。
// 该表达式的右值是这个位置的值，左值时内存地址本身。

++cp;
// 前缀++是先增加它的操作数再返回结果，该表达式的右值是增值后的指针的一份拷贝，作为左值时是非法的。

cp++;
// 后缀++是先返回值的一份拷贝，再对值进行自增操作，因此该表达式的右值是cp值的拷贝，作为左值是非法的。

*++cp;
// 间接访问操作符作用于增值后的指针的拷贝上，该表达式的右值是ch后面那个内存地址的那个值，左值是那个内存地址。

*cp++;
// 由于是后缀++，该表达式的右值是cp本身的拷贝，左值是cp指向的内存地址。

++*cp;
// 在该表达式中，操作符的结合性是从右向左的，所以先执行间接访问操作，然后cp的值增加1，表达式的结果是这个增值后的一份拷贝。
// 该表达式作为左值是非法的。
```



```c
++*++cp;
// 从右向左进行计算，++cp表示cp所指向的内存地址加1，*++cp则会取++cp所指向的内存地址的值，最后再进行++表示该内存地址的值加1
// 该表达式作为左值是非法的

++*cp++;
// 从右向左进行计算，cp++是先返回cp操作数再进行自增，*cp++会取cp所指向内存地址的值，最后再对*cp所指向的值进行前缀自增操作。
```



总结：

每个bit位都由一个地址标识，通常会将临近的多个bit位合并成一组，这样可以表示更大范围的数。而指针就是值是内存地址的变量。





## 高级指针

### 高阶声明

> int f();

f被声明为一个函数，它的返回值是整数。

> int *f();

先执行函数调用符()，因为()的优先级高于\*，所以f是一个函数，它的返回值是一个int型指针。

> int (*f)();

第一对小括号()使f成为一个函数指针，因为f是在函数调用之前进行间接引用，第二对小括号()是函数调用符。

> int  \*(\*f)();

该表达式与上个声明基本相同，f是一个函数指针，但是它的返回值是一个int型指针



与数组组合下的声明：

> int f[];

f是一个整型数组

> int *f[];

下标运算符的优先级高于间接引用运算符，因此f是一个数组，它的元素类型是指向int型的指针，所以f是一个指针数组。

> int (*f[])();

首先针对表达式*f[]求值，f是一个指针数组，表达式的末尾是函数调用操作符，所以f是一个元素类型为函数指针的数组，它的返回值是一个整型

> int \*(*f[])();

与上个表达式相同，不同的是返回值是一个int型的指针



example:

```c
int (*f)(int, float);
// f是一个函数指针，它所指向的函数接收俩个参数，分别是一个int型和float型，并返回一个整型值。

int *(*g[])(int, float);
// g是一个元素类型为函数指针的数组，所指向的函数接收俩个参数，分别是int型和float型，并返回一个int型的指针。
```



### 函数指针

函数也是一种类型，因此可以定义指向函数的指针。

声明一个函数指针并不意味着能立刻使用，和其他指针一样，对函数指针执行间接引用之前必须把它初始化为指向某个函数。

```c
// 声明
int f();
int (*pf)(int) = &f;
```

第一对括号是在第二对括号之前调用，它使pf称为一个函数指针，第二对括号是函数调用符号。



```c
int ans;
ans = pf(10);

ans = f(10);

//(*pf)会被转换为函数名再执行
ans = (*pf)(10);	
```

函数名在被使用时，编译器总会把它转换成函数指针。

例如f()函数在执行时，函数名f会被转换成函数指针，该指针指定函数在内存中的位置，然后函数调用操作符调用该函数，执行该内存地址的代码。

而对函数指针执行间接访问操作，编译器会把函数指针转为一个函数名。



### 指针与const

const与指针结合使用有以下几种情况：

```c
const int *a;
int const *a;
```

这俩种写法都一样，a是指向一个const int型的指针，a指向的内存单元是不可修改，所以(\*a)++报错，但是a++允许；意思就是a指针所指向的内存地址的值是不可以修改的，但是可以修改指针本身存储的内存地址。



```c
int * const a;
```

定义一个int型的const指针，*a可以被改写，但是a是不允许改写；

指针a存储的内存单元不可以修改，但是可以修改指针a指向的内存单元的值。



```c
int const * int a;
```

a是指向一个const int的const指针，*a和a都不可以被改写；无法修改指针存储的内存地址，也无法修改该指针指向的内存地址的值。



const指针的类型转换

非const变量的指针或非const变量的地址可以传递给const变量的指针，编译器会自动转换，

但是指向const变量的指针或const变量的地址不可以传递给非const变量的指针，避免意外改变const变量指针所指向的内存单元。

```c
char c1 = 'a';
char const * pc = &c1;

char *c2 = &c1；
char const * pc = c2;
```