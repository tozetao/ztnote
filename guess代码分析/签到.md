

首先应该有一个签到设置列表、签到活动时间



然后每个玩家保存着自己的一份签到数据。

玩家每天登陆时，要判断当前是能够领取第几天的奖品，也就是当前时间的零点 - 活动起始时间的零点 =  间隔的时间，

间隔的时间 / 24小时 = 间隔的天数，该天数 + 1，就是要领取的天数。



## 签到协议

### 1158（进行签到）



```protobuf
// 签到
// @name go_sign
message m_1158_tos{
}
message m_1158_toc{
    repeated  p_assets  reward = 1;//获得的奖励
}
```

这是1158协议使用的数据结构，1158是进行签到。



```erlang
%% 累计签到进行签到
handle(1158, _, Role = #role{acc_sign = Sign = #acc_sign{time = Time, day = Day, sign_time = SignTime}}) ->
    Now = date:unixtime(),
    
    %% 最后一次签到时间与当前时间是同一天，则表示已签到
    case date:is_same_day(Now, SignTime) of
        true -> 
            {false, ?error_act};
        _ ->
            case setting_mgr:get(?setting_acc_sign) of
                %% 同一个活动
                {ok, {Time, 1}} -> 
                    %% 这里应该时获取签到后台配置
                    List = get_acc_sign(),
                    
                    %% 寻找第X天的签到奖励
                    case lists:keyfind(Day + 1, #p_sign_reward.id, List) of
                        #p_sign_reward{list = Reward = [#p_assets{type = Type, num = Num}]} -> 
                            %% 领取奖励
                            {ok, NewRole} = role_lib:do_add(Role, [{Type, Num}]),
                            
                            %% 返回签到奖励数据，更新玩家结构
                            {ok, #m_1158_toc{reward = Reward}, NewRole#role{acc_sign = Sign#acc_sign{day = Day + 1, sign_time = Now}}};
                        _ -> {false, ?error_act}
                    end;
                _ ->
                    {false, ?error_act_time}
            end
    end;
```

进行签到的实现。









### 1157（签到信息）



```protobuf
message m_1157_toc {
	required uint32 day = 1;	// 已经签到天数
	required uint32 is_sign = 2;	// 今天是否签到
	repeated p_sign_reward list = 3;	// 每天的奖励信息
}

message p_sign_reward {
	required uint32 id = 1;	//第几天
	repeated p_assets list = 2;	//奖励列表
}
```

这是1157协议所的数据结构，1157就是累计签到协议。





```erlang
%% 累计签到信息
handle(1157, _, Role = #role{acc_sign = #acc_sign{time = Time, day = Day, sign_time = SignTime}}) ->
    case setting_mgr:get(?setting_acc_sign) of
        {ok, {Time, 1}} -> %% 同一个活动
            List = get_acc_sign(),
            Now = date:unixtime(),
            IsSign = case date:is_same_day(Now, SignTime) of
                true -> 1;
                _ -> 0
            end,
            {reply, #m_1157_toc{day = Day, is_sign = IsSign, list = List}};
        {ok, {Time1, 1}} ->  %% 活动变了
            List = get_acc_sign(),
            {ok, #m_1157_toc{day = 0, is_sign = 0, list = List}, Role#role{acc_sign = #acc_sign{time = Time1}}};
        _ -> 
            {false, ?error_act_time}
    end;
```

累计签到信息。







### 相关record

```erlang
-record(acc_sign, {
	time = 0,	%% 累计签到开始时间，用来作为key
	day = 0,	%% 累计签到的天数
	sign_time = 0,	%% 最后一次签到时间
}).
```

Role进程的acc_sign字段所对应的record。









如果按照目前实现的话，每个玩家需要保存一个签到列表，里面存储每一天的签到信息。

```erlang
[
	{}
].
```



这里面有个数据状态问题，就是如果后台更改了活动的数据，那么玩家的数据要怎么处理？

而且玩家又分为已经登陆的玩家和未登录的玩家。



活动不是有起始和结束时间么？

我们在获取签到接口那里坐下修改，获取的时候判断下活动是否发生更改，如果发生更改那么就替换成新的活动数据。

















需要看下管理后台签到时如何进行实现的。