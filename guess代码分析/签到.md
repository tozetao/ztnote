

首先应该有一个签到设置列表、签到活动时间



然后每个玩家保存着自己的一份签到数据。

玩家每天登陆时，要判断当前是能够领取第几天的奖品，也就是当前时间的零点 - 活动起始时间的零点 =  间隔的时间，

间隔的时间 / 24小时 = 间隔的天数，该天数 + 1，就是要领取的天数。



## 签到协议

### 1158（进行签到）



```protobuf
// 签到
// @name go_sign
message m_1158_tos{
}
message m_1158_toc{
    repeated  p_assets  reward = 1;//获得的奖励
}
```

这是1158协议使用的数据结构，1158是进行签到。



```erlang
%% 累计签到进行签到
handle(1158, _, Role = #role{acc_sign = Sign = #acc_sign{time = Time, day = Day, sign_time = SignTime}}) ->
    Now = date:unixtime(),
    
    %% 最后一次签到时间与当前时间是同一天，则表示已签到
    case date:is_same_day(Now, SignTime) of
        true -> 
            {false, ?error_act};
        _ ->
            case setting_mgr:get(?setting_acc_sign) of
                %% 同一个活动
                {ok, {Time, 1}} -> 
                    %% 这里应该时获取签到后台配置
                    List = get_acc_sign(),
                    
                    %% 寻找第X天的签到奖励
                    case lists:keyfind(Day + 1, #p_sign_reward.id, List) of
                        #p_sign_reward{list = Reward = [#p_assets{type = Type, num = Num}]} -> 
                            %% 领取奖励
                            {ok, NewRole} = role_lib:do_add(Role, [{Type, Num}]),
                            
                            %% 返回签到奖励数据，更新玩家结构
                            {ok, #m_1158_toc{reward = Reward}, NewRole#role{acc_sign = Sign#acc_sign{day = Day + 1, sign_time = Now}}};
                        _ -> {false, ?error_act}
                    end;
                _ ->
                    {false, ?error_act_time}
            end
    end;
```

进行签到的实现。

基础思路是从签到配置列表中，根据玩家需要签到的天数找出对应的签到奖励配置，然后增加玩家的道具，最后返回数据并更新玩家状态。







### 1157（签到信息）

```protobuf
message m_1157_toc {
	required uint32 day = 1;	// 已经签到天数
	required uint32 is_sign = 2;	// 今天是否签到
	repeated p_sign_reward list = 3;	// 每天的奖励信息
}

message p_sign_reward {
	required uint32 id = 1;	//第几天
	repeated p_assets list = 2;	//奖励列表
}
```

这是1157协议所的数据结构，1157就是累计签到协议。



```erlang
%% 累计签到信息
handle(1157, _, Role = #role{acc_sign = #acc_sign{time = Time, day = Day, sign_time = SignTime}}) ->
    case setting_mgr:get(?setting_acc_sign) of
        %% 跟acc_sign的time字段进行比较，判断是否同一个活动。time字段存储着签到活动的开始时间
        {ok, {Time, 1}} -> 
            List = get_acc_sign(),
            Now = date:unixtime(),
            IsSign = case date:is_same_day(Now, SignTime) of
                true -> 1;
                _ -> 0
            end,
            {reply, #m_1157_toc{day = Day, is_sign = IsSign, list = List}};
        %% 活动发生更改
        {ok, {Time1, 1}} ->  
            List = get_acc_sign(),
            {ok, #m_1157_toc{day = 0, is_sign = 0, list = List}, Role#role{acc_sign = #acc_sign{time = Time1}}};
        _ -> 
            {false, ?error_act_time}
    end;
```

累计签到信息。

在获取玩家签到信息时，有俩种情况。

一种是活动发生更改，这时会返回修改过的签到列表信息，并更新玩家ass_sign record的time字段（即更新活动开始时间）。

一种是活动未发生改变，这种会返回玩家累计的签到天数，以及当前活动的签到列表。







### 相关record

```erlang
-record(acc_sign, {
	time = 0,	%% 累计签到开始时间，用来作为key
	day = 0,	%% 累计签到的天数
	sign_time = 0,	%% 最后一次签到时间
}).
```

Role进程的acc_sign字段所对应的record。



```protobuf
message m_1157_toc {
	repeated p_sign_reward list = 1;	// 玩家的签到列表
}

message p_sign_reward {
	required uint32 id = 1;	//第几天
	repeated p_assets list = 2;	//奖励列表
}
```

1157协议的proto



```protobuf
// 签到
// @name go_sign
message m_1158_tos{
}
message m_1158_toc{
    repeated  p_assets  reward = 1;//获得的奖励
}
```

1158协议的proto







如果按照目前实现的话，每个玩家需要保存一个签到列表，里面存储每一天的签到信息。

```erlang
[
	{Day, IsSign}
].
```

Day：第几天签到。

IsSign：是否签到

Type：道具类型

Num：道具数量



- 签到要求能够循环。

- 要求能够关闭签到。



28类型字段有：活动开始、结束时间、开启状态、更改时间。

假设不加入start_time、end_time





需求

重启活动，玩家的所有签到数据都会重置。

未签到的天数不能再次领取道具。

最好能够循环开启。



进行签到：

签到配置列表



三个条件判断：

活动是否发生重启

活动是否开启

签到天数是否产出（活动是否结束）



玩家数据结构：

#acc_sign{updated_at, list = [{day, is_sign}, {day, is_sign}, , {day, is_sign}, {day, is_sign}]}



签到配置列表：

[#p_sign_reward{}]

签到状态：

{started_at, status}



要修改1157协议响应结构。









- 当前应该签第几天，这个要计算出来

  这个签第几天，不是由玩家决定，而是跟时间有关系。

  当前时间与活动的开始时间相隔的天数，就是第几天要签到。

- 超出天数

  超出天数就是超出签到的活动时间了，这时候应该停止签到。

























role record的var字段。

表示当前role record的最新版本，玩家的数据下线后是会存储在dets中的。

如果你代码中修改了role record的结构，这时dets存储的role record与新定义的role record字段不一致，那么从dets中读取的role数据就会出错。

因此需要进行更新，在role_var.erl增加新的版本方法，并且将role record的var字段改为最新的版本。

