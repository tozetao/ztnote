### record

```erlang
-record(treasure, {
         id = 0           %% 道具唯一id
        ,type = 1         %% 道具类型（游戏里面道具才用）
        ,treasure_num = 1 %% 夺宝期数
        ,sub_type = 1     %% 道具分类（0游戏道具，1自定义道具）
        ,price = 1        %% 总价格
        ,num = 1          %% 道具数量
        ,icon = ""        %% 道具图标
        ,name = ""        %% 道具名字
        ,desc = ""        %% 道具描述
        ,buy_price = 1    %% 单个价格，即购买金额
        ,buy_type = 1     %% 夺宝类型，即购买金额的类型
        ,buy_num = 0      %% 夺宝次数
        ,all_num = 0      %% 总次数
        ,now_treasure_num = 0  %% 当前夺宝编号
        ,list = []        %% 夺宝码
        ,role_list = []   %% 参与夺宝的人物信息
        ,on_sale = 0      %% 是否上架
        ,condition = 0     %% 0没有，1特惠，2vip，3秒杀, 4限时
        ,vip = 0          %% vip需求
        ,old_price = 0    %% 原价格
        ,start_time = 0   %% 开始时间
        ,end_time = 0     %% 结束时间
        ,stock = -1        %% 库存
    }
).
```

now_treasure_num：当前夺宝编号？预计是用于开奖的。

all_num：总购买次数

buy_num：夺宝次数

role_list：一个列表，存储参与的玩家信息

list：夺宝码，跟玩家怎么对应的???



重点关注这4个字段。



```erlang
-record(treasure_log, {
        id = {0, 0}   %% 期数，类型
        ,time = 0     %% 开奖时间
        ,role_id = 0  %% 中奖id
        ,name = ""    %% 中奖名字
        ,icon = ""
        ,luck_num = 0 %% 幸运号码
    }
).
```

夺宝参与日志record。



```erlang
-record(role_treasure_log, {
        id = {0, 0}   %% 唯一id, 期数
        ,buy_time = 0 %% 购买时间
        ,time = 0     %% 开奖时间
        ,luck_num = 0 %% 幸运号码
        ,num_list = [] %% 夺宝码列表
    }
).
```





ets

- treasure表

  存储treasure记录。每个对象存储的是商品正在开奖的状态。

- treasure_log表

  存储treasure_log记录。即中奖记录。

dets

在磁盘上存储这俩张表的记录，关服的时候会存储到磁盘中。





### init

```erlang
init([]) ->
    process_flag(trap_exit, true),
    
    %% 从dets加载treasure、treasure_log俩张表到ets中
    ets:new(treasure, [set, named_table, public, {read_concurrency, true}, {keypos, #treasure.id}]),
    dets:open_file(treasure, [{file, "./dets/treasure.dets"},  {keypos, #treasure.id}, {type, set}]),
    ets:from_dets(treasure, treasure),
    
    ets:new(treasure_log, [set, named_table, public, {read_concurrency, true}, {keypos, #treasure_log.id}]),
    dets:open_file(treasure_log, [{file, "./dets/treasure_log.dets"},  {keypos, #treasure_log.id}, {type, set}]),
    ets:from_dets(treasure_log, treasure_log),
    
    %% 1秒后向自己发送一个reload消息
    erlang:send_after(1000, self(), reload),
    
    State = #state{},
    {ok, State}.
```

初始化ets表，并重载夺宝商品。



### reload

在服务启动的时候，重载商品数据。

```erlang
handle_info(reload, State) ->
    reload(),
    {noreply, State}.

reload() ->
    case db:get_all("select * from treasure_item") of
        {ok, List} ->
            do_reload(List);
        _ ->
            ok
	end.

%% Info是mysql表的一行记录，erlang以一个列表来存储一行记录
do_reload([]) -> ok;
do_reload([Info = [Id | _], L]) ->
    case get_item(Id) of
        {ok, T = #treasure{}} ->
            do_change(T, Info);
        _ ->
            new_treasure(Info);
	end,
    do_reload(L).
```

查询数据库的所有商品记录，同步到ets表中。同步时有俩种情况：

- 已存在ets表中，需要同步ets表与mysql表，并添加到夺宝中
- 不存在ets表中，新增到ets表，再添加到夺宝中



### do_change

mysql表与ets表的同步

```erlang
%% 从ets表取出的数据与mysql表的数据不一致，因此要进行同步，
do_change(T = #treasure{on_sale = _OnSale1}, [Id, Type, Icon, Name, Desc, Num, Price, BuyType, BuyNum, OnSale, SubType, Condition, Vip, OldPrice, StartTime, EndTime, Stock]) ->
    %% 计算该商品的夺宝总次数
    AllNum = get_all_num(Price, BuyType, BuyNum),
    
    %% 新的treasure
    Treasure = T#treasure{id = Id, type = mail_mgr:to_atom_assets(Type), sub_type = SubType, price = Price, num = Num, icon = Icon, name = Name, desc = Desc, buy_price = BuyNum, buy_type = mail_mgr:to_atom_assets(BuyType), all_num = AllNum, now_treasure_num = init_treasure_num(Id), on_sale = OnSale, condition = Condition, vip = Vip, old_price = OldPrice, start_time = StartTime, end_time = EndTime, stock = Stock},
    
    %% 如果上架就插入到ets表中
    case OnSale of
        1 ->
            ets:insert(treasure, Treasure),
            ?MODULE ! {add_item, Treasure};
        _ ->
            ?MODULE ! {delete_item, Treasure}
    end.

%% 初始化夺宝码
init_treasure_num(Type) ->
    Type * 100000.

%% 根据商品价格，购买金额来计算总夺宝次数
%% Price：商品价格，单位元
%% BuyNum：购买金额，它的单位就是它的购买类型。比如说100红包
get_all_num(Price, BuyType, BuyNum) ->
    %% 获取购买金额的类型，可能是金币、红包、钻石
    Type = mail_mgr:to_atom_assets(BuyType),
    
    %% 根据购买金额的类型，计算出该类型和人民币元的比例
    Price1 = get_type_price(Type),
    
    %% 商品总价格 / 购买金额对应的人民币
    util:ceil(Price / (Price1 * BuyNum)).
```



### new_treasure

新增到ets表，与do_change()相同，区别在于不需要删除夺宝信息，即执行delete_item消息的处理。



### add_item消息

夺宝商品进程的State存储了当前夺宝商品的信息，State是一个#state记录。

```erlang
#state{list = []}
```

add_item消息新增一个夺宝商品，代码如下：

```erlang
%% 新上架物品
handle_info({add_item, Info = #treasure{id = Id, stock = Stock, condition = Condition, end_time = End}}, State = #state{list = List}) when Stock =/= 0->
    % 如果在State列表中能找到夺宝商品，那么替换掉它，否则加入到State中。
    NewList = case lists:keyfind(Id, #treasure.id, List) of
        T = #treasure{} -> 
            Treasure = do_treasure_change(Info, T),
            lists:keyreplace(Id, #treasure.id, List, Treasure);
         _ ->
            [Info | List]
    end,
    
    case Condition of   
        %% 4是限时开奖
        4 -> 
            Now = date:unixtime(),
            %% 结束时间大于当前时间，意味着还未到开奖时间，End-Now是剩余开奖时间。
            case End > Now of
                true ->
                    Ref = erlang:send_after((End - Now) * 1000, self(), {open_time, Id}),
                    put({time_open, Id}, Ref);
                _ ->
                    %% 立即开奖
                    erlang:send_after(1, self(), {open_time, Id})
            end;
        _ -> ok
    end,
    {noreply, State#state{list = NewList}};
```



open_time

限时开奖处理。

```erlang
handle_info({open_time, Id}, State = #state{list = List}) ->
    %% 从State中寻找夺宝商品(#treasure记录)，且夺宝码列表(list)不等于空列表，即有人参与
    NewState = case lists:keyfind(Id, #treasure.id, List) of
        Treasure = #treasure{role_list = RoleList, list = TreasureList, treasure_num = TreasureNum, sub_type = SubType, buy_num = BuyNum, all_num = AllNum} when TreasureList =/= [] -> 
			%% 夺宝商品id * 100000                       
            Start = init_treasure_num(Id),
			%% Start + 夺宝总次数 - 1
            End = Start + AllNum - 1,
			
            %% Num应该是随机码了
            Num = sys_rand:rand(Start, End),
			
            %% 从夺宝码列表中寻找中奖玩家
            {RoleId, Name, Icon, {Add, PName, Phone}} = case lists:keyfind(Num, 1, TreasureList) of
				%% 有中奖玩家
                {Num, RoleId0} ->
					%% 从玩家列表里面找到信息
                    case lists:keyfind(RoleId0, 1, RoleList) of
                        false -> {0, "", "", {"", "", ""}};
                        _Info -> _Info
                    end;
				%% 没有中奖玩家
                _ -> {0, "", "", {"", "", ""}}
            end,

            %% 生成夺宝中奖日志
            Log = #treasure_log{id = {TreasureNum, Id}, time = date:unixtime(), role_id = RoleId, name = Name, icon = Icon, luck_num = Num},
                       
            %% SubType：0游戏道具，1自定义道具。
			%% Status标记
            Status = case SubType of
                0 -> 1;
                _ -> 0
            end,
            do_reward(Treasure, RoleId, TreasureNum, Num),
            log_db:log(treasure_reward_log, insert, [Id, TreasureNum, BuyNum, Num, RoleId, Status, Add,  PName, Phone, date:unixtime()]),
            ets:insert(treasure_log, Log),
            NewTreasure = Treasure#treasure{treasure_num = TreasureNum + 1, role_list = [], list = [], buy_num = 0, now_treasure_num = init_treasure_num(Id)},
            ets:insert(treasure, NewTreasure#treasure{on_sale = 0}),             %% 下架
            db:exec("update treasure_item set on_sale = 0 where id = ?", [Id]),
            NewList = lists:keydelete(Id, #treasure.id, List),
            State#state{list = NewList};
        _ ->
            State
    end,
    {noreply, NewState};
```



 



### delete_item消息





### terminate

```erlang
terminate(_Reason, _State) ->
    ets:to_dets(treasure, treasure),
    ets:to_dets(treasure_log, treasure_log),
    ok.
```

分别将ets俩张表的数据存储到磁盘中。









期数是在哪里发生改变的？

role_lib的send_buffer做什么用的?









role_lib.erl

send_buff_begin()

send_buff_flush()

这个有什么用处？