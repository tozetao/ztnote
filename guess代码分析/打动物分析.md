### 模块文件

动物园模快有以下文件：

- animal_rpc.erl

  动物园协议入口文件。

- animal_mgr.erl

  动物园管理进程文件。

- animal.erl











### 打动物

```erlang
%% 打动物
hit(Role = #role{role_id = RoleId, status = ?status_zone, room_pid = Pid, room_type = Type, use_coin = CoinLev, skill_list = SkillList, luck_num = LuckNum, animal_flag = Flag, guide_task = #guide_task{id = TaskId}}, Id, Coin) when is_pid(Pid)->
    Min = get_min_coin(Type, TaskId),
    {Max, _, _} = zoo_room_power_setting:get_data(CoinLev),
    NewCoin = case lists:keyfind(rage, #role_skill.type, SkillList) of
        #role_skill{effect = Effect} ->
            trunc(Coin/Effect);
        _ ->
            Coin
    end,
    case NewCoin >= Min andalso NewCoin =< Max of
        true ->
            role_lib:send_buff_begin(),
            case role_lib:do_cost_coin(Role, Coin) of
                {ok, NewRole} ->
                    case catch gen_server:call(Pid, {hit, RoleId, Id, Coin, LuckNum, Flag}) of
                        {ok, HitList, List, NewLuck} ->
                            
                            {ok, NewRole1} = role_lib:do_add(NewRole, List),
                            NewRole2 = do_bonus(HitList, NewRole1, 0),
                            role_lib:send_buff_flush(),
                            case Flag of
                                99 -> ok;
                                _ ->
                                    animal_account_mgr:update_animal_pw(Coin, List)
                            end,
                            NewRole3 = task:handle(NewRole2, animal_die, Type, HitList),
                             
                            NewRole4 = do_daily_kill(NewRole3, List),
                            NewRole5 = task:do_pet_task(NewRole4,4, HitList ),
                            {ok, NewRole5#role{luck_num = NewLuck}};
                        ok ->
                            role_lib:send_buff_flush(),
                            case Flag of
                                99 -> ok;
                                _ ->
                                    animal_account_mgr:update_animal_pw(Coin, 0)
                            end,
                            {ok, NewRole};
                        {false, Reason} -> 
                            role_lib:send_buff_clean(),
                            {false, Reason};
                        _ -> 
                            role_lib:send_buff_clean(),
                            {false, ?error_busy}
                    end;
                _ ->
                    role_lib:send_buff_clean(),
                    {false, ?error_coin}
            end;
        _ ->
            {false, ?error_act}
    end;
hit(_, _, _) ->
    {false, ?error_act}.
```

这是打动物的主体逻辑。

Role参数是玩家结构，即玩家进程的Role状态。



## 房间管理进程

animal_mgr.erl是房间管理进程，它会随着游戏启动时而启动。它的结构体如下：

```erlang
-record(state, {
	id = 0,
	list = []
}).
```

- id：房间id，用于标识房间
- list：一个元组列表，键是房间类型，值是房间列表





### 房间管理进程初始化

```erlang
init([]) ->
    ?INFO("[~w] 正在启动", [?MODULE]),
    process_flag(trap_exit, true),
    erlang:process_flag(min_bin_vheap_size, 1024*1024),
    erlang:process_flag(min_heap_size, 1024*1024),
    erlang:process_flag(priority, high),
    State = #state{},
    ?INFO("[~w] 启动完成", [?MODULE]),
    {ok, State}.
```

只是把自己设置为系统进程，并调整了进程优的先级和堆大小。





### 创建房间进程

```erlang
start_room(Type, Id) ->    
    case catch animal:start_link(Type, Id) of        
        {ok, Pid} ->            
            #animal_room{id = Id, type = Type, num = 1, pid = Pid};        
        _ ->            
            false    
    end.
```

创建一个房间进程，Type是房间类型，Id是房间标识，这里管理进程创建房间进程时会建立一个链接关系。









### 进入房间

寻找可以加入的房间由房间管理进程来负责。

```erlang
%% 进入房间
%% Role：玩家结构，use_coin是炮等级，guide_task是新手指引任务；Type：房间类型
enter_room(Role = #role{status = ?status_normal, use_coin = Coin, guide_task = #guide_task{id = TaskId}}, Type) ->
    %% 获取房间最小炮值
    Need = animal:get_min_coin(Type, TaskId),
    %% 获取炮等级的消耗金币
    {Max, _, _} = zoo_room_power_setting:get_data(Coin),
    
    %% 这里应该是判断玩家的最大炮值是否大于房间要求的最小炮值
    case Max >= Need of
        true ->
            %% 寻找一个可以加入的房间
            case catch gen_server:call(?MODULE, {get_room_pid, Type, TaskId}) of
                {ok, Pid} ->
                    %% 向房间进程发生一个enter信息
                    case catch gen_server:call(Pid, {enter, role_conver:to_animal_role(Role)}) of
                        {ok, Data} ->
                            {ok, Data, Role#role{room_type = Type, room_pid = Pid, status = ?status_zone}};
                        _Err ->
                            {false, ?error_busy}
                    end;
                _Err ->
                    {false, ?error_busy}
            end;
        _ ->
            {false, ?error_act}
    end;
enter_room(_, _) ->
    {false, ?error_act}.
```

房间是有不同类型的。每种房间的最低炮值是不一样的，因此在玩家进入房间时会检查玩家已解锁的最大炮值。

接着寻找一个可以加入的房间，其实就是一个房间进程。在找到房间进程后，就会向房间进程发送一条enter消息，同时把玩家数据传递过去，由该房间进程处理玩家信息。



寻找一个可以加入的房间代码：

```erlang
handle_call({get_room_pid, Type, _}, _From, State = #state{id = NextId, list = List}) ->
    %% 根据房间类型寻找对应的房间列表
    case lists:keyfind(Type, 1, List) of
        {Type, RoomList} ->
            case find_room(RoomList) of
                %% 找到空位房间
                Room = #animal_room{id = Id, pid = Pid, num = Num} ->
                    NewList = lists:keydelete(Id, #animal_room.id, RoomList),
                    NewList1 = [Room#animal_room{num = Num + 1} | NewList],
                    {reply, {ok, Pid}, State#state{list = lists:keyreplace(Type, 1, List, {Type, NewList1})}};
                %% 未找到空位房间
                _ ->
                    case start_room(Type, NextId) of
                        Room = #animal_room{pid = Pid} ->
                            NewList = [Room | RoomList],
                            {reply, {ok, Pid}, State#state{id = NextId + 1, list = lists:keyreplace(Type, 1, List, {Type, NewList})}};
                        _ ->
                            {reply, false, State}
                    end
            end;
        _ ->
            %% 开启一个房间
            case start_room(Type, NextId) of
                Room = #animal_room{pid = Pid} ->
                    {reply, {ok, Pid}, State#state{id = NextId + 1, list = [{Type, [Room]} | List]}};
                _ ->
                    {reply, false, State}
            end
    end;
```

房间管理进程的State存储了房间列表。

首先寻找空位房间，如果找不到则创建房间进程，再加入到房间管理进程State的列表中；

如果寻找到可用房间进程，会判断房间是否满人。房间如果不满人，那么加入房间并更新房间列表。房间满人则新创建房间，加入到房间列表。









## 房间进程

animal.erl是房间进程，它的记录结构如下：

```erlang
-record(state, {
    id = 0,
    type = 0,			%% 房间类型
    role_list = [],		%% 玩家列表
    animal_list = [],	%% 动物列表
    pre_list = [],		%% 动物预警列表
    skill = [],
    num = 1,			%% 动物id，从1开始
    guide_task = 0
}).
```

- id

  房间id，房间的标识

- type

  房间类型

- role_list

  玩家列表

- animal_list

  产生的动物列表

- pre_list

  动物预警列表

- num

- guide_task

它的初始化如下：

```erlang
init([Type, Id]) ->
    State = case Type of
        {Type1, TaskId} ->
            #state{id = Id, type = Type1, guide_task = TaskId};
        _ ->
            #state{id = Id, type = Type}
    end,
    NewState = do_init(State),
    process_flag(trap_exit, true),
    erlang:send_after(1000, self(), check_animal_out),
    {ok, NewState}.

```

Id是房间标识，Type是房间类型。

在初始化会向自身发送一条check_animal_out消息，用于检查动物退出。主要的初始化逻辑在do_init函数中，该函数会调用init_animal()函数，主要用于产生动物。



```erlang
%% 批量产生动物
init_animal(0, State) -> State;
init_animal(N, State = #state{animal_list = List, role_list = RoleList, num = Num, pre_list = PreList, type = Type, guide_task = TaskId}) ->
    {PushList, NewList, NewNum, PreList1} = init_animal(N, [], List, Num, RoleList, PreList, Type, TaskId),
    push_animal_enter(PushList, RoleList),
    NewState = State#state{animal_list = NewList, num = NewNum, pre_list = PreList1},
    NewState.
```



init_animal()函数是初始化动物路线，在根据动物的出现概率随机产生一只动物，在初始化路线、爆率等属性。

List1是要推送的动物列表。

List是产生的动物列表。

Num是产生动物的数量。

PreList是预警的动物列表，每个元素都是animal_base记录结构。

```erlang
init_animal(0, List1, List, Num, _, PreList, _Type, _) -> {List1, List, Num, PreList};
init_animal(N, List1, List, Num, RoleList, PreList, Type, TaskId) ->
    %% 随机产生一只动物
    Animal = #animal_base{base_id = BaseId, rate = [Min, Max]} = get_one_annimal(PreList ++ List, TaskId),
    
    %% 随机出倍率
    Rate = sys_rand:rand(Min, Max),
    
    RedBag = create_red_bag(Type, BaseId),
    
    %% 初始化路线
    #animal_route{id = RouteId, time = AllTime, post = Post, xy = XY} = init_animal_route(),
    
    %% 预警动物与非预警动物的俩种处理
    case lists:member(BaseId, ?animal_pre_notice_list) of
        true ->
            NewAnimal = Animal#animal_base{id = Num, end_time = AllTime, post = 0, route_id = RouteId, xy = XY, red_bag = RedBag, rate = Rate},
            push_pre_animal(BaseId, RoleList),
            erlang:send_after(3000, self(), {add_animal, NewAnimal}),   %% 预警动物之后再加载
            init_animal(N -1, List1, List, Num + 1, RoleList, [NewAnimal | PreList], Type, TaskId);
        _ ->
            %% 赋值Animal的路线值、倍率等变量，最后加入到列表中。
            NewAnimal = Animal#animal_base{id = Num, end_time = AllTime, post = Post, route_id = RouteId, xy = XY, red_bag = RedBag, rate = Rate},
            init_animal(N -1, [NewAnimal | List1], [NewAnimal| List], Num + 1, RoleList,  PreList, Type, TaskId)
    end.
```

房间进程创建时会初始化一批动物出来。

- List1

  要推送的动物列表

- List

  第一次初始化的值是动物列表

- PreList

  预警动物列表



随机产生一只动物。

- List参数

  动物列表和预警列表合并的列表。

```erlang
get_one_annimal(List, _TaskId) ->
    %% OnlyList是只允许出现一次的动物列表，这里面的动物就不要再产生了。
    OnlyList = [Id || #animal_base{base_id = Id} <- List, lists:member(Id, ?animal_only_one_list)],

    %% 允许出现的动物列表
    NewList = [A||A = #animal_base{base_id = Id} <-get_animal_base(), not lists:member(Id, OnlyList)],

    %% 根据动物的出现概率，随机产生一只动物
    case sys_rand:rand_list(NewList, #animal_base.pre) of
        %% 如果是同类型炸弹人，那么会随机产生一只炸弹类型的动物。
        Animal = #animal_base{base_id = type_bomber, bomber_type = List1} ->
            Type = sys_rand:rand_list(List1),
            #animal_base{rate = Rate} = lists:keyfind(Type, #animal_base.base_id, get_animal_base()),
            Animal#animal_base{bomber_type = Type, rate = Rate};
        _Animal -> _Animal
    end.
```

产生一只动物的逻辑是：

- 从已产生的动物列表、预警列表里面找出只允许出现一次的动物，OnlyList就是寻找的结果，这个列表里面的动物是不允许再次产生的。
- 获取整个动物列表配置，从中排除已出现过的只允许出现一次的动物，得到一个可以随机出动物的列表，即第二行代码。
- 根据动物产生的概率，随机出一只动物。animal_base的pre字段表示产生的概率。















### 加入房间

房间管理进程在为玩家寻找到合适的房间进程后，就会向其发送一条加入信息，将玩家加入到房间中。

以下是加入房间的代码，主要逻辑是把玩家信息加入到进程的玩家列表中，再向其他人推送进入消息。

```erlang
%% 玩家进入
handle_call({enter, Role = #animal_role{role_id = RoleId}}, _From, State = #state{type = Type, role_list = RoleList, animal_list = AnimalList}) ->
    %% 将当前玩家加入房间玩家列表中
    NewList = lists:keystore(RoleId, #animal_role.role_id, RoleList, Role),

    %% 向其他玩家推送进入消息
    push_in(Role, RoleList),
    
    %% 转换成响应给前端的数据格式
    NewList1 = to_p_animal_role(NewList),
    NewList2 = to_p_animal(AnimalList),
    
    Data = #m_1301_toc{animals = NewList2, role_list = NewList1, type = Type},
    {reply, {ok, Data}, State#state{role_list = NewList}};
```



以下是向其他玩家推送有玩家进入房间，代码逻辑很简单，List是要推送的玩家列表，Role是进入房间的玩家。

```erlang
%% 推送玩家进入
push_in(Role = #animal_role{}, List) ->
    Role1 = to_p_animal_role(Role),
    [sys_conn:pack_send(Pid, 1307, #m_1307_toc{role = Role1})||#animal_role{socket_pid = Pid} <-List].
```







### 其他结构体





```erlang
-record(animal_room, {
    id = 0,
    type = 0,
    num = 0,
    pid			%% 房间进程id
}).
```

房间信息。存储人数和房间进程pid，由房间管理进程使用。

- pid：房间进程id
- num：



```erlang
-record(animal_role, {
    role_id = 0,
    pid,		%% 房间进程pid
    socket_pid,	%% 连接进程pid
    skill_id = [],
    effect = 1,		%% 狂暴倍数
    vip_effect = 0	%% vip特效
}).
```

房间人物信息。





```erlang
-record(animal_base, {
    id = 0,		%% 唯一id
    base_id = 0,	%% 基础id，其实就是动物类型
    name,		%% 动物名字

    rate = 0,	%% 倍率
    pre = 0,	%% 出现概率

    end_time = 0,	%% 剩余总步数
    post = 0,		%% 当前位置
    xy = {0, 0},		%% 当前坐标

    is_notice = 0,		%% 0不广播，1广播
    status = 0,			%% 0正常，1冰冻
    drop_item = [],		%% 掉落列表
    item_list = [],		%% 可以掉落的列表
    red_bag = 0,		%% 是否有红包
    bomber_type = 0,	%% 同类型炸弹类型

    self_id = 0,		%% 私有大象人物id
    self_name = 0,		%% 私有大象人物名字
})
```

动物基本信息







### 房间类型

```erlang
get_min_coin(civilian, _) -> 5;
get_min_coin(petty, _) -> 100;
get_min_coin(rich, _) -> 1000;
get_min_coin(gold, _) -> 10000;
get_min_coin(diamond, _) -> 20000;
get_min_coin(ticket, _) -> 1000;
get_min_coin(single, TaskId) ->
    case TaskId =< 5 of
        true -> 5;
        _ -> 1000
    end.
```





问题：

动物的路线是怎么处理的？

房间进程的animal_list和pre_list在后续是怎么处理的???

