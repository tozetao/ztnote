## 模块文件

动物园模快有以下文件：

- animal_rpc.erl

  动物园协议入口文件。

- animal_mgr.erl

  动物园管理进程文件。

- animal.erl





## 协议文件



### 进入动物园

```erlang
handle(1301, #m_1301_tos{type = Type}, Role = #role{role_id = _RoleID}) ->
    case animal_mgr:enter_room(Role, Type) of
        {ok, Data, NewRole} ->
            {ok, Data, NewRole};
        {false, Reason} ->
            {false, Reason}
    end;
```





### 退出动物园



### 打动物

```erlang
handle(1303, #m_1303_tos{id = Id, coin = Coin}, Role = #role{hit_num = Num}) ->
    case animal:hit(Role, Id, Coin) of
        {ok, NewRole} ->
            case Coin < 1000 of
                true ->
                    {ok, #m_1303_toc{}, NewRole#role{hit_num = Num + 1}};
                _ ->
                   {ok, #m_1303_toc{}, NewRole}
            end;
        {false, Reason} ->
            {false, Reason}
    end;
```

- Id：动物Id
- Coin：炮值，消耗的金币值

该协议主要调用animal房间进程来处理玩家打动物。









## animal_mgr进程

animal_mgr.erl是房间管理进程，它会随着游戏启动时而启动。它的state如下：

```erlang
-record(state, {
	id = 0,
	list = []
}).
```

- id：房间id，用于标识房间

- list

  一个元组列表，键是房间类型，值是房间列表。

  类似 [{Type, [Room...]}, {Type, [Room...]}]，Room是animal_room record







### 初始化

```erlang
init([]) ->
    ?INFO("[~w] 正在启动", [?MODULE]),
    process_flag(trap_exit, true),
    erlang:process_flag(min_bin_vheap_size, 1024*1024),
    erlang:process_flag(min_heap_size, 1024*1024),
    erlang:process_flag(priority, high),
    State = #state{},
    ?INFO("[~w] 启动完成", [?MODULE]),
    {ok, State}.
```

只是把自己设置为系统进程，并调整了进程优的先级和堆大小。



### get_room_pid

get_room_pid消息是从进程状态的房间列表中，根据房间类型寻找到一个可以加入的房间（房间进程）。

代码如下：

```erlang
handle_call({get_room_pid, Type = single, TaskId}, _From, State = #state{id = NextId}) ->
    case start_room({Type, TaskId}, NextId) of
        #animal_room{pid = Pid} ->
            {reply, {ok, Pid}, State#state{id = NextId + 1}};
        _ ->
            {reply, false, State}
    end;


handle_call({get_room_pid, Type, _}, _From, State = #state{id = NextId, list = List}) ->
    %% 根据房间类型寻找对应的房间列表
    case lists:keyfind(Type, 1, List) of
        {Type, RoomList} ->
            case find_room(RoomList) of
                %% 找到空位房间
                Room = #animal_room{id = Id, pid = Pid, num = Num} ->
                    NewList = lists:keydelete(Id, #animal_room.id, RoomList),
                    NewList1 = [Room#animal_room{num = Num + 1} | NewList],
                    {reply, {ok, Pid}, State#state{list = lists:keyreplace(Type, 1, List, {Type, NewList1})}};
                %% 未找到空位房间
                _ ->
                    case start_room(Type, NextId) of
                        Room = #animal_room{pid = Pid} ->
                            NewList = [Room | RoomList],
                            {reply, {ok, Pid}, State#state{id = NextId + 1, list = lists:keyreplace(Type, 1, List, {Type, NewList})}};
                        _ ->
                            {reply, false, State}
                    end
            end;
        _ ->
            %% 开启一个房间
            case start_room(Type, NextId) of
                Room = #animal_room{pid = Pid} ->
                    {reply, {ok, Pid}, State#state{id = NextId + 1, list = [{Type, [Room]} | List]}};
                _ ->
                    {reply, false, State}
            end
    end;


```

寻找可以加入房间的主体逻辑。



```erlang
%% 寻找有空位的房间
find_room([]) -> false; 
find_room([Room = #animal_room{num = Num}| _L]) when Num < ?animal_max_num->
    Room;
find_room([_Room | L]) ->
    find_room(L).
```

从房间列表中寻找是否有空位的房间。



```erlang
start_room(Type, Id) ->    
    case catch animal:start_link(Type, Id) of        
        {ok, Pid} ->            
            #animal_room{id = Id, type = Type, num = 1, pid = Pid};        
        _ ->            
            false    
    end.
```

开启一个房间，其实就是创建一个房间进程。

Type是房间类型，Id是房间标识，这里animal_mgr进程会与animal进程建立一个链接关系。





## animal_mgr方法











### 进入房间

寻找可以加入的房间由房间管理进程来负责。

```erlang
%% 进入房间
enter_room(Role = #role{status = ?status_normal, use_coin = Coin, guide_task = #guide_task{id = TaskId}}, Type) ->
    %% 获取房间最小炮值
    Need = animal:get_min_coin(Type, TaskId),
    %% 获取炮等级的消耗金币
    {Max, _, _} = zoo_room_power_setting:get_data(Coin),
    
    %% 这里应该是判断玩家的最大炮值是否大于房间要求的最小炮值
    case Max >= Need of
        true ->
            %% 寻找一个可以加入的房间
            case catch gen_server:call(?MODULE, {get_room_pid, Type, TaskId}) of
                {ok, Pid} ->
                    %% 向房间进程发生一个enter信息
                    case catch gen_server:call(Pid, {enter, role_conver:to_animal_role(Role)}) of
                        {ok, Data} ->
                            {ok, Data, Role#role{room_type = Type, room_pid = Pid, status = ?status_zone}};
                        _Err ->
                            {false, ?error_busy}
                    end;
                _Err ->
                    {false, ?error_busy}
            end;
        _ ->
            {false, ?error_act}
    end;
enter_room(_, _) ->
    {false, ?error_act}.
```

- status

  表示玩家当前所处状态，值有大厅、动物园等，

- use_coin

  使用的炮等级

- guide_task

  该字段是一个guide_task record，它的id暂时不知道作用

- Type

  房间类型

房间是有不同类型的。

每种房间的最低炮值是不一样的，因此在玩家进入房间时会检查玩家已解锁的最大炮值。

接着寻找一个可以加入的房间，其实就是一个房间进程。在找到房间进程后，就会向房间进程发送一条enter消息，同时把玩家数据传递过去，由该房间进程处理玩家信息。



寻找一个可以加入的房间代码：

```erlang
handle_call({get_room_pid, Type, _}, _From, State = #state{id = NextId, list = List}) ->
    %% 根据房间类型寻找对应的房间列表
    case lists:keyfind(Type, 1, List) of
        {Type, RoomList} ->
            case find_room(RoomList) of
                %% 找到空位房间
                Room = #animal_room{id = Id, pid = Pid, num = Num} ->
                    NewList = lists:keydelete(Id, #animal_room.id, RoomList),
                    NewList1 = [Room#animal_room{num = Num + 1} | NewList],
                    {reply, {ok, Pid}, State#state{list = lists:keyreplace(Type, 1, List, {Type, NewList1})}};
                %% 未找到空位房间
                _ ->
                    case start_room(Type, NextId) of
                        Room = #animal_room{pid = Pid} ->
                            NewList = [Room | RoomList],
                            {reply, {ok, Pid}, State#state{id = NextId + 1, list = lists:keyreplace(Type, 1, List, {Type, NewList})}};
                        _ ->
                            {reply, false, State}
                    end
            end;
        _ ->
            %% 开启一个房间
            case start_room(Type, NextId) of
                Room = #animal_room{pid = Pid} ->
                    {reply, {ok, Pid}, State#state{id = NextId + 1, list = [{Type, [Room]} | List]}};
                _ ->
                    {reply, false, State}
            end
    end;
```

房间管理进程的State存储了房间列表。

首先寻找空位房间，如果找不到则创建房间进程，再加入到房间管理进程State的列表中；

如果寻找到可用房间进程，会判断房间是否满人。房间如果不满人，那么加入房间并更新房间列表。房间满人则新创建房间，加入到房间列表。









## animal进程

animal.erl是房间进程

### State

```erlang
-record(state, {
    id = 0,
    type = 0,			%% 房间类型
    role_list = [],		%% 玩家列表
    animal_list = [],	%% 动物列表
    pre_list = [],		%% 动物预警列表
    skill = [],			%% 击杀列表?
    num = 1,			%% 动物id，从1开始
    guide_task = 0
}).
```

- id

  房间id，房间的标识

- type

  房间类型

- role_list

  玩家列表

- animal_list

  产生的动物列表

- pre_list

  动物预警列表

- guide_task

- num

  猜测是动物id，从1开始

- skill

  猜测是击杀列表



### 初始化

```erlang
init([Type, Id]) ->
    State = case Type of
        {Type1, TaskId} ->
            #state{id = Id, type = Type1, guide_task = TaskId};
        _ ->
            #state{id = Id, type = Type}
    end,
    NewState = do_init(State),
    process_flag(trap_exit, true),
    erlang:send_after(1000, self(), check_animal_out),
    {ok, NewState}.

```

- Id

  房间Id，唯一的值，由animal_mgr分发。

- Type

  房间类型。

  它也可能是一个元组，这种情况一般是单人场才会发生。可以在animal_mgr的get_room_pid消息处理中看到这种情况的发生。

主要的初始化逻辑在do_init函数中，该函数会调用init_animal()函数，主要用于产生动物。同时会触发一个定时器，向自身发送一条check_animal_out消息，用于检查动物退出。



```erlang
init_animal(0, State) -> State;
init_animal(N, State = #state{animal_list = List, role_list = RoleList, num = Num, pre_list = PreList, type = Type, guide_task = TaskId}) ->
    %% 产生动物
    {PushList, NewList, NewNum, PreList1} = init_animal(N, [], List, Num, RoleList, PreList, Type, TaskId),
    
    %% 向房间中的玩家推送动物列表
    push_animal_enter(PushList, RoleList),
    NewState = State#state{animal_list = NewList, num = NewNum, pre_list = PreList1},
    NewState.
```

- State

  animal进程状态

该函数主要做了产生动物，向玩家推送动物列表，更新进程状态3个操作。





```erlang
init_animal(0, List1, List, Num, _, PreList, _Type, _) -> {List1, List, Num, PreList};
init_animal(N, List1, List, Num, RoleList, PreList, Type, TaskId) ->
    %% 随机产生一只动物
    Animal = #animal_base{base_id = BaseId, rate = [Min, Max]} = get_one_annimal(PreList ++ List, TaskId),
    
    %% 确定倍率
    Rate = sys_rand:rand(Min, Max),
    
    %% 创建红包
    RedBag = create_red_bag(Type, BaseId),
    
    %% 初始化路线
    #animal_route{id = RouteId, time = AllTime, post = Post, xy = XY} = init_animal_route(),
    
    %% 预警动物与普通动物的俩种处理
    case lists:member(BaseId, ?animal_pre_notice_list) of
        true ->
            %% 为animal_base record各个字段赋值，这个就是当前动物的属性了
            NewAnimal = Animal#animal_base{id = Num, end_time = AllTime, post = 0, route_id = RouteId, xy = XY, red_bag = RedBag, rate = Rate},
            %% 推送预警信息
            push_pre_animal(BaseId, RoleList),
            %% 预警动物之后再加载
            erlang:send_after(3000, self(), {add_animal, NewAnimal}),   
            %% 预警动物会加入到预警列表中，然后再次递归，产生下一只动物
            init_animal(N -1, List1, List, Num + 1, RoleList, [NewAnimal | PreList], Type, TaskId);
        _ ->
            %% 为animal_base record各个字段赋值
            NewAnimal = Animal#animal_base{id = Num, end_time = AllTime, post = Post, route_id = RouteId, xy = XY, red_bag = RedBag, rate = Rate},
            %% 如果是普通动物，会分别加入到List1和List列表中
            init_animal(N -1, [NewAnimal | List1], [NewAnimal| List], Num + 1, RoleList,  PreList, Type, TaskId)
    end.
```

参数：

- N：表示产生多少只动物
- Num：猜测用于标识产生的动物，Num标识animal进程当前产生动物的最大Id
- List1：要推送的动物列表
- List：animal进程的动物列表
- PreList：animal进程的预警动物列表
- TaskId：引导任务Id？

返回值是一个元组：

- List1：推送给玩家的动物列表
- List：动物列表，用于更新animal进程的animal_list字段
- Num：猜测是动物数量，因为animal进程有更新num字段？但是也看到作为animal_base record的id字段
- PreList：预警动物列表，用于更新animal进程的pre_list字段

init_animal()函数会递归的产生动物，每递归一次就产生一只动物。





```erlang
get_one_annimal(List, _TaskId) ->
    %% OnlyList是只允许出现一次的动物列表，这里面的动物就不要再产生了。
    OnlyList = [Id || #animal_base{base_id = Id} <- List, lists:member(Id, ?animal_only_one_list)],

    %% 可随机产生的动物列表
    NewList = [A||A = #animal_base{base_id = Id} <-get_animal_base(), not lists:member(Id, OnlyList)],

    %% 根据动物的出现概率，随机产生一只动物
    case sys_rand:rand_list(NewList, #animal_base.pre) of
        %% 如果是同类型炸弹人，那么会随机产生一只炸弹类型的动物。
        Animal = #animal_base{base_id = type_bomber, bomber_type = List1} ->
            Type = sys_rand:rand_list(List1),
            #animal_base{rate = Rate} = lists:keyfind(Type, #animal_base.base_id, get_animal_base()),
            Animal#animal_base{bomber_type = Type, rate = Rate};
        _Animal -> _Animal
    end.
```

随机产生产生一只动物。

- List

  预警动物列表与普通动物列表的集合

它的逻辑是：

1. 从已产生的动物列表、预警列表里面找出只允许出现一次的动物，OnlyList就是寻找的结果，这个列表里面的动物是不允许再次产生的。
2. 获取整个动物列表配置，从中排除已出现过的只允许出现一次的动物，得到一个可以随机出动物的列表，即第二行代码。
3. 根据动物产生的概率，随机出一只动物。animal_base的pre字段表示产生的概率。



## animal进程方法













### 加入房间

房间管理进程在为玩家寻找到合适的房间进程后，就会向其发送一条加入信息，将玩家加入到房间中。

以下是加入房间的代码，主要逻辑是把玩家信息加入到进程的玩家列表中，再向其他人推送进入消息。

```erlang
%% 玩家进入
handle_call({enter, Role = #animal_role{role_id = RoleId}}, _From, State = #state{type = Type, role_list = RoleList, animal_list = AnimalList}) ->
    %% 将当前玩家加入房间玩家列表中
    NewList = lists:keystore(RoleId, #animal_role.role_id, RoleList, Role),

    %% 向其他玩家推送进入消息
    push_in(Role, RoleList),
    
    %% 新的玩家列表
    NewList1 = to_p_animal_role(NewList),
    
    %% 动物列表
    NewList2 = to_p_animal(AnimalList),
    
    %% 响应数据并更新进程状态
    Data = #m_1301_toc{animals = NewList2, role_list = NewList1, type = Type},
    {reply, {ok, Data}, State#state{role_list = NewList}};
```



以下是向其他玩家推送有玩家进入房间，代码逻辑很简单，List是要推送的玩家列表，Role是进入房间的玩家。

```erlang
%% 推送玩家进入信息
push_in(Role = #animal_role{}, List) ->
    Role1 = to_p_animal_role(Role),
    
    %% 向其他玩家推送有玩家进入的信息
    [sys_conn:pack_send(Pid, 1307, #m_1307_toc{role = Role1}) || #animal_role{socket_pid = Pid} <- List].
```

- Role

  当前玩家

- List

  其他玩家



### 房间类型

```erlang
get_min_coin(civilian, _) -> 5;
get_min_coin(petty, _) -> 100;
get_min_coin(rich, _) -> 1000;
get_min_coin(gold, _) -> 10000;
get_min_coin(diamond, _) -> 20000;
get_min_coin(ticket, _) -> 1000;
get_min_coin(single, TaskId) ->
    case TaskId =< 5 of
        true -> 5;
        _ -> 1000
    end.
```









## 相关结构体



### animal_room

```erlang
-record(animal_room, {
    id = 0,
    type = 0,
    num = 0,
    pid			%% 房间进程id
}).
```

房间信息。存储人数和房间进程pid，由房间管理进程使用。

- pid：房间进程id
- num：



### animal_role

```erlang
-record(animal_role, {
    role_id = 0,
    pid,		%% 房间进程pid
    socket_pid,	%% 连接进程pid
    skill_id = [],
    effect = 1,		%% 狂暴倍数
    vip_effect = 0	%% vip特效
}).
```

房间人物信息。



### animal_base

动物基本信息

```erlang
-record(animal_base, {
    id = 0,		%% 唯一id
    base_id = 0,	%% 基础id，其实就是动物类型
    name,		%% 动物名字

    rate = 0,	%% 倍率
    pre = 0,	%% 出现概率

    end_time = 0,	%% 剩余总步数
    post = 0,		%% 当前位置
    xy = {0, 0},		%% 当前坐标

    is_notice = 0,		%% 0不广播，1广播
    status = 0,			%% 0正常，1冰冻
    drop_item = [],		%% 掉落列表
    item_list = [],		%% 可以掉落的列表
    red_bag = 0,		%% 是否有红包
    bomber_type = 0,	%% 同类型炸弹类型

    self_id = 0,		%% 私有大象人物id
    self_name = 0,		%% 私有大象人物名字
})
```









## Problems

了解房间进程是如何初始化的？

1. init_animal()函数中List1、List一个用于推送，一个是普通的，都存储了普通动物，为什么要用变量来存储呢？
2. 为什么预警动物要晚点加载：add_animal消息怎么处理的？
3. 动物是怎么推送的？
4. 同类型炸弹有什么特殊处理。

这些是查看动物初始化留下来的问题。

目前知道房间进程初始化后会产生动物，进程的State会发生变化。



了解打动物的过程？





动物路线怎么处理？

动物消失后发生什么？

检测动物越界？

