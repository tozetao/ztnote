### fork()

```c
#include <unistd.h>

pid_t fork(void);
// In parent: returns process ID of child on success, or -1 on error.
```

fork()系统调用允许进程创建一新进程，新进程是子进程，原进程为父进程。在fork()成功后，父子进程都是从fork()的返回处进行执行代码。

在父进程中fork()执行成功返回的是子进程的进程ID，在子进程中fork()执行成功会返回0；如果返回-1一般是真实用户超出系统允许创建的进程数量或者超出系统允许创建的进程数量。

- 父子进程的区别

  父子进程会指向相同的程序文本段，但却拥有不同的数据段、栈段和堆段。子进程的数据段、栈段和堆段在开始时是对父进程的完全复制，执行fork()后，每个进程均可修改各自的栈数据和堆中的变量，且互不影响。

- 进程的调用顺序

  要明确的是，父子进程的调用顺序是未知且不可靠的，因为进程的调度分配工作是由内核来决定的， 对于程序是不可知的。



### fork的文件共享

执行fork()时，子进程会获得父进程所有文件描述符的副本。

这些副本的创建方式相当于dup()，这意味父子进程的文件描述符都指向相同的打开文件句柄，而打开文件句柄包含当前偏移量与文件状态标志，所以父子进程共享同一个文件句柄，父子之间对文件描述符的操作都会影响对方。



### fork的内存语义

从概念上可以将fork()当做是对父进程的程序段、数据段、堆段和栈段的创建拷贝，然而这种实现太浪费内存空间了，因此大部分unix实现采用俩种技术来避免这种浪费。

- 共享代码段

  内核对每一进程的代码段标记为只读，从而使进程无法修改自身代码，这样父子进程会共享同一代码段。

  fork()在为子进程创建代码段时，其构建的进程级页表项都指向与父进程相同的物理内存页帧。

- 对于数据段、堆栈和栈段采用写时复制技术

  内核会先让子进程这些段的页表项指向与父进程相同的物理内存页帧，并将这些页标记为只读。

  调用fork()之后内核会捕获所有父进程和子进程针对这些页帧的修改企图，并为将要修改的页帧创建拷贝，系统会将新的页帧拷贝分配给遭到内核捕获的进程，还会对子进程的相应页表项做适当调整，这时父子进程可修改各自的也拷贝，且互不影响。



### 进程的终止

进程的终止方式有俩种，一种是异常（abnormal）终止，比如接收了某一信号，该信号的默认动作为终止当前进程，可能产生核心转储（core dump）；另一种是使用_exit()系统调用正常（normally）终止。



```c
#include <unistd.h>
void _exit(int status);
```

\_exit()的status参数定义了进程的终止状态，父进程可调用wait()以获取该状态，status虽然是int型，但是只有低8位可为父进程使用。一般status等于0表示程序正常退出，非0值表示异常退出。



```CQL
#include <unistd.h>
void exit(int status);
```

一般不会执行_exit()系统调用，而是执行exit()库函数，它做了些封装，在\_exic()执行之前做如下处理：

- 调用退出处理程序，通过atexit()和on_exit()注册的函数，其执行顺序与注册顺序相反
- 刷新stdio流缓冲区
- 使用有status提供的值执行_exit()系统调用

程序的另一种终止方法，在main()函数中return返回值等同于exit()调用



无论进程是否正常终止，都会发生以下操作：

- 关闭所有打开文件描述符、目录流、信息目录描述符。
- 关闭文件描述符后，将释放该进程所持有的任何文件锁。
- 分离（detach）任何已连接的System V共享内存段，且对应于各段的shm_nattch计数器的值将减1
- 进程为每个System V信号量所设置的semadj值将会被加到信号量值中
- 将关闭该进程打开的任何POSIX有名信号量，类似调用sem_close()
- 将关闭进程打开的任何POSIX消息队列，类似调用mq_close()
- 移除该进程通过mlock()或mlockall()所建立的任何内存锁。
- 取消该进程调用mmap()所创建的任何内存映射
- 如果该进程是一个管理终端的管理进程，那么系统会向该终端前台进程进程组中的每个进程发送SIGHUP信号，接着终端与会话脱离。
- 如果某进程组成为孤儿，且该组中存在任何已停止进程，则组中所有进程都将收到SIGHUP信号，随之为SIGCONT信号。





### 退出处理程序

退出处理程序指的是在进程终止时会自动的执行某些操作。

退出处理器程序其实就是一个自定义的处理函数，可在进程生命周期的任何时间点进行注册，并会在该进程调用exit()正常终止时自动执行。如果程序调用_exit()或因信号而异常终止，是不会调用退出处理程序的。

要注意的是，当进程收到信号而终止时，将不会调用退出处理程序，这时最好的方式是针对可能会发送给进程的信号注册处理程序，并在其中设置标记位，由主程序来执行exit()函数，因为exit()不属于异步安全函数。即使如此仍然不能解决SIGKILL信号，因此建议使用SIGTERM信号。



```c
#include <stdlib.h>

int atexit(void (*func)(void));
// reutrns 0 on success, or nonzero on error
```

函数atexit()会将func注册到一个函数列表中，进程终止时会调用该函数列表的所有函数。func参数是一个函数指针，无参数也无返回值。

- 执行顺序

  可以注册多个处理程序，这些程序的执行顺序与注册顺序相反。

- 注册退出程序的数量上限

  SUSV3要求系统实现允许一个进程能够注册最少32个退出处理程序，通过系统调用sysconf(\_SC_ATEXIT_MAX)可以查看系统可注册退出处理程序的数量上限。



### stdio缓冲区

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char const *argv[])
{
    printf("hello world.\n");
    write(STDOUT_FILENO, "Ciao\n", 5);

    if (fork() == -1) {
        printf("fork error\n");
        exit(-1);
    }

    return 0;
}
```

上述的这段代码执行时如果重定向到一个文件，printf()将会先于write()调用，并且输出俩次。



进程的用户空间内存中维护着stdio缓冲区，fork()创建子进程时会复制这些缓冲区，当标准输出定向到终端时，因为缺省为行缓冲，所以能得到预期的结果。

但是当标准输出定向到文件时，由于缺省输出为块缓冲，当调用fork()时，printf()输出仍然在父进程的stdio缓冲区，且随着子进程的创建而产生一份拷贝，所以当父子进程调用exit()退出时会刷新各自的缓冲区，从而导致printf()重复的输出。

而write()先于printf()输出结果是因为write()函数写入数据时，会将数据立即传递给内核高速缓冲，而printf()的输出则要等到调用exit()刷新stdio缓冲区时才触发。



解决的方法有：

- 可以使用fflush()来刷新stdio缓冲区，或者使用setvbuf()/setbuf()来关闭缓冲区。
- 子进程可以调用_exit()，以便不再刷新stdio缓冲区。





### 监控子进程

父进程可以知道子进程于何时改变了状态，例如子进程终止或因为信号而停止。监控子进程可以通过wait()以及信号SIGCHLD。

```c
#include <sys/wait.h>

pid_t wait(int *status);
```

wait()会等待调用进程的任一子进程终止，参数status可以获取子进程的终止状态。

wait()会执行如下动作：

- 如果调用进程的子进程尚未终止，调用将一直阻塞，直到某个子进程终止。如果调用时有子进程终止，wait()将立即返回。
- 如果status参数非空，那么子进程终止的信息会通过status执行的整型变量返回。
- 内核会为父进程下的所有子进程的运行总量追加进程CPU时间以及资源使用数据。
- 将终止的子进程的ID作为wait()的结果返回。

出错时wait()返回-1，同时errno会被置为ECHILD，可能原因之一是调用进程并无未被等待的子进程。



```c
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *status, int options);
// returns process ID of child, 0(see text), or -1 error.
```

waitpid()的status参数与返回值与wait()系统调用相同。

参数pid用来表示需要等待的具体子进程：

- 如果pid大于0，表示等待指定的子进程ID
- 如果pid等于0，则等待与调用进程同一个进程组的所有子进程
- 如果pid小于-1，则会等待进程组标识符与pid绝对值相等的所有子进程
- 如果pid等于-1，则等待任意子进程，与wait()等价。

参数options是一个位掩码，可以通过按位或包含多个如下标志：

- WUNTRACED

  除了返回终止子进程的信息外，还返回因信号而停止的子进程信息。

- WCONTINURD

  返回那些因受到SIGCOUNT信号而恢复执行的已停止子进程的状态信息。

- WNOHANG

  如果参数pid所指定的子进程并未发生状态变化，则立即返回而不会阻塞，这时waitpid()返回0；如果调用进程并无与pid匹配的子进程，则waitpid()报错，并将错误号置为ECHILD。



### 等待状态值

由wait()和waitpid()返回的status值可以用于区分以下子进程事件：

- 子进程调用exit()而终止，并指定一个整型值作为退出状态。
- 子进程收到未处理信号而终止。
- 子进程因为信号而停止，并以WUNTRACED标志调用waitpid()
- 子进程因收到信号SIGCONT而恢复，并以WCONTINUED标志调用waitpid()

约定俩个属于，等待状态表示上述所有情况，终止状态表示前俩种情况。



status虽然是int型，但是只使用了最低的2个字节，对这俩个字节的填充方式决定了子进程发生的具体事件，具体填充方式不细究，在头文件<sys/wait.h>定义了用于解析等待状态值的一组标准宏。

```c
WIFEXITBD(status);
// 若子进程正常结束则返回true，此时宏WEXITSTATUS(status)返回子进程的退出状态

WIFSIGNALED(status);
// 若通过信号杀死子进程则返回true，此时宏WTERMSIG(status)返回导致子进程终止的信号。

WIFSTOPPED(status);
// 若子进程因信号而停止返回true，此时宏WSTOPSIG(status)返回导致子进程停止的信号编号。

WIFCONTINURD(status);
// 若子进程收到SIGCONT而恢复执行则返回true

// 注：这里的status参数是整型值而非指针。
```











