## ets

ets是erlang term storage的缩写。

该模块提供了在运行时存储erlang数据项的接口。数据被组织为一组动态表，这些表通过键值对的形式来组织数据，即{Key, Value}。



### 生命周期

每个表由一个进程创建，当进程终止时表会自动销毁。且每个表在创建是都会设置权限。

ets表是没有垃圾回收的，即使没有任何进程对表的引用，除非所有者进程终止，或者主动删除表，否则表是不会自动销毁的。

默认所有者进程是创建表的进程，也可以通过give_away/3转移表的所有权。





### 表类型

ets表有四种类型：

- set

  异键表，所插入元组的key是唯一的。

  这意味着如果存储的元组的key已在表中，那么后者会覆盖前者。

- order_set

  有序异键表，存储的元组的key不仅唯一，而且会按照key对元组进行排序。

- bag

  同键表，存储的元组的key允许重复，但是相同key的元组的值必须是唯一的。

- duplicate_bag

  可重复的同键表，存储的元组的key和value允许重复。





### ets表的效率

ets表对数据的访问时间是恒定的，除了ordered_set表，它的访问时间与存储对象数量的对数成正比。这是因为ordered_set表是平衡二叉树实现的，而其他类型的表是由散列表实现的。

散列表类型的表会带来少许空间开销，而平衡二叉树的表会带来时间开销。值得注意的是，使用同键表的代价要高于可重复的同键表，因为每次插入时都需要与所有相同键的元素比较是否相等。







### 数据复制

插入操作的数据是从进程的栈中复制到ets表中的，查询操作时，如果找到数据会从ets表中复制到栈中。

大型的二进制数据是存储在内存堆中，它会为每个二进制数据块维护一个计数器，进程和ets表如果有应用某块数据那么计数器会自增，当计数器为0时该数据的存储区域就会被回收。







### 并发

此模块为并发访问提供了一些有限的支持。

对单个对象的所有更新都保证是原子性和孤立的，这意味着对单个对象的更新操作要么成功要么完全失败，没有任何影响，而且其他进程看不到更新的中间结果（隔离性）。

一些更新许多对象状态的函数声明它们甚至保证了整个操作的原子性和隔离性。



### ERL_MAX_ETS_TABLES





### 匹配与相等

如果俩个erlang数据项匹配，那么它们拥有相同的类型和值。所以1与1匹配，但是1.0与1不匹配（类型不同）；

如果俩个erlang数据项相等，要么它们拥有相同的类型和值，或者它们是数值类型并扩展到相同的值。比如1与1或1.0都相等。





### 失败

这里的失败是指调用函数失败。

本模块中的函数通过引发一个带有错误原因的错误异常而失败。具体错误原因有：

- badarg

- system_limit

  修改一个值可能会导致无法在VM中表示它。例如计数器的大小超过可表示的最大整数。

- system_limit

  如果作为参数传递的匹配规范有过多的嵌套，导致调用进程正在执行的调度器堆栈耗尽。

  注：调度程序堆栈大小是可配置的。







### 遍历表





### 匹配规格







### 常用函数

```erlang
-spec ets:new(Name, [Opt]) -> TableId
```

Name是一个原子，[Opt]是一列选项，具体有：

- set | ordered_set | bag | duplicate_bag

  ets表类型

- private

- protected

- public

- named_table

  为表命名，如果设置了该选项，则Name可以用于后续表操作。

- {keypos, K}

  指定元组中要用作键的元素，默认是第一个元素，K=1。

  注：表中存储的任何元组至少要有K个元素。

- read_concurrency

  并发读性能调整。

  当设置为true时，表针对并发读取操作进行优化。在支持SMP的运行系统上启动该选项后，读取操作会变得很廉价，尤其是在具有多个物理处理器的系统上。

  当并发读操作比写操作频繁的多，或者许多读不会被写打断，许多写不会被读打断，就可以启动该选项。

  

  但是在读和写操作之间的切换会变得更加昂贵，这是对针对同个元素的读写操作（个人理解，有待考证），所以当访问模式是几个读操作与几个写操作重复交织时，启动该选项会导致性能下降。

- write_concurrency

  并发写性能调整。



```erlang
-spec delete(Tab) -> true
```

删除指定的表。



```erlang
from_dets(Tab, DetsTab) -> true
```

用已打开的dets表中的对象填充已创建的ets表。ets表中的现有数据会被保留，除非被覆盖。

如何任何一个表不存在或者dets表没有打开，会引发一个badarg异常。









## dets

disk erlang term storage。



dets模块提供了在文件上存储erlang数据项。

被存储的数据项在模块中叫做对象，它就是被定义为一个键元素的元组。比如{a, {...}}，该元组就是一个对象，第一个元素（原子a）是key，第二个元素是值。

一个dets表是对象的集合，相同键的对象会被存储在文件中的同一个位置。



这个模块通过Mnesis应用使用的，它提供给那些只对在磁盘上高效存储erlang数据项感兴趣的用户。许多的应用只需要在文件上存储一些erlang数据项。Mnesia增加了事务、查询和分发功能。

Dets表文件不能超过2GB，如果需要更大容量的表，可以使用Mnesia提供的表碎片。



### 表类型

- set

  所插入的对象的key必须是唯一的，如果表中已存在相同key的对象，后插入的对象会覆盖原有的对象。

- bag

  允许不同的对象拥有相同的key，但是这些对象的值必须是唯一的。

- duplicate_bag

  允许有多个相同的对象，允许插入key与value都相同的元组，且不会覆盖。





### 生命周期

dets表必须在更新或读取之前打开，完成后必须被正确关闭。如果表未正确关闭，dets会自动修复该表，如果表数据很大则修复的时间会漫长。



当打开dets表的进程终止时，dets表会被关闭。

如果许多进程打开同一个表，则它们共享该表，当所有进程终止或者主动关闭该表时，该表会被正确关闭；如果erlang运行时系统异常，则表不会被正确关闭。



### 存储实现

dets表将数组组织为一个线性散列表，当表中插入更多的数据时，散列表会自动增长。

表空间管理是由buddy系统来执行的，当前的实现是将整个buddy系统存储在RAW中，这意味着表被严重碎片化，就会耗费相当多的内存。对表进行碎片化整理的唯一方式是关闭它，然后在选项repair设置为force的情况下再次打开它。





### 并发

请注意，Dets尚未提供Ets中的ordered_set类型表，也不提供对并发更新的有限支持，即无能并发的对同一个元素进行读写操作。





### 错误处理

所有的dets函数都会返回{error, Reason}，first/1和next/2是例外，它们会带着错误元组退出进程。

如果指定了错误的参数，所以函数都会以bagarg信息退出进程。





### 常用函数

```erlang
-spec open_file(Name, Args) -> {ok, Name} | {error, Reason}
```

打开一个表，如果不存在则创建一个空的dets表。

原子Name是表名，在后续表的所有操作中都是通过表名来进行操作。该名称也可以被其他进程引用，许多进程可以共享一个表。

如果俩个进程通过相同的表名和参数打开同一个表，那么这个表就会有俩个用户。如果一个用户关闭了表，那么在第二个用户关闭表之前，表仍然是开放的。

参数Args是{K, V}的的元组列表，具体的值有：

- {access, access()}

  默认为read_write。

  现有的表可以在只读模式打开。以只读模式打开的表，如果在崩溃后被打开，则不受自动文件修复算法的影响。

- {auto_save, auto_save()}

  自动存储间隔，默认值为180000（3分钟）。

  如果存储间隔是整数时间，当表在毫秒时间内未被访问时，数据就会刷新到磁盘上。

  一个已刷新的表在一个不受控制的emulator停止后重新打开时，不需要进行修复。

  如果存储间隔是原子无穷大，则禁用自动存储。

- {file, file:name}

  要打开的文件名称，默认为表名。

- {max_no_slots, no_slots()}

  要使用的最大插槽数，默认32M，这是最大值。

  请注意较高的值会增加表碎片，较小的值会减少碎片，但会增加执行时间。

- {min_no_slots, no_slots()}

  在创建表时，指定表中要存储的不同键的估计数量，通过该选项提高程序性能。

  默认值256，这是最小值。

- {ram_file, boolean()}

  表是否保存的RAW中，默认false。

  

- {keypos, keypos()}

  指定对象中的哪个元素会作为键，默认1。

  在存储erlang记录时需要显示的声明。

- {repair, Value}

  Value可以是布尔值或原子force。

  该标志指定dets服务是否要调用自动文件修复算法。

  默认值为true。如果指定false，则不尝试修复文件，如果必须修复表，则返回{error，{needs_repair，FileName}}。

- {type, type()}

  表类型。







```erlang
from_ets(Name, EtsTab) -> ok | {error, Reason}
```



init_table

insert

insert_new

lookup







