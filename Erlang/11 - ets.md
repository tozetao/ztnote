## ets

ets是erlang term storage的缩写。

该模块提供了在运行时存储erlang数据项的接口。数据被组织为一组动态表，这些表通过键值对的形式来组织数据，即{Key, Value}。



### 生命周期

每个表由一个进程创建，当进程终止时表会自动销毁。且每个表在创建是都会设置权限。

ets表是没有垃圾回收的，即使没有任何进程对表的引用，除非所有者进程终止，或者主动删除表，否则表是不会自动销毁的。

默认所有者进程是创建表的进程，也可以通过give_away/3转移表的所有权。





### 表类型

ets表有四种类型：

- set

  异键表，所插入元组的key是唯一的。

  这意味着如果存储的元组的key已在表中，那么后者会覆盖前者。

- order_set

  有序异键表，存储的元组的key不仅唯一，而且会按照key对元组进行排序。

- bag

  同键表，存储的元组的key允许重复，但是相同key的元组的值必须是唯一的。

- duplicate_bag

  可重复的同键表，存储的元组的key和value允许重复。





### ets表的效率

ets表对数据的访问时间是恒定的，除了ordered_set表，它的访问时间与存储对象数量的对数成正比。这是因为ordered_set表是平衡二叉树实现的，而其他类型的表是由散列表实现的。

散列表类型的表会带来少许空间开销，而平衡二叉树的表会带来时间开销。值得注意的是，使用同键表的代价要高于可重复的同键表，因为每次插入时都需要与所有相同键的元素比较是否相等。







### 数据复制

插入操作的数据是从进程的栈中复制到ets表中的，查询操作时，如果找到数据会从ets表中复制到栈中。

大型的二进制数据是存储在内存堆中，它会为每个二进制数据块维护一个计数器，进程和ets表如果有应用某块数据那么计数器会自增，当计数器为0时该数据的存储区域就会被回收。







### 并发

此模块为并发访问提供了一些有限的支持。

对单个对象的所有更新都保证是原子性和孤立的，这意味着对单个对象的更新操作要么成功要么完全失败，没有任何影响，而且其他进程看不到更新的中间结果（隔离性）。

一些更新许多对象状态的函数声明它们甚至保证了整个操作的原子性和隔离性。



### ERL_MAX_ETS_TABLES





### 匹配与相等

如果俩个erlang数据项匹配，那么它们拥有相同的类型和值。所以1与1匹配，但是1.0与1不匹配（类型不同）；

如果俩个erlang数据项相等，要么它们拥有相同的类型和值，或者它们是数值类型并扩展到相同的值。比如1与1或1.0都相等。





### 失败

这里的失败是指调用函数失败。

本模块中的函数通过引发一个带有错误原因的错误异常而失败。具体错误原因有：

- badarg

- system_limit

  修改一个值可能会导致无法在VM中表示它。例如计数器的大小超过可表示的最大整数。

- system_limit

  如果作为参数传递的匹配规范有过多的嵌套，导致调用进程正在执行的调度器堆栈耗尽。

  注：调度程序堆栈大小是可配置的。







### 遍历表





### 匹配规格







### 常用函数

```erlang
-spec ets:new(Name, [Opt]) -> TableId
```

Name是一个原子，[Opt]是一列选项，具体有：

- set | ordered_set | bag | duplicate_bag

  ets表类型

- private

- protected

  所属进程可以对表进行读写，但是其他进程只允许读。这是默认设置。

- public

  任何进程都可以对表进行读写。

- named_table

  为表命名，如果设置了该选项，则Name可以用于后续表操作。

- {keypos, K}

  指定元组中要用作键的元素，默认是第一个元素，K=1。

  注：表中存储的任何元组至少要有K个元素。

- read_concurrency

  并发读性能调整。

  当设置为true时，表针对并发读取操作进行优化。在支持SMP的运行系统上启动该选项后，读取操作会变得很廉价，尤其是在具有多个物理处理器的系统上。

  当并发读操作比写操作频繁的多，或者许多读不会被写打断，许多写不会被读打断，就可以启动该选项。

  

  但是在读和写操作之间的切换会变得更加昂贵，这是对针对同个元素的读写操作（个人理解，有待考证），所以当访问模式是几个读操作与几个写操作重复交织时，启动该选项会导致性能下降。

- write_concurrency

  并发写性能调整。



```erlang
-spec delete(Tab) -> true
```

删除指定的表。



```erlang
from_dets(Tab, DetsTab) -> true
```

用已打开的dets表中的对象填充已创建的ets表。ets表中的现有数据会被保留，除非被覆盖。

如何任何一个表不存在或者dets表没有打开，会引发一个badarg异常。



```erlang
to_dets(Tab, DetsTab) -> DetsTab
```

把一个已打开的ETS表Tab里的对象数据插入到一个已创建的磁盘ETS表Dets中。表Dets里的数据在对象数据插入前会被请空。



```erlang
fun2ms(LiteralFun) -> MatchSpec
```

伪函数，通过parse_transform将函数调用中作为参数的LiteralFun转换为匹配规范。literal的意思是，这个fun必须以文本的形式写成函数的参数，它不能被保存在一个变量中，然后传递给fun2ms函数。

ms_transform模块提供了解析转换的功能，在源码中必须包含STDLIB的ms_transform.hrl文件，这个伪函数才能工作。如果未能在源文件中包含hrl文件，将导致运行时错误，而不是编译时错误。

该文件通过-include_lib("stdlib/include/ms_transform.hrl")来包含。

fun是受限的，它只能接收一个参数（即要匹配的对象）：一个唯一的变量或元组。它必须使用is_guard断言。像if、case、receive之类的语法是不允许出现在匹配规范中的。

该函数的返回值就是一个匹配规范。

注：匹配规范参数ets:select/2的定义。



```erlang
select(Tab, MatchSpec) -> [Match]
```

使用一个匹配规范从Tab表中匹配对象。此函数比ets:match/2更常用。以下是一些最简单行是的匹配描述：

```
Match = [MatchFunction]
MatchFunction = {MatchHead, [Guard], [Result]}
MatchHead = "Pattern as in ets:match"
Guard = {"Guardtest name", ...}
Result = "Term construct"
```

这意味着匹配规范总是由一个或多个元组组成的列表。元组的第一个元素应是ets:match/2的文档中所描述的匹配模式；第二个元素应是含0个或多个断言测试的列表；第三个元素应是包含关于实际返回值的描述列表，通常是一个对返回值全描述的列表，即返回匹配对象的所有项目。



返回值的结构使用MatchHead所绑定的"match variables"，或者使用特殊的匹配值，比如'\$_'会返回整个匹配对象，而'$$'则返回包含所有匹配值的列表。

example：

```erlang
Tab = ets:new(test_ets_new, [private]).
ets:insert(Tab, [{a, 1}, {b, 2}]).

%% 输出[[b,2],[a,1]]，可以返回的元素是所有匹配值组成的列表
ets:select(Tab, [{{'$1', '$2'}, [], ['$$']}]).

%% 输出[{b,2},{a,1}]
ets:select(Tab, [{{'$1', '$2'}, [], ['$_']}]).
```

返回值也可以通过写一个简单的列表来构建符合选项，例如：

```erlang
ets:select(Tab, [{{'$1', '$2'}, [], [['$1', '$2']]}]).
```

也就是将匹配头中的所有绑定变量当作一个列表。如果要构造元组，必须写一个参数数量1的元组，其中元组中的单元素就是自己要构造的元素，因为普通元组会被误认为Guard。

```erlang
ets:select(Tab, [{{'$1', '$2'}, [], [{{'$1', '$2'}}]}]).
```

这个语法与Runtime_Tools中的trace patterns(dbg3)模块中使用的语法相当。



Guards被构造为元组，其中第一个元素是测试名，其余元素是测试参数。

要检查绑定到匹配变量'$1'的元素的特定类型（比如列表），可以将guard test写成{is_list, '$1'}。如果验证失败，表中的对象不匹配，就会尝试下一个MatchFunction（如果有的话）。大多数存在于erlang的guard test都可以使用，但是只有前缀为is_的guard才允许使用（is_floag, is_atom等）。

Guards部分也可以包含逻辑运算和算数运算，这些运算的编写语法与guard test相同，所以下面写在erlang中的guard test：

```erlang
is_integer(X), is_integer(Y), X + Y < 1000
```

转换成Guards表示为，X、Y分别用\$1、\$2代替：

```erlang
[{is_integer, '$1'}, {is_integer, '$2'}, {'<', {'+', '$1', '$2'}, 4711}]
```



对于orderd_set类型的表，对象的访问顺序与first/next遍历相同。这表示匹配规范是相对于first/next顺序的对象执行的，相应的结果列表也是按照该执行顺序进行的。













```erlang
match(Tab, Pattern) -> [Match]
```

根据匹配模式Pattern匹配ETS表Tab里的对象数据。

一个匹配模式也许包含的项值有：

- 绑定部分（Erlang项）
- ’_‘ 可以匹配任何erlang项
- 匹配变量：'$N'(N >= 0)，使用时不能缺少分号。

该函数为每个匹配对象返回一个元素列表，其中每个元素是一个绑定变量模式的有序列表（即匹配变量所表示的值）。

example:

```erlang
ets:new(Tab, {named_table, bag}).
ets:insert(Tab, [{rufsen, dog, 7}, {brunte, horse, 5}, {ludde, dog, 5}]).

ets:match(Tab, {'_', dog, '$0'}).
%% 输出[[7], [5]]
%% 返回所有匹配对象的元素列表，每个元素的值都是有$0组成的。

ets:match(Tab, {'_', '$0', '$1'}).
%% 输出[[dog, 7], [house, 5], [dog, 5]]
```

注：匹配模式中如果指定了键，匹配是很有效率的。如果没有指定键，例如它是一个变量或者_，那么会搜索整个表。表越大搜索的时间就越长。



```erlang
match(Tab, Pattern, Limit) -> {[Match], Continuation} | '$end_of_table'
```

与match/2一样，不同的是Limit限制了返回的匹配数据数目。同时返回结果的Continuation变量，可以用于ets:match/2来获取下一批数据。这比使用ets:first/1和ets:next/2方法遍历获取表里的对象数据会更有效率。

```erlang
match(Continuation) -> {[Match], Continuation} | '$end_of_table'
```

继续从ets:match/3方法开始匹配数据，调用ets:match/3方法跟匹配数据一起返回的变量Continuation可用在下一次调用这个函数来获取下一批的匹配数据。

如果没有更多的数据在表里，那么则返回'$end_of_table'。













## dets

disk erlang term storage。



dets模块提供了在文件上存储erlang数据项。

被存储的数据项在模块中叫做对象，它就是被定义为一个键元素的元组。比如{a, {...}}，该元组就是一个对象，第一个元素（原子a）是key，第二个元素是值。

一个dets表是对象的集合，相同键的对象会被存储在文件中的同一个位置。



这个模块通过Mnesis应用使用的，它提供给那些只对在磁盘上高效存储erlang数据项感兴趣的用户。许多的应用只需要在文件上存储一些erlang数据项。Mnesia增加了事务、查询和分发功能。

Dets表文件不能超过2GB，如果需要更大容量的表，可以使用Mnesia提供的表碎片。



### 表类型

- set

  所插入的对象的key必须是唯一的，如果表中已存在相同key的对象，后插入的对象会覆盖原有的对象。

- bag

  允许不同的对象拥有相同的key，但是这些对象的值必须是唯一的。

- duplicate_bag

  允许有多个相同的对象，允许插入key与value都相同的元组，且不会覆盖。





### 生命周期

dets表必须在更新或读取之前打开，完成后必须被正确关闭。如果表未正确关闭，dets会自动修复该表，如果表数据很大则修复的时间会漫长。



当打开dets表的进程终止时，dets表会被关闭。

如果许多进程打开同一个表，则它们共享该表，当所有进程终止或者主动关闭该表时，该表会被正确关闭；如果erlang运行时系统异常，则表不会被正确关闭。





### 存储实现

dets表将数组组织为一个线性散列表，当表中插入更多的数据时，散列表会自动增长。

表空间管理是由buddy系统来执行的，当前的实现是将整个buddy系统存储在RAW中，这意味着表被严重碎片化，就会耗费相当多的内存。对表进行碎片化整理的唯一方式是关闭它，然后在选项repair设置为force的情况下再次打开它。





### 并发

请注意，Dets尚未提供Ets中的ordered_set类型表，也不提供对并发更新的有限支持，即无能并发的对同一个元素进行读写操作。





### 错误处理

所有的dets函数都会返回{error, Reason}，first/1和next/2是例外，它们会带着错误元组退出进程。

如果指定了错误的参数，所以函数都会以bagarg信息退出进程。





### 常用函数

```erlang
-spec open_file(Name, Args) -> {ok, Name} | {error, Reason}
```

打开一个表，如果不存在则创建一个空的dets表。

原子Name是表名，在后续表的所有操作中都是通过表名来进行操作。该名称也可以被其他进程引用，许多进程可以共享一个表。

如果俩个进程通过相同的表名和参数打开同一个表，那么这个表就会有俩个用户。如果一个用户关闭了表，那么在第二个用户关闭表之前，表仍然是开放的。

参数Args是{K, V}的的元组列表，具体的值有：

- {access, access()}

  默认为read_write。

  现有的表可以在只读模式打开。以只读模式打开的表，如果在崩溃后被打开，则不受自动文件修复算法的影响。

- {auto_save, auto_save()}

  自动存储间隔，默认值为180000（3分钟）。

  如果存储间隔是整数时间，当表在毫秒时间内未被访问时，数据就会刷新到磁盘上。

  一个已刷新的表在一个不受控制的emulator停止后重新打开时，不需要进行修复。

  如果存储间隔是原子无穷大，则禁用自动存储。

- {file, file:name}

  要打开的文件名称，默认为表名。

- {max_no_slots, no_slots()}

  要使用的最大插槽数，默认32M，这是最大值。

  请注意较高的值会增加表碎片，较小的值会减少碎片，但会增加执行时间。

- {min_no_slots, no_slots()}

  在创建表时，指定表中要存储的不同键的估计数量，通过该选项提高程序性能。

  默认值256，这是最小值。

- {ram_file, boolean()}

  表是否保存的RAW中，默认false。

  

- {keypos, keypos()}

  指定对象中的哪个元素会作为键，默认1。

  在存储erlang记录时需要显示的声明。

- {repair, Value}

  Value可以是布尔值或原子force。

  该标志指定dets服务是否要调用自动文件修复算法。

  默认值为true。如果指定false，则不尝试修复文件，如果必须修复表，则返回{error，{needs_repair，FileName}}。

- {type, type()}

  表类型。







```erlang
from_ets(Name, EtsTab) -> ok | {error, Reason}
```



init_table

insert

insert_new

lookup







