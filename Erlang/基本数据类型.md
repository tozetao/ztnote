### 变量

erlang的变量是一次性赋值变量，它只能被赋值一次，如果试图再变量被设置后改变它的值就会得到一个错误。



=号是模式匹配操作符，并不等同于c系列语言的赋值。

> X  = expression

上面整个表达式的含义是对 = 号右边的表达式进行计算，将计算结果与X变量进行匹配。如果X变量未绑定值，那么将计算结果与其进行绑定；如果X绑定了值，那么将计算结果与X进行匹配。

```erlang
%% 第一次对X进行绑定
X = 2 + 4.

%% 第二次是对X模式匹配，X是等于6的。如果不匹配将会报错。
X = 6
```



未绑定变量：变量还没有绑定值

已绑定变量：变量已经绑定值





### 作用域

变量的作用域是它声明时所处的语汇单元。

因此一个变量X用在一条单独的函数子句中，它的值就不能用于这个子句外面。







### 整数

erlang不需要使用特定字长（word size）来表示整数，并且整数运算是精确的，无需担心运算溢出的问题。





### 浮点数

erlang的内部使用64位的IEEE754-1985浮点数，因此使用浮点数的程序会存在浮点数取整和精度问题。

- 除法运算总会得到一个浮点数。
- div与rem运算得到的是整数，div会舍去小数点，rem是求余数。



### 元组

元组是由若干关联性的项目组成而成。创建元组的方法是用大括号把想要的值括起来，再用逗号分隔开。

#### 创建

声明时自动创建，不使用时由erlang垃圾回收器回收。

```erlang
{person, {name, "li"}, {age, 20}}
```

一般的元组的第一项是一个原子，用于说明该元组，这有益于读取代码。



### 提取元素的值

元组的值使用模式匹配操作符 = 来进行提取。

我们编写与元素结构相同的模式，在待提取值得位置加入未绑定变量来提取元素的值。

```erlang
Node = {node, {name: 'xiaoli'}}.

%% 提取name项
{_, {name: Name}} = Node.
```

_ 是占位符，表示不感兴趣的变量。





### 列表

用于存放任意数量的事务。列表用中括号括起来，中间可以存放任何元素，用逗号分隔。



#### 定义列表

如果T是一个列表，那么[H|T]也是一个列表。H是列表头，T是列表尾，竖线用于把列表头和尾分隔开。

只要用[... | T]语法构建的列表，就应该确保T是一个列表。如果T不是列表，构建的就是不正确的列表，大多数库函数假定列表是有正确格式的，无法用于不正确格式的列表。

可以给列表添加多个头，写法是：[E1, E2, ..., En | T]

```erlang
ThingsToBuy = [apples, pears, milk].
ThingsToBuy1 = [oranges, newspaper | ThingsToBuy].
```



#### 提取列表元素

根据列表的定义使用模式匹配来提取列表元素。















### 字符串

erlang的字符串是用整数列表或二进制型来表示的。

如果用整数列表来表示一个字符串，每个元素都代表了一个Unicode代码点（codepoint）。比如字符串字面量本质上就是一个整数列表，每个元素都是对应字符的整数字符代码。



- 字符串字面量：erlang用双引号括一串字符来表示字符串。





### 二进制型

二进制型是介于双小括号和双大括号之间的一列整数或字符串。

在erlang种，二进制型默认使用8位（1个子节）来分隔并存储数据。比如<<1, 15>>，该表达式实际是<<1:8, 15:8>>，将数字1和15分别以8位来进行打包，相当于二进制的0000 0001 0000 1111。

如果一个二进制型的每个元素都对应ASCII码字符，那它也能表示字符串。比如<<97, 98, 99>>将会输出<<"abc">>。

- binary

  二进制型，它的总位数是8的倍数。

- bitstring

  位串，它的总位数不是8的倍数，binary是bitstring的特殊类型。

example：

```erlang
X = <<1, 17, 42:16>>.
X.
```

