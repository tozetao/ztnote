### 变量

erlang的变量是一次性赋值变量，它只能被赋值一次，如果试图再变量被设置后改变它的值就会得到一个错误。



=号是模式匹配操作符，并不等同于c系列语言的赋值。

> X  = expression

上面整个表达式的含义是对 = 号右边的表达式进行计算，将计算结果与X变量进行匹配。如果X变量未绑定值，那么将计算结果与其进行绑定；如果X绑定了值，那么将计算结果与X进行匹配。

```erlang
%% 第一次对X进行绑定
X = 2 + 4.

%% 第二次是对X模式匹配，X是等于6的。如果不匹配将会报错。
X = 6
```



未绑定变量：变量还没有绑定值

已绑定变量：变量已经绑定值





### 作用域

变量的作用域是它声明时所处的语汇单元。

因此一个变量X用在一条单独的函数子句中，它的值就不能用于这个子句外面。







### 整数

erlang不需要使用特定字长（word size）来表示整数，并且整数运算是精确的，无需担心运算溢出的问题。





### 浮点数

erlang的内部使用64位的IEEE754-1985浮点数，因此使用浮点数的程序会存在浮点数取整和精度问题。

- 除法运算总会得到一个浮点数。
- div与rem运算得到的是整数，div会舍去小数点，rem是求余数。



### 元组

元组是由若干关联性的项目组成而成。创建元组的方法是用大括号把想要的值括起来，再用逗号分隔开。

#### 创建

声明时自动创建，不使用时由erlang垃圾回收器回收。

```erlang
{person, {name, "li"}, {age, 20}}
```

一般的元组的第一项是一个原子，用于说明该元组，这有益于读取代码。



### 提取元素的值

元组的值使用模式匹配操作符 = 来进行提取。

我们编写与元素结构相同的模式，在待提取值得位置加入未绑定变量来提取元素的值。

```erlang
Node = {node, {name: 'xiaoli'}}.

%% 提取name项
{_, {name: Name}} = Node.
```

_ 是占位符，表示不感兴趣的变量。





### 列表

用于存放任意数量的事务。列表用中括号括起来，中间可以存放任何元素，用逗号分隔。



#### 定义列表

如果T是一个列表，那么[H|T]也是一个列表。H是列表头，T是列表尾，竖线用于把列表头和尾分隔开。

只要用[... | T]语法构建的列表，就应该确保T是一个列表。如果T不是列表，构建的就是不正确的列表，大多数库函数假定列表是有正确格式的，无法用于不正确格式的列表。

可以给列表添加多个头，写法是：[E1, E2, ..., En | T]

```erlang
ThingsToBuy = [apples, pears, milk].
ThingsToBuy1 = [oranges, newspaper | ThingsToBuy].
```



#### 提取列表元素

根据列表的定义使用模式匹配来提取列表元素。















### 字符串

erlang的字符串是用整数列表或二进制型来表示的。

如果用整数列表来表示一个字符串，每个元素都代表了一个Unicode代码点（codepoint）。比如字符串字面量本质上就是一个整数列表，每个元素都是对应字符的整数字符代码。



- 字符串字面量：erlang用双引号括一串字符来表示字符串。





### 二进制型

二进制型是介于双小括号和双大括号之间的一列整数或字符串。

在erlang种，二进制型默认使用8位（1个子节）来分隔并存储数据。比如<<1, 15>>，该表达式实际是<<1:8, 15:8>>，将数字1和15分别以8位来进行打包，相当于二进制的0000 0001 0000 1111。

如果一个二进制型的每个元素都对应ASCII码字符，那它也能表示字符串。比如<<97, 98, 99>>将会输出<<"abc">>。

- binary

  二进制型，它的总位数是8的倍数。

- bitstring

  位串，它的总位数不是8的倍数，binary是bitstring的特殊类型。



#### 二进制型的相关函数

> list_to_binary(L) -> B

该函数返回一个二进制型，它会将一个iolist压扁后转成二进制型。

iolist是指一个列表包含的元素是0至255的整数、二进制型或其他iolist。



> split_binary(Bin, Pos) -> {Bin1, Bin2}

在Pos指定的字节处将Bin分隔成俩个二进制型。Pos是从1开始进行精算的。



> term_to_binary()



> binary_to_trem()















### 位语法表达式

位语法表达式用于构建二进制型或位串，它的形式如下：

<<E1, E2, ... , En>>，每个Ei元素标识出二进制型或位串里的一个片段，单个Ei元素的形式如下：

Ei = Value:Size/TypeSpecifierList



#### Value

Value是值，打包时Value可以是integer、float、字符串型的绑定变量，或者是能够返回这类类型的表达式。在模式匹配是，可以是已绑定变量或未绑定变量。



#### Size

Size指定片段的大小，即Value的大小。Value的类型会影响Size的单位。integer、float型Size的单位是bit位。二进制型Size的单位是子节。

Size有默认值，根据Value的类型默认值是不同的，integer型默认值是8，float默认值是64，binary默认值是1，即1个子节。

要注意的是在匹配模式里，只能对最后一个元素使用默认值。

example：测试Size的单位

```erlang
%% intger、float型的单位是位
<<A:8,B:8,C:16>>  = <<1,17,42:16>>.
A.		%% 1
B.		%% 17

<<F1:32,F2:32>>   = <<3.14:64/float>>.

%% binary型的单位是1个子节
<<C1:1/binary, C2:4/binary>> = <<"abcde">>.
C1.		%% a
C2.		%% bcde
```

example：测试Size的默认值

```erlang
<<10>>.		
<<10:8>>.	%% 俩个表达式返回相同的结果

<<3.14/float>>.
<<3.14:64/float>>.	%% 俩个表达式等价

<<C/binary>> = <<"a">>.
```



#### TypeSpecifierList

TypeSpecifierList是由多个项组成，形式为End - Sign - Type - Unit组成，这些项没有特定顺序，可以任意组合。



- Type

  Type是Value的类型，它可以是integer、float、binary、bitstring、utf8、utf16、utf32，默认值是integer。

  打包时表示要将什么类型的数据打包成二进制，模式匹配时表示将二进制解包成指定类型的数据。

- End

  End是字节序，可以是big、little、native，默认值是big。

  它只和打包或解包整数和浮点数有关，打包时表示用指定的字节序打包，解包也是同样的道理。

- Sign

  可以是unsigned、signed，默认值是unsigned，只用于模式匹配。

- Unit

  Unit一般用于字节对齐，它的写法是unit:1|2|...256，integer、float和bitstring的Unit默认值是1，binary则是8。
  
  size和unit的积就是数据占用的二进制位数，这里说明下binary的unit是8，是因为binary型size的单位是字节，因此是8。
  
  

```erlang
%% 数据所占bit位的计算方法为：size * unit，也就是说它决定了你用多少位来存储数据。
<<25:4/unit:8>>.
<<24:2/unit:16>>.
<<25:1/unit:32>>
```



二进制型参考：https://www.cnblogs.com/me-sa/archive/2011/12/25/erlang0024.html









### 位串（bitstring）

数据长度不满足8位倍数的二进制型称为位串。

位串可以方便地处理位级数据。在匹配模式是位级操作，比如要处理没有按照8位边界对齐或者可变长度数据。

tips：一般c系语言的最小可寻址单元的宽度通常是8位，比如c语言一个char是8位，操作char里的位非常麻烦，需要移位、掩码等操作。



example：

```erlang
%% 匹配二进制整数
<<2#1000:4, B10:4>> = <<135>>
```





不同的字节序打包的结果是不同的，俩种打包方式如下：

位串在大端序的打包方式：

1. 将打包的数转成二进制数
2. 若打包的位数大于二进制数的位数，会对二进制数高位补0直至满足打包位数。
3. 针对二进制数从高位往低位，每8位一组进行打包，最后一组剩余的位数单独作为的片段。

```erlang
<<35891:19>>. %% 输出<<17,134,3:3>>

%% 17二进制：00010001
%% 134二进制：10000110
%% 3:3二进制：011
%% 000 10001100 00110011
```

35891的二进制数为：10001100 00110011，高位补0补满19位，变为000 10001100 00110011，最后每8位分隔即可。

bitstring小端序的打包方式：

1. 将打包的数转成二进制数

```erlang
<<35891:19/little>>.
```

2#1000110000110011
00110011
10001100
000

小端序是高位字节存储在高地址，低位字节存储在低地址。
因此在以小端序打包时，会从右往左边切割，每8位一组，剩余的位数作为一组。



