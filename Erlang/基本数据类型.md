### 变量

erlang的变量是一次性赋值变量，它只能被赋值一次，如果试图再变量被设置后改变它的值就会得到一个错误。



=号是模式匹配操作符，并不等同于c系列语言的赋值。

> X  = expression

上面整个表达式的含义是对 = 号右边的表达式进行计算，将计算结果与X变量进行匹配。如果X变量未绑定值，那么将计算结果与其进行绑定；如果X绑定了值，那么将计算结果与X进行匹配。

```erlang
%% 第一次对X进行绑定
X = 2 + 4.

%% 第二次是对X模式匹配，X是等于6的。如果不匹配将会报错。
X = 6
```



未绑定变量：变量还没有绑定值

已绑定变量：变量已经绑定值





### 作用域

变量的作用域是它声明时所处的语汇单元。

因此一个变量X用在一条单独的函数子句中，它的值就不能用于这个子句外面。







### 整数

erlang不需要使用特定字长（word size）来表示整数，并且整数运算是精确的，无需担心运算溢出的问题。





### 浮点数

erlang的内部使用64位的IEEE754-1985浮点数，因此使用浮点数的程序会存在浮点数取整和精度问题。

- 除法运算总会得到一个浮点数。
- div与rem运算得到的是整数，div会舍去小数点，rem是求余数。



### 元组

元组是由若干关联性的项目组成而成。创建元组的方法是用大括号把想要的值括起来，再用逗号分隔开。

#### 创建

声明时自动创建，不使用时由erlang垃圾回收器回收。

```erlang
{person, {name, "li"}, {age, 20}}
```

一般的元组的第一项是一个原子，用于说明该元组，这有益于读取代码。



### 提取元素的值

元组的值使用模式匹配操作符 = 来进行提取。

我们编写与元素结构相同的模式，在待提取值得位置加入未绑定变量来提取元素的值。

```erlang
Node = {node, {name: 'xiaoli'}}.

%% 提取name项
{_, {name: Name}} = Node.
```

_ 是占位符，表示不感兴趣的变量。





### 列表

用于存放任意数量的事务。列表用中括号括起来，中间可以存放任何元素，用逗号分隔。



#### 定义列表

如果T是一个列表，那么[H|T]也是一个列表。H是列表头，T是列表尾，竖线用于把列表头和尾分隔开。

只要用[... | T]语法构建的列表，就应该确保T是一个列表。如果T不是列表，构建的就是不正确的列表，大多数库函数假定列表是有正确格式的，无法用于不正确格式的列表。

可以给列表添加多个头，写法是：[E1, E2, ..., En | T]

```erlang
ThingsToBuy = [apples, pears, milk].
ThingsToBuy1 = [oranges, newspaper | ThingsToBuy].
```



#### 提取列表元素

根据列表的定义使用模式匹配来提取列表元素。















### 字符串

erlang的字符串是用整数列表或二进制型来表示的。

如果用整数列表来表示一个字符串，每个元素都代表了一个Unicode代码点（codepoint）。比如字符串字面量本质上就是一个整数列表，每个元素都是对应字符的整数字符代码。



- 字符串字面量：erlang用双引号括一串字符来表示字符串。



































二进制型

二进制型是介于双小括号和双大括号之间的一列整数或字符串。

如果由整数组成，每个整数必须是0-255之间；如果二进制型是字符串，那么这个二进制型的其实是由这些字符的ASCII编码组成的。

本质上二进制型是由数字组成的。

```erlang
%%  这俩个二进制型是相匹配的
<<"ABC">> = <<65,66,67>>
```



操作二进制型

> list_to_binary(L) -> B

将一个列表转成二进制型，L中的元素可以是0至255的整数、二进制型或其他列表。



> term_to_binary(Term) -> Bin

将任意erlang数据类型转成个一个二进制型。

生成的二进制型使用了外部数据格式（external term format）。



> binary_to_term(Bin) -> Term

将二进制型转成erlang数据类型



> byte_size(Bin) -> Size

返回二进制型里的字节数。





位语法

用于从二进制数据里提取或加入单独的位或者位串。

- 打包，将多个变量打包成二进制，且每个变量占据指定的位数。

  比如将X、Y、Z三个变量打包进一个16位的内存区域，X占3位，Y占7位，Z占6位，可以这样做。

  <<X:3, Y:7, Z:6>>

- 解包：与打包相反的过程，将二进制数据解码成我们想要的数据。

example：打包和解包16位颜色，红色和蓝色分配5位，绿色分配6位。

```erlang
Red = 15.
Blue = 211.
Green = 55.

%% 打包
Mem = <<Red:5, Green:6, Blue:5>>

%% 解包
<<R1:5, G1:6, B1:5>> = Mem.
```



位语法表达式









一个字节是8位，二进制型里的位数大多数是8的整数倍，因此对应一个字符串。

如果位数不是8的倍数，那么这段数据称为位串（bitstring）。



binary：二进制型，它的总位数是8的倍数。

bitstring：位串，它的总位数不是8的倍数。

