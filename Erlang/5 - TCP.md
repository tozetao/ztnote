### 控制进程

创建某个套接字的进程被称为该套接字的控制进程。所有来自套接字的消息都会被发送到控制进程。如果控制进程挂了，该套接字就会被关闭。

某个套接字的控制进程可以通过调用gen_tcp:controlling_process(Socket, NewPid)为该套接字指定新的控制进程。



### 套接字模式

erlang的套接字有三种打开模式：主动（active）、被动（passive）和单次主动（active once）。

这是通过gen_tcp:connect()或gen_tcp:listen()的Options参数的active选项来设置的。



#### 主动模式

被动模式通过{active: true}打开。

当一个主动套接字被创建后，它会在收到数据时向控制进程发送{tcp, Socket, Data}消息。控制进程是无法控制这些消息流的。

主动模式是非阻塞式的，使用这种方式的服务器被称为非阻塞式服务器。它的缺点在于客户端可以随意地向服务器发送数据，如果服务器处理消息的速度慢于客户端，那么消息会被积压在消息缓存区，系统可能会异常或者崩溃。



#### 被动模式

被动模式通过{active: false}打开。

当一个被动套接字被创建后，控制进程只能通过gen_tcp:recv(Socket, N)来从这个套接字读取数据。N表示读取N个字节，如果N=0将会读取全部可用字节。

被动模式的套接字是阻塞式的，如果控制进程不从套接字读取数据，客户端发送数据时会阻塞，知道服务器条用recv为止。



### 混合模式

单次主动的套接字可以认为是混合模式，通过{active: once}打开。

单次模式既不是阻塞的也不是非阻塞的，而是俩种模式的混合。设置成单次主动的套接字是主动的，但是只针对一次消息，控制进程在接收一次消息后，必须通过inet:setopts()才能重启下一个消息的接受，在重启之前系统是阻塞的。

```erlang
{ok, Listen} = gen_tcp:listen(Port, [...{active: once}...]),

```





