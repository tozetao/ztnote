

### 玩家进程的初始化

role.erl是玩家模块，由gen_server实现。玩家进程初始化时会调用role:init/1函数。

```erlang
start(Role = #role{}) ->
    gen_server:start(?MODULE, [Role], []).

init([Role = #role{socket_pid = SocketPid, role_id = RoleID}]) ->
    process_flag(trap_exit, true),
    
    %% 存储连接进程pid，让玩家进程绑定连接进程
    put(socket_pid, SocketPid),
    link(SocketPid),
    
    %% 向连接进程发送一条存储玩家进程id的消息
    SocketPid ! {save_role_pid, self(), RoleID},
    
    %% 创建俩个定时器，向自身发送俩条消息
    erlang:send_after(date:next_diff(0, 0, 0) * 1000, self(), zero_flush),
    erlang:send_after(date:next_diff(8, 0, 0) * 1000, self(), daily_gift_flush),
    
    %% 处理玩家登陆的业务逻辑，如统计留存数据，接收邮件列表等
    NewRole = role_login:do(Role#role{pid = self()}),
    
    %% 向自身发送init消息
    self() ! init,
    
    {ok NewRole}.
```

上述代码分别做了以下处理：

- 玩家进程字典存储连接进程id
- 与连接进程相互建立链接
- 处理玩家登陆业务
- 向自身发送一条init消息，该消息主要是让进程定时执行一些任务，如gc清理等。





### 玩家进程的定时任务

```erlang
handle_info(init, Role) ->
    self() ! loop,
    {noreply, Role}.
handle_info(loop, Role = #role{role_id = RoleId, ...}) ->
	...
```

在init/1函数中可以看到向自身发送了一条init消息，在处理这条消息时回向自身再发送一条loop消息，这里都是一些需要定时处理的任务，回头再来分析。













### 玩家进程的终止

我们用连接进程来表示玩家的连接状态，如果连接进程终止退出，那么就表示该玩家已经断开连接退出游戏了。

由于玩家进程与连接进程相互建立链接的，当连接进程退出时我们能收到一条{'EXIT', Pid, Why}的消息，以下是处理连接断开的代码。

```erlang
%% 连接器进程异常退,只处理玩家 延迟1分钟
handle_info({'EXIT', SocketPid, _Why}, Role = #role{socket_pid = SocketPid}) ->
    %% 1分钟后像自身发送一条stop消息
    Ref = erlang:send_after(60000, self(), stop),
    
    %% 存储stop定时器应用，在重连的时候会进行检测。
    put(stop, Ref),
    
    %% ets表中更新用户数据
    role_data:update_online_role(Role),
    {noreply, Role};
```

上面的代码主要是在ets表中更新玩家数据，并在1分钟后停止进程。值得注意的是Role = #role{socket_pid = SocketPid}参数，它表示我只收到和我建立链接关系的连接进程的异常消息，其他连接进程（可能是以前连接的连接进程）我是不关注的。



当stop定时器生效的时候就会执行下面的代码，终止玩家进程并进行清理。

```erlang
handle_info(stop, Role) ->
    {stop, normal, Role};

terminate(_Reason, Role) ->
    role_out:do(Role),
    ok.
```

role_out:do/1函数它会从ets表中删除玩家数据，同时更新dets和数据库的玩家数据，这俩点是我们目前要了解的。









### 断线重连

什么情况下可以进行断线重连？

ets表中的玩家数据表示玩家是否在线，如果在ets表中查找到玩家数据就会尝试断线重连，这是因为玩家进程初始化的时候就会在ets表中存储玩家数据了。



这是微信断线重连所作的处理：

```erlang
%% 微信断线重连处理
%% Pid：连接进程id
handle_call({reconnect, Pid, Ip, OpenID, RedId, PayId}, _From, Role = #role{socket_pid = OldPid, role_id = RoleID}) ->
    %% 检查进程字典是否有stop定时器，有的话清除
    case get(stop) of
        undefined -> ok;
        Ref ->
            erlang:cancel_timer(Ref)
    end,
    
    %% 向原有的连接进程发送错误信息
    sys_conn:pack_send(OldPid, 1099, #m_1099_toc{error_code = ?error_login_other}),
    
    %% 停止旧的连接进程，如果存在的话
    OldPid ! timeout,
    
    %% 存储新的连接进程id
    put(socket_pid, Pid),
    
    %% 相互建立链接关系
    link(Pid),
    Pid ! {save_role_pid, self(), RoleID},
    
    %% 更新新的玩家数据
    NewRole = Role#role{socket_pid = Pid, ip = Ip, open_id = OpenID, red_openid = RedId, pay_openid = PayId},
    role_data:update_online_role(NewRole),
    boradcast_mgr:reconnect(NewRole),
    
    %% 响应
    {reply, role_conver:to_login_role(NewRole), NewRole};
```

在上面的代码中可以看到一个stop定时器，该定时器会在连接进程异常退出，即玩家进程收到{'EXIT', Pid, Why}消息的时候创建。

```erlang
%% 玩家进程收到EXIT消息
handle_info({'EXIT', SocketPid, _Why}, Role = #role{socket_pid = SocketPid}) ->
    %% 60秒后停止玩家进程
    Ref = erlang:send_after(60000, self(), stop),
    
    %% 在进程字典里面存储stop定时器
    put(stop, Ref),
    
    role_data:update_online_role(Role),
    {noreply, Role};
```













### role_login.erl

role_login模块处理登陆的相关业务逻辑，当玩家进程启动的时候会调用它。

```erlang
do(Role = #role{login_time = Time, role_id = RoleId}) -> 
    Now = date:unixtime(),

	%% 以下都是各个模块需要针对登陆用户的业务逻辑处理。
    
    %% 农场处理
    Role1 = farm_mgr:login(Role),
    
    %% 暂时不清楚，应该比较重要
    Role2 = case date:is_same_day(Time, Now) of
        true ->
            Role1;
        _ ->
            role:do_zero_flush(Role1)
    end,
    
    Role3 = mail_mgr:login(Role2),
    Role4 = do_skill(Role3, Now),
    Role5 = task:login(Role4),
    Role6 = task_mgr:get_task(Role5),
    Role7 = do_vip(Role6),
    Role8 = do_daily_gift(Role7, Now),
    Role9 = pet_mgr:check_pt(Role8),
    
    Role10 = role_lib:do_set_sheep(Role9),
    RoleEnd = Role10,

    rank:handle(?rank_coin, RoleEnd),
    rank:handle(?rank_lollipop, RoleEnd),
    boradcast_mgr:login(RoleEnd),

	%% 缓存玩家数据，其实就是将玩家数据存储到ets表中。
    role_data:sync_online_role(RoleEnd),
	
	%% 玩家日志的统计，如3日、7日留存等数据
    role_account_mgr:login(Role),

    pet_mgr:login(RoleEnd),

	%% 更新在线状态
    db:exec("update role set off = 0 where role_id = ?", [RoleId]),

	%% 更新role记录的在线时间、在线状态、状态等，最后返回该记录结构
    RoleEnd#role{login_time = Now, status = ?status_normal, off = 0, hit_num = 0}.
```

- role_lib_do_set_sheep

  处理羊毛党

- role_data:sync_online_role

  缓存玩家数据



### role_data.erl

负责处理玩家数据的模块，我觉得这里划分的不好。针对不同源划分为不同个文件会更好。

```erlang
sync_online_role(Role) ->
    OnlineRole = role_convert:to_online(Role),
    ?MODULE ! add,
    ets:insert(online_role, OnlineRole).

handle_info(add, State = #state{num = Num}) ->
    {noreply, State#state{num = Num + 1}}.
```

sync_online_role/1主要用ets来存储玩家数据。

