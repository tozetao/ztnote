### login_rpc.erl

提供登陆的一系列接口。

```erlang
handle(1001, #m_1001_tos{...}) ->
    ...
```

1001协议是微信登陆的接口。主要调用login模块的weixin_login函数来处理微信登陆。



### login.erl

```erlang
weixin_login({..., RoleId = 0, ...}, State) ->
	...
		do_login({OpenID, NickName, Icon, Sex, ParentID, ..., RoleID, Flag}, State);
	...
```

这是微信登陆的处理接口，省略的代码是使用各种code做授权操作，核心处理要看do_login/2函数。

```erlang
do_login({..., RoleID = 0, ...}, State) ->
	case get_role_id([{openid, OpenID}, {redopenid, RedOpenId}, {payopenid, PayOpenID}]) of
        
	end.
```



如果玩家未注册会做以下处理：

- pet_mgr模块会存储该玩家数据

- 创建玩家记录，在数据库中插入记录
- 启动一个玩家进程
- 判断是否有上级玩家并进行处理
- 将玩家记录结构进行转换
- 设置连接进程的State，即将#conn记录的pid_object字段设为玩家进程的id，将玩家进程绑定到连接进程。
- 返回处理结果



如果是注册玩家会做以下处理：

首先判断玩家是否在黑名单中：

- 如果存在黑名单中则返回错误信息，不允许玩家登陆。

玩家在正常的情况下会有俩种处理：

- 一种是断线重连的处理
- 一种是正常登陆处理

对于断线重连，代码会从ets表中查询玩家数据判断是否在线，如果查询到数据则表示玩家在线，这时会尝试断线重连操作；

对于正常登陆的处理，会根据RoleID先从dets查询玩家数据，接着处理玩家登陆业务；如果dets没有玩家数据，则从数据库进行查找，再接着处理玩家登陆业务。

```erlang
case role_var:update_var(Term) of
	{ok, Role = #role{role_id = RoleId}} ->
        case ParentID =:= 0 orelse ParentID =:= RoleId of
            true -> ok;
            _ ->
                pet_mgr:add_friend(RoleId, ParentID)
        end,
        {ok, Pid} = role:start(Role#role{socket_pid = self(), icon = Icon, ip = IP, screat = Screat, open_id = OpenId, red_openid = RedId, pay_openid = PayId}),
        {ok, role_conver:to_login_role(Role), Screat, State#conn{pid_object = Pid, role_id = RoleId}};
_Err ->
        ?ERR("数据库读取玩家数据错误~w", [_Err]),
	{false, ?error_role_data}
end;
```

这是处理玩家登陆的主要逻辑，与创建玩家时的几个步骤是相同的，首先处理上级pid的逻辑，接着启动一个玩家进程，最后返回处理好的数据。











问题汇总：

- 玩家下线处理

- 怎么处理断线重连？
- 什么情况下触发断线重连？允许多长时间内断线重连？

- get_role_from_dets()做什么用的？



想法：

用户注册是直接注册的，并没有我所想的使用队列来处理，减小数据库插入压力。





### role.erl

role.erl是玩家模块，由gen_server实现。

```erlang
start(Role = #role{}) ->
    gen_server:start(?MODULE, [Role], []).

init([Role = #role{socket_pid = SocketPid, role_id = RoleID}]) ->
    process_flag(trap_exit, true),
    
    %% 存储连接进程pid，让玩家进程绑定连接进程
    put(socket_pid, SocketPid),
    link(SocketPid),
    
    %% 向连接进程发送一条存储玩家进程id的消息
    SocketPid ! {save_role_pid, self(), RoleID},
    
    %% 创建俩个定时器，向自身发送俩条消息
    erlang:send_after(date:next_diff(0, 0, 0) * 1000, self(), zero_flush),
    erlang:send_after(date:next_diff(8, 0, 0) * 1000, self(), daily_gift_flush),
    
    %% 处理玩家登陆的业务逻辑，如统计留存数据，接收邮件列表等
    NewRole = role_login:do(Role#role{pid = self()}),
    
    %% 向自身发送init消息
    self() ! init,
    
    {ok NewRole}.
```

这是玩家进程的初始化处理，最重要的是绑定连接进程，并处理玩家登陆后的一些业务逻辑，它是由role_login模块负责的。

俩个定时器暂时不知道用途，后续再看。



```erlang
handle_info(init, Role) ->
    self() ! loop,
    {noreply, Role}.
handle_info(loop, Role = #role{role_id = RoleId, ...}) ->
	...
```

在init/1函数中可以看到向自身发送了一条init消息，在处理这条消息时回向自身再发送一条loop消息，这里都是一些需要定时处理的任务，回头再来分析。





### role_login.erl

role_login模块处理登陆的相关业务逻辑，当玩家进程启动的时候会调用它。

```erlang
do(Role = #role{login_time = Time, role_id = RoleId}) -> 
    Now = date:unixtime(),

	%% 以下都是各个模块需要针对登陆用户的业务逻辑处理。
    
    %% 农场处理
    Role1 = farm_mgr:login(Role),
    
    %% 暂时不清楚，应该比较重要
    Role2 = case date:is_same_day(Time, Now) of
        true ->
            Role1;
        _ ->
            role:do_zero_flush(Role1)
    end,
    
    Role3 = mail_mgr:login(Role2),
    Role4 = do_skill(Role3, Now),
    Role5 = task:login(Role4),
    Role6 = task_mgr:get_task(Role5),
    Role7 = do_vip(Role6),
    Role8 = do_daily_gift(Role7, Now),
    Role9 = pet_mgr:check_pt(Role8),
    
    Role10 = role_lib:do_set_sheep(Role9),
    RoleEnd = Role10,

    rank:handle(?rank_coin, RoleEnd),
    rank:handle(?rank_lollipop, RoleEnd),
    boradcast_mgr:login(RoleEnd),

	%% 缓存玩家数据，其实就是将玩家数据存储到ets表中。
    role_data:sync_online_role(RoleEnd),
	
	%% 玩家日志的统计，如3日、7日留存等数据
    role_account_mgr:login(Role),

    pet_mgr:login(RoleEnd),

	%% 更新在线状态
    db:exec("update role set off = 0 where role_id = ?", [RoleId]),

	%% 更新role记录的在线时间、在线状态、状态等，最后返回该记录结构
    RoleEnd#role{login_time = Now, status = ?status_normal, off = 0, hit_num = 0}.
```

- role_lib_do_set_sheep

  处理羊毛党

- role_data:sync_online_role

  缓存玩家数据



### role_data.erl

负责处理玩家数据的模块，我觉得这里划分的不好。针对不同源划分为不同个文件会更好。

```erlang
sync_online_role(Role) ->
    OnlineRole = role_convert:to_online(Role),
    ?MODULE ! add,
    ets:insert(online_role, OnlineRole).

handle_info(add, State = #state{num = Num}) ->
    {noreply, State#state{num = Num + 1}}.
```

sync_online_role/1主要用ets来存储玩家数据。





一会儿对比下转换和不转换结构有什么不同。