### 微信登陆

login_rpc模块提供登陆的一系列接口。

```erlang
handle(1001, #m_1001_tos{...}) ->
    ...
```

1001协议是微信登陆的接口。主要调用login模块的weixin_login函数来处理微信登陆。



以下是login:weixin_login/2函数的代码：

```erlang
weixin_login({..., RoleId = 0, ...}, State) ->
	...
		do_login({OpenID, NickName, Icon, Sex, ParentID, ..., RoleID, Flag}, State);
	...
```

这是微信登陆的处理接口，省略的代码是使用各种code做授权操作，核心处理要看do_login/2函数。

```erlang
do_login({..., RoleID = 0, ...}, State) ->
	case get_role_id([{openid, OpenID}, {redopenid, RedOpenId}, {payopenid, PayOpenID}]) of
        
	end.
```

首先会判断玩家是否注册，如果玩家未注册会做以下处理：

- pet_mgr模块会存储该玩家数据

- 创建玩家记录，在数据库中插入记录
- 启动一个玩家进程
- 判断是否有上级玩家并进行处理
- 将玩家记录结构进行转换
- 设置连接进程的State，即将#conn记录的pid_object字段设为玩家进程的id，将玩家进程绑定到连接进程。
- 返回处理结果



如果是注册玩家会做以下处理：

首先判断玩家是否在黑名单中：

- 如果存在黑名单中则返回错误信息，不允许玩家登陆。

玩家在正常的情况下会有俩种处理：

- 一种是断线重连的处理
- 一种是正常登陆处理

对于断线重连，代码会从ets表中查询玩家数据判断是否在线，如果查询到数据则表示玩家在线，这时会尝试断线重连操作；

对于正常登陆的处理，会根据RoleID先从dets查询玩家数据，接着处理玩家登陆业务；如果dets没有玩家数据，则从数据库进行查找，再接着处理玩家登陆业务。

```erlang
case role_var:update_var(Term) of
	{ok, Role = #role{role_id = RoleId}} ->
        case ParentID =:= 0 orelse ParentID =:= RoleId of
            true -> ok;
            _ ->
                pet_mgr:add_friend(RoleId, ParentID)
        end,
        {ok, Pid} = role:start(Role#role{socket_pid = self(), icon = Icon, ip = IP, screat = Screat, open_id = OpenId, red_openid = RedId, pay_openid = PayId}),
        {ok, role_conver:to_login_role(Role), Screat, State#conn{pid_object = Pid, role_id = RoleId}};
_Err ->
        ?ERR("数据库读取玩家数据错误~w", [_Err]),
	{false, ?error_role_data}
end;
```

这是处理玩家登陆的主要逻辑，与创建玩家时的几个步骤是相同的，首先处理上级pid的逻辑，接着启动一个玩家进程，最后返回处理好的数据。











