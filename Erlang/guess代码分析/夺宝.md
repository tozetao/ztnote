### treasure_mgr.erl

```erlang
-record(treasure, {
         id = 0           %% 道具唯一id
        ,type = 1         %% 道具类型（游戏里面道具才用）
        ,treasure_num = 1 %% 夺宝期数
        ,sub_type = 1     %% 道具分类（0游戏道具，1自定义道具）
        ,price = 1        %% 总价格
        ,num = 1          %% 道具数量
        ,icon = ""        %% 道具图标
        ,name = ""        %% 道具名字
        ,desc = ""        %% 道具描述
        ,buy_price = 1    %% 单个价格
        ,buy_type = 1     %% 夺宝类型
        ,buy_num = 0      %% 夺宝次数
        ,all_num = 0      %% 总次数
        ,now_treasure_num = 0  %% 当前夺宝编号
        ,list = []        %% 夺宝码
        ,role_list = []   %% 参与夺宝的人物信息
        ,on_sale = 0      %% 是否上架
        ,condition = 0     %% 0没有，1特惠，2vip，3秒杀, 4限时
        ,vip = 0          %% vip需求
        ,old_price = 0    %% 原价格
        ,start_time = 0   %% 开始时间
        ,end_time = 0     %% 结束时间
        ,stock = -1        %% 库存
    }
).
```

now_treasure_num：当前夺宝编号？预计是用于开奖的。

all_num：总购买次数

role_list：一个列表，存储参与的玩家信息

list：夺宝码，跟玩家怎么对应的???



重点关注这4个字段。



```erlang
-record(treasure_log, {
        id = {0, 0}   %% 期数，类型
        ,time = 0     %% 开奖时间
        ,role_id = 0  %% 中奖id
        ,name = ""    %% 中奖名字
        ,icon = ""
        ,luck_num = 0 %% 幸运号码
    }
).
```



```erlang
-record(role_treasure_log, {
        id = {0, 0}   %% 唯一id, 期数
        ,buy_time = 0 %% 购买时间
        ,time = 0     %% 开奖时间
        ,luck_num = 0 %% 幸运号码
        ,num_list = [] %% 夺宝码列表
    }
).
```





ets

- treasure表

  存储treasure记录。每个对象存储的是商品正在开奖的状态。

- treasure_log表

  存储treasure_log记录。即中奖记录。

dets

在磁盘上存储这俩张表的记录，关服的时候会存储到磁盘中。





夺宝初始化

```erlang
init([]) ->
    process_flag(trap_exit, true),
    
    %% 从dets加载treasure、treasure_log俩张表到ets中
    ets:new(treasure, [set, named_table, public, {read_concurrency, true}, {keypos, #treasure.id}]),
    dets:open_file(treasure, [{file, "./dets/treasure.dets"},  {keypos, #treasure.id}, {type, set}]),
    ets:from_dets(treasure, treasure),
    
    ets:new(treasure_log, [set, named_table, public, {read_concurrency, true}, {keypos, #treasure_log.id}]),
    dets:open_file(treasure_log, [{file, "./dets/treasure_log.dets"},  {keypos, #treasure_log.id}, {type, set}]),
    ets:from_dets(treasure_log, treasure_log),
    
    %% 1秒后向自己发送一个reload消息
    erlang:send_after(1000, self(), reload),
    
    State = #state{},
    {ok, State}.
```



reload

```erlang
handle_info(reload, State) ->
    reload(),
    {noreply, State}.

reload() ->
    case db:get_all("select * from treasure_item") of
        {ok, List} ->
            do_reload(List);
        _ ->
            ok
	end.

%% Info是mysql表的一行记录，erlang以一个列表来存储一行记录
do_reload([]) -> ok;
do_reload([Info = [Id | _], L]) ->
    case get_item(Id) of
        {ok, T = #treasure{}} ->
            do_change(T, Info);
        _ ->
            new_treasure(Info);
	end,
    do_reload(L).

%% 从ets表取出的数据与mysql表的数据不一致，因此要进行同步，
do_change(T = #treasure{on_sale = _OnSale1}, [Id, Type, Icon, Name, Desc, Num, Price, BuyType, BuyNum, OnSale, SubType, Condition, Vip, OldPrice, StartTime, EndTime, Stock]) ->
    %% 计算该商品的夺宝总次数
    AllNum = get_all_num(Price, BuyType, BuyNum),
    
    %% 新的treasure
    Treasure = T#treasure{id = Id, type = mail_mgr:to_atom_assets(Type), sub_type = SubType, price = Price, num = Num, icon = Icon, name = Name, desc = Desc, buy_price = BuyNum, buy_type = mail_mgr:to_atom_assets(BuyType), all_num = AllNum, now_treasure_num = init_treasure_num(Id), on_sale = OnSale, condition = Condition, vip = Vip, old_price = OldPrice, start_time = StartTime, end_time = EndTime, stock = Stock},
	
```





停止模块

```erlang
terminate(_Reason, _State) ->
    ets:to_dets(treasure, treasure),
    ets:to_dets(treasure_log, treasure_log),
    ok.
```

分别将ets俩张表的数据存储到磁盘中。





参数夺宝

1. 参数检测

2. 扣除消耗

3. 调用treasure_mgr模块，处理buy消息。

4. 入库

5. 返回响应数据

   

role_lib的send_buffer做什么用的?

购买数量是哪个字段？



获取夺宝信息







role_lib.erl

send_buff_begin()

send_buff_flush()

这个有什么用处？