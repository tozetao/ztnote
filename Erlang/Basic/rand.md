## rand

此模块提供随机数生成器。该模块包含了一些算法，其中均匀分布算法使用了Sebastiano Vigna的扰乱Xorshift算法。正态分布算法使用Marsaglia和Tsang的Ziggurat方法。

提供了以下算法。

- exsplus

  Xorshift116+，58位精度，周期为2^116-1。

- exs64

  Xorshift64*，64位精度，周期为2^64-1。

- exs1024

  Xorshift1024*，64位精度，周期为2^1024-1。



默认算法是exsplus。如果需要特定的算法，确保始终使用 seed/1 来初始化状态。

每次请求一个随机数时，都会使用一个状态来计算它，并产生一个新的状态。状态可以是隐式的，也可以是显式的参数和返回值。

隐式状态的函数使用进程字典变量rand_seed来记忆当前状态。

如果进程在没有先设置种子的情况下调用uniform/0或uniform/1，则会用默认算法自动调用seed/1，并产生一个非常量种子。

具有显式状态的函数从不使用进程字典。



> 上述内容说明

调用seed/1是显示的初始化状态。

没有调用seed/1再调用uniform/0h或uniform/1是隐式初始化状态，erlang会使用默认算法自动调用seed/1。



> Examples：

如果没有指定算法则会用一个非常量种子和默认算法来创建随机数。

```erlang
R1 = rand:uniform().
```









### 关于随机数

每次调用uniform/0或uniform/1都会更新进程字典里的rand_seed变量，同一个进程每次产生随机数时，由于随机种子不同所以产生的随机数时不同的。

但是如果是不同进程分别调用uniform/0函数，因为随机种子的更新算法是一样的，所以每次各进程的随机种子也是相同的，从而生成的随机数也是一样的，要想让不同进程生成的随机数不同，要手动为每个进程设置不同的种子。

这些种子之间的值最好相差大一些，保证各进程生成的随机数值不会接近。

example：

```erlang
_ = rand:seed(exs1024, {123, 12345, 345534}).
R = rand:uniform().
```

上面的俩行代码重复执行可以发现产生的随机数是相同的。

链接参数：https://www.cnblogs.com/unqiang/p/4180748.html

