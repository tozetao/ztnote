### Validating Configuration Values

从各种资源加载配置值后，可以使用Config component的 "Definition"部分来验证这些值和它们的结构。配置值通常被期望显示某种层次结构。而且，值应该具有某种类型，在数量上受到限制，或者是给定的一组值中的一个。例如，下面的配置（YAML格式）显示了一个清晰的层次结构和一些应该应用于它的验证规则（比如："auto_connect的值必须是一个布尔值"）。

```yaml
database:
    auto_connect: true
    default_connection: mysql
    connections:
        mysql:
            host:     localhost
            driver:   mysql
            username: user
            password: pass
        sqlite:
            host:     localhost
            driver:   sqlite
            memory:   true
            username: user
            password: pass
```

当加载多个配置文件时，应该可以合并和覆盖一些值。其他的值不应该被合并，而是保持第一次遇到时的样子。另外，有些键只有在另一个键有特定值时才可用（在上面的配置样本中：memory key只有在驱动是sqlite时才有意义）。

### Defining a Hierarchy of Configuration Values Using the TreeBuilder

使用TreeBuilder定义一个配置值的层次结构。

所有关于配置值的规则都可以用TreeBuilder来定义。一个[TreeBuilder](https://github.com/symfony/symfony/blob/5.4/src/Symfony/Component/Config/Definition/Builder/TreeBuilder.php)实例应该从一个实现了ConfigurationInterface的自定义配置类中返回。

```php
namespace Acme\DatabaseConfiguration;

use Symfony\Component\Config\Definition\Builder\TreeBuilder;
use Symfony\Component\Config\Definition\ConfigurationInterface;

class DatabaseConfiguration implements ConfigurationInterface
{
    public function getConfigTreeBuilder()
    {
        $treeBuilder = new TreeBuilder('database');

        // ... add node definitions to the root of the tree
        // $treeBuilder->getRootNode()->...

        return $treeBuilder;
    }
}
```



### Adding Node Definitions to the Tree

#### Variable Nodes

树包含节点定义(node definitions)，可以用语义学的方式进行布局。这意味着，使用缩进和流畅的符号，有可能反映配置值的真实结构。

```
$rootNode
    ->children()
        ->booleanNode('auto_connect')
            ->defaultTrue()
        ->end()
        ->scalarNode('default_connection')
            ->defaultValue('default')
        ->end()
    ->end()
;
```

根节点本身是一个数组节点，并且有子节点，比如布尔节点auto_connect和标量节点default_connection。一般来说：在定义了一个节点后，调用end()会使你在层次结构中上升一步。



#### Node Type

可以通过使用适当的节点定义(node definition)来验证所提供值的类型。节点类型可用于:

- scalar (generic type that includes booleans, strings, integers, floats and null)

    标量类型（通用类型，包含布尔值、字符串、整型、浮点型和null）

- boolean

- integer

- float

- enum (similar to scalar, but it only allows a finite set of values)

- array

- variable (no validation)

    变量（不验证）

并通过node(\$name, \$type)或其相关的快捷方式 xxxxNode(\$name)方法创建。



#### Numeric Node Constraints

数字节点（浮点数和整数）提供了两个额外的约束--min()和max()--允许验证值。

```
$rootNode
    ->children()
        ->integerNode('positive_value')
            ->min(0)
        ->end()
        ->floatNode('big_value')
            ->max(5E45)
        ->end()
        ->integerNode('value_inside_a_range')
            ->min(-50)->max(50)
        ->end()
    ->end()
;
```



#### Enum Nodes

Enum节点提供了一个约束条件，将给定的输入与一组值相匹配。

```
$rootNode
    ->children()
        ->enumNode('delivery')
            ->values(['standard', 'expedited', 'priority'])
        ->end()
    ->end()
;
```

这将限制delivery 选项为standard、expedited 或priority。

#### Array Nodes

通过添加一个数组节点，可以为层次结构添加一个更深的层次。数组节点本身，可以有一个预定义的变量节点集合（a predefined set of variable nodes）。

```
$rootNode
    ->children()
        ->arrayNode('connection')
            ->children()
                ->scalarNode('driver')->end()
                ->scalarNode('host')->end()
                ->scalarNode('username')->end()
                ->scalarNode('password')->end()
            ->end()
        ->end()
    ->end()
;
```

或者你可以为数组节点内的每个节点定义一个原型(prototype )。

```
$rootNode
    ->children()
        ->arrayNode('connections')
            ->arrayPrototype()
                ->children()
                    ->scalarNode('driver')->end()
                    ->scalarNode('host')->end()
                    ->scalarNode('username')->end()
                    ->scalarNode('password')->end()
                ->end()
            ->end()
        ->end()
    ->end()
;
```

原型（prototype ）可以用来添加一个定义（definition ），这个定义（definition ）可以在当前节点内重复多次。根据上面例子中的原型定义（prototype definition），可以有多个connection数组（包含driver、host等）。

有时，为了改善你的应用程序或bundle的用户体验，你可以允许在需要一个数组值的地方使用一个简单的字符串或数字值。使用castToArray() helper将这些变量变成数组。

```
->arrayNode('hosts')
    ->beforeNormalization()->castToArray()->end()
    // ...
->end()
```



#### Array Node Options

在定义一个数组节点的子节点之前，你可以提供一些选项，比如。

- useAttributeAsKey()
    提供一个子节点的名称，该节点的值应该被用作结果数组中的键。这个方法也定义了配置数组键的处理方式，在下面的例子中解释。
- requiresAtLeastOneElement()
    数组中应该至少有一个元素（仅当isRequired()也被调用时有效）。
- addDefaultsIfNotSet()
    如果任何子节点有默认值，在没有提供明确的值时就使用它们。
- normalizeKeys(false)
    如果调用（false），带有破折号的键不会被规范化为下划线。建议在用户将定义一个键值映射的原型节点中使用，以避免不必要的转换。
- ignoreExtraKeys()
    允许在一个数组下指定额外的配置键（config keys）而不抛出一个异常。

一个基本的原型数组配置（prototyped array configuration）可以定义如下:

```
$node
    ->fixXmlConfig('driver')
    ->children()
        ->arrayNode('drivers')
            ->scalarPrototype()->end()
        ->end()
    ->end()
;
```

When using the following YAML configuration:

```yaml
drivers: ['mysql', 'sqlite']
```

Or the following XML configuration:

```xml
<driver>mysql</driver>
<driver>sqlite</driver>
```

出里后的配置为：

```php
Array(
    [0] => 'mysql'
    [1] => 'sqlite'
)
```

一个更复杂的例子是，定义一个带有children的原型数组:

```
$node
    ->fixXmlConfig('connection')
    ->children()
        ->arrayNode('connections')
            ->arrayPrototype()
                ->children()
                    ->scalarNode('table')->end()
                    ->scalarNode('user')->end()
                    ->scalarNode('password')->end()
                ->end()
            ->end()
        ->end()
    ->end()
;
```

When using the following YAML configuration:

```yaml
connections:
    - { table: symfony, user: root, password: ~ }
    - { table: foo, user: root, password: pa$$ }
```

Or the following XML configuration:

```xml
<connection table="symfony" user="root" password="null"/>
<connection table="foo" user="root" password="pa$$"/>
```

The processed configuration is:

```php
Array(
    [0] => Array(
        [table] => 'symfony'
        [user] => 'root'
        [password] => null
    )
    [1] => Array(
        [table] => 'foo'
        [user] => 'root'
        [password] => 'pa$$'
    )
)
```

前面的输出与预期结果相符。然而，鉴于配置树，当使用以下YAML配置时:

```yaml
connections:
    sf_connection:
        table: symfony
        user: root
        password: ~
    default:
        table: foo
        user: root
        password: pa$$
```

输出的配置将与之前完全一样。换句话说，sf_connection和default配置键会丢失。原因是Symfony配置组件默认将数组视为列表。

> 注：在写这篇文章时，有一个不一致的地方：如果只有一个文件提供有关的配置，键（即sf_connection和default）就不会丢失。但如果有多个文件提供配置，键就会丢失，如上所述。

为了维护数组的key，请使用useAttributeAsKey()方法:

```
$node
    ->fixXmlConfig('connection')
    ->children()
        ->arrayNode('connections')
            ->useAttributeAsKey('name')
            ->arrayPrototype()
                ->children()
                    ->scalarNode('table')->end()
                    ->scalarNode('user')->end()
                    ->scalarNode('password')->end()
                ->end()
            ->end()
        ->end()
    ->end()
;
```

> 注: 在YAML中，useAttributeAsKey()的'name'参数有特殊含义，指的是map的key（本例中的sf_connection和default）。如果为connections节点定义了一个带有键名的子节点，那么该map的key就会丢失。

这个方法的参数（上面例子中的name）定义了添加到每个XML节点的属性名称，以区分它们。现在你可以使用之前显示的YAML配置或以下XML配置。

```xml
<connection name="sf_connection"
    table="symfony" user="root" password="null"/>
<connection name="default"
    table="foo" user="root" password="pa$$"/>
```

在这两种情况下，被处理的配置都保持了sf_connection和default键。

```php
Array(
    [sf_connection] => Array(
        [table] => 'symfony'
        [user] => 'root'
        [password] => null
    )
    [default] => Array(
        [table] => 'foo'
        [user] => 'root'
        [password] => 'pa$$'
    )
)
```



带翻译：

https://symfony.com/doc/5.4/components/config/definition.html#array-node-options