进程向内核注册要监视的文件描述符，在内核发现进程要监视的文件描述符，它们其中有一种或多种IO事件继续的，就通知进程，这种能力被成为IO复用。select、poll和epoo系统调用都支持IO复用。

I/O复用的应用场合：

- 如果一个客户端处理多个描述符，必须使用I/O复用。

- 如果一个服务器既要处理监听套接字，又要处理已连接的套接字，一般会使用I/O复用。

- 如果一个服务器既要处理TCP，又要处理UDP，一般需要使用I/O复用。

I/O复用的优势可以等待多个描述符就绪。



### select

```c
#include <sys/select.h>
#include <sys/time.h>

int select(int maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);
```

该函数允许进程指定内核要监视的文件描述符，并等待描述符中的多个事件中的任何一个发生，并只有在一个或多个时间发生，或经历一段指定的时间后才唤醒它。

意思是：select告诉内核对哪些描述符进行监视以及等待多长时间，监视的事件有：就读、可写或异常事件。

- maxfd

  所监视描述符的最大个数，一般是描述符的值加1

- timeout

  指定内核等待所指定描述符中任何一个事件就绪的时间，即超时时间。

  const限定词用于指针时，可以让指针所指向的内容不被修改。

```c
struct timeval {
    long tv_sec;	//秒
    long tv_usec;	//微秒
}
```

timeout参数可以有三种结果：

- 一直等待

  当值为NULL时，select()系统调用会一直阻塞，直到有某个描述符的IO事件就绪。

- 等待指定时间

  通过设置timeout参数的秒数和微秒数，可以让select()等待程序指定的时间。在此期间如果有IO事件就绪会返回，如果超时将返回错误。

- 不等待

  检查描述符后立即返回，该参数必须指向timeval结构，而且其中的值必须都为0



select()监视的描述符是通过三个描述符集合来指定的，一般是通过数组来实现的，每个整数上的每一位对应一个描述符。例如数组的第一个元素对应0 - 31描述符。

描述符集合的实现被隐藏在fd_set集合中，系统实现了相关接口给程序使用：

```c
void FD_ZERO(fd_set *fdset);			//初始化一个描述符集合
void FD_SET(int fd, fd_set *fdset);		//将fd描述符加入到集合中
void FD_CLR(int fd, fd_set *fdset);		//在集合中清除fd描述符
void FD_ISSET(int fd, fd_set *fdset);	//fd描述符的bit位是否在集中打开
```

readset、writeset和exceptset三个参数都是值结果参数。

它们都会被select()系统调用改变，select()返回时，结果将指示哪些描述符已就绪，同时它会把未就绪的描述符所对应的位都置为0，因此每次重新调用select()时，需要在描述符集合中重新指定要监视的对象。

注：FD_SETSIZE是fd_set的描述符总数，一般是1024，它定义与<sys/select.h>中。



example:

```c
int fds[];

// 阻塞于select调用，直到有I/O条件继续
int nready = select();

// 遍历监视的文件描述符
for (int i = 3; i < maxfd + 1; i++) {
    //处理I/O条件
}
```



### 描述符就绪条件

一个描述符满足以下条件，就是可读的：

- 该socket接收缓冲区的字节数大于等于套接字的接收缓冲区低水位标记（lower water market），可以理解为缓冲区中有数据可读。低水位标记由SO_RCVLOWAT选项控制。
- 对方连接的读关闭，即接收到FIN报文段。
- 有一个socket错误待处理，对这样的socket将返回-1，同时把errno设置为确切的错误条件。

可写需要满足以下条件：

- 该套接字发送缓冲区中的可用空间字节数大于等于套接字的发送缓冲区低水位标记的大小，该套接字可连接（TCP）或不需要连接（UDP）。

  简单理解为有空间可用写入数据。

- 使用非阻塞式connect的套接字已建立连接，或者connect已经以失败告终。

- 其上有一个套接字错误待处理，对这样的套接字写操作将不阻塞并返回-1，同时把errno设置成确切的错误条件。

如果一个套接字存在带外数据或者仍处于带外标记，那么它有异常事件待处理。

注：从上述条件可用看出，当一个套接字上发生错误时，select()将其标记为可读也可写。我的理解是比如在读写时有触发信号这种错误?



接收低水位标记与写入低水位标记的目的在于：允许应用进程指定内核，当至少有多少数据可读或者有多大空间可写的时候才算满足I/O就绪。

举例来说，如果我们知道至少存在64个字节的数据，否则我们的应用进程没有任何工作可做，这种情况我们就可用把低水位标记设置为64，以防止少于64个字节的数据准备好读时select唤醒我们。



### poll

```c
#include <poll.h>

int poll(struct pollfd *fdarray, unsigned long nfds, int timeout);
```

poll与select类似，也是允许进程指定内核要监视的描述符，并在IO事件就绪的情况下通知进程。

fdarray，该参数是一个指向pollfd结构数组的第一个元素的指针。该数组每个元素都是一个pollfd结构，用于指定监视某个给定描述符fd的条件。

```c
struct pollfd {
    int fd;	//要监视的描述符
    short events;	//描述符要监视的IO条件
    short revents;	//描述符上发生的IO条件
};
```

要监视的事件由events成员指定，revents成员会返回描述符已触发的事件，一个为调用值，另一个为返回结果。每个成员都是指定某个特定事件的一位或多位组成。



select是通过不同的描述符集合来指定要监听的事件，而poll则是单独给每个描述符指定要监视的事件，用于指定events、revents成员事件的标志有：

- POLLIN

  普通或优先级带数据可读

- POLLRDNORM

  poll read normal的意思，普通数据可读

- POLLRDBAND

  poll read (priority) band的意思，表示优先级带数据可读。

- POLLPRI

  高优先级数据可读

上述四个常值用于处理输入。

- POLLOUT
- POLLWRNORM
- POLLWRBAND

这3个常值用于处理输出。

- POLLERR
- POLLHUP
- POLLNVAL

最后3个常值处理错误，它们不能在events成员中设置，响应的事件会在revents中返回。



poll触发IO事件的条件如下所示：

- 所有正规TCP数据和UDP数据都被认为是普通数据。
- TCP读半关闭时，也被认为是普通数据，随时读操作返回0
- 在监听套接字上有新的连接可用就认为是普通数据，也可以认为是优先级数据，大部分认为是普通数据。
- TCP带外数据被认为是优先级带数据
- TCP连接存在错误即可认为是普通数据，也可认为是错误（POLLERR），无论哪种情况都返回-1，并把errno设置位合适的值，可以用于处理接受到RST或者发生超市等条件。

以下条件认为可写：

- 非阻塞式connect的完成被认为是使相应套接字可写。







一个输入读取操作包含俩个操作：

- 等待数据准备好
- 从内核向进程复制数据

对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二部就是把数据从内核缓冲区复制到进程缓冲区中。
