TCP为应用层提供可靠的、面向连接的基于字节流的通信协议。

- 可靠

  TCP协议使用超时重传、数据确认等方式来保证数据包被正确的发送至目的端，因此TCP服务是可靠的。

- 面向连接

  使用TCP协议必须建立连接，并在内核中为连接维持必要的数据结构，比如连接状态、读写缓冲区以及定时器等，而在通信双方结束后必须关闭连接以释放这些内核数据，因此TCP是基于流的。



TCP头部结构



连接的建立



关闭连接



半关闭



连接超时



数据交互



TCP状态转移



TIME_WAIT



复位报文段（RST）



TCP超时重传



拥塞控制





### TCP数据报结构

```c
struct tcp_package {
    short source_port;	//源端口
    short target_port;	//目标端口
    int seq;	//Sequence Number，序号，占32位
    int ack;	//Acknowledge Numb，确认号，占32位
    //6个标志位
    //其他略...
};
```

重点关注以下字段：

- seq

  Sequence Number，序号，占32位，用来标识从计算机A发送到计算机B的数据包的序号，在发送数据包时会对此进行标记。

- ack

  Acknowledge Number，确认号，32位，客户端和服务端都可以发送，ack = seq + 1

标志位有6个，每个标志位占1个字节，分别是：

-  URG：紧急指针（urgent pointer）有效。
-  ACK：确认序号有效。
-  PSH：接收方应该尽快将这个报文交给应用层。
-  RST：重置连接。
-  SYN：建立一个新连接。
-  FIN：断开一个连接。

SYN是Synchronous的缩写，表示同步的；FIN是Finish的缩写，表示完成；seq是Sequence的缩写，表示序列；ack是Acknowledge，表示确认。



### TCP连接的建立

客户端调用socket()函数创建socket套接字后，因为没有建立连接，所以处于CLOSED状态；服务端调用listen()函数后，套接字进入LISTEN状态，开始监听客户端请求。

- 建立连接

  客户端调用connect()发起连接，这时TCP会发送一个SYN包，它会设置SYN标志位，设置客户端发送数据的初始序列号，即设置Seq字段的序列号为G。当发出SYN包后，客户端处于SYNC-SEND状态。

  说明：SYN包不携带数据，它包含一个IP头部，TCP头部和相关TCP选项。

- 服务端确认客户端的SYN

  服务器必须确认客户端的SYN包，因此也需要发送一个SYN包，它包含服务器将在同一连接中发送数据的初始序列号，也包含客户端期待的确认号。

  TCP会在包中设置SYN标志位和ACK标志位，设置序列号Seq字段的为K，设置确认号ACK字段的为G+1，当发送数据包后，服务器处于SYNC-SENT状态。

- 客户端确认服务器的SYN包

  客户端收到服务端的SYN包后，检测检测到有SYN标志位和ACK标志位，知道这是服务端发来的"确认包"，因此会检测确认号ACK字段的值是否等于G+1，如果是说明连接建立成功。

  客户端会发送确认包，设置ACK标志位，设置确认号ACK字段为K+1，然后发送数据包，这时客户端处于ESTABLISED状态，表示连接建立成功。

- 服务端收到数据包，检测到有ACK标志位，知道这是客户端发来的"确认包"，服务端会检测ACK字段，判断是否等于K+1，如果是说明连接建立成功，服务端进入ESTABLISED状态。

注1：确认号 = 序列号 + 1，可以理解为响应的确认号为发送方的序列号加1

注2：握手的关键是确认对方收到了自己的数据包，确认是通过ACK标志位和确认号来实现的；



### TCP连接的断开

建立一个连接要三次握手，而断开一个连接要经过四次握手。

- A端发起断开连接的请求

  某一端调用close()，执行主动关闭。TCP会设置FIN标志位，设置序列号Seq字段为M，然后发送FIN包，这时该端处于FIN_WAIT_1状态。

- B端确认FIN包

  B端在收到FIN包会执行被动关闭，该端需要确认FIN包。

  FIN是由TCP确认的，FIN的接收会作为一个文件结束符(end of file)传递给应用进程，即将文件结束符放在应用进程接收的任何数据之后，因此FIN表示接收端应用进程在连接上没有可以接收的数据了。

  TCP会设置ACK标志位，设置确认号ack字段为M+1，发送确认包，这时B端处于CLOSE_WAIT状态。

- A端在收到确认包后会进入FIN_WAIT_2状态，等待B端再次发送数据包。

- B端发送FIN包

  在一段时间后，接受到这个文件描述符的应用进程会调用close()关闭它的套接字，TCP也会发送一个FIN包。

  TCP会设置FIN标志位，设置序列号Seq字段为N，发送该数据包，这时B端进入LAST_ACK状态。

- A端确认FIN包

  接收到最终FIN包的原发送端TCP确认这个FIN。

  TCP会设置ACK标志位，设置确认号ack字段为N+1，然后发送确认包，这时A端处于TIME_WATI状态。

- 最终B端在收到A端的确认包后就断开连接，进入CLOSE状态。

不论是客户端还是服务器，任何一端都可以执行主动关闭，通常是客户端执行关闭，但是某些协议例如HTTP协议却是由服务器执行主动关闭。





### TIME_WAIT

在TCP断开连接的四次握手中，主动发起断开连接的一方，在最后响应FIN包之后会处于TIME_WAIT状态。

主要有俩个原因：

1. 为了可靠地实现TCP全双工连接的终止

   主动发起断开连接的一方，最后确认FIN包时会发送ACK包，如果ACK包丢失，接收方则会再次重传FIN包，因此必须维护状态信息，以便能够再次发送最终的ACK包。

2. 允许老的重复包在网络中消逝



### TCP数据的传输

假设主机A要分2个数据包向主机B传输200字节数据，那么会有以下过程：

- 发送方发送数据包

  主机A通过一个数据包发送100个字节的数据，数据包的Seq序号设置为1200

- 接收方响应ACK包

  主机B为了确保收到主机A的数据包会响应ACK数据包，并将ACK字段设为1301。

  ACK字段  = Seq + 传递的字节数 + 1，将传递的字节数计算在内是为了让发送端能够确保自己的数据发送成功，加1是告诉发送方下次传递的Seq序号

- 发送方继续发送数据包

  主机A收到ACK数据包，检测ACK字段是否为1301，如果是代表数据发送成功。然后会以1301作为序号发送下一个数据包。



发送方是如何确保接收方收到数据的?

为了保证数据准确到达，目标机器在收到数据包（SYN包、FIN包、普通数据包等）都需要回传ACK包，这样发送方才能确保接收方有收到数据包。



超时重传

如果发送的数据包丢失或者中途发生错误，例如在一定时间内没有收到目标机器相应的ACK包，或者ACK包数据长度验证失败，那么TCP协议会对数据包进行重传。

为了完成数据包的重传，TCP套接字在每次发送数据包的时候都会启动定时器，如果在一定时间内没有收到目标服务器的ACK包，那么定时器超时，数据包会重传。

- 重传超时时间 

  重传的超时时间理论上最好的是网络RTT时间，RTT指的是从发送端发送数据包开始，到发送端收到来自接收端的ACK确认包，总共经历的时间。



