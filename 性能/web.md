### 吞吐率

吞吐率用于描述服务器的并发能力，它是指单位时间内服务器处理的请求数量，单位是"reqs/s"。

从定义来看，吞吐率描述了服务器在实际运行期间单位时间内处理的请求数，然后一般更关注的是服务器并发处理能力的上限，即单位时间内服务器能够处理的最大请求，即最大吞吐率。

吞吐率的前提包括并发用户数、总请求数和请求资源描述3个条件。



### 并发用户数

并发用户数是指在某一时刻同时向服务器发送请求的用户总数。

在测试中连续发送请求是指发出一个请求收到响应后再发出下一个请求，因此1个用户发送1000次请求与100个用户同时向服务器分别进行10次请求，倆者是不一样，前者在服务器的网卡缓冲区中只有来自该用户的请求，后者在服务器网卡接收缓冲区最多有100个等待处理的请求。

- 实际并发用户数

  即客户端同时存在的用户数量。

- 最大并发连接数

  web服务器所能打开的最大文件描述符数量。

  实际并发用户数可以理解为web服务器当前维护的不同用户的文件描述符总数，当然不是来多少用户就维护多少文件描述符。

  所以实际并发用户数有时候会大于服务器所维护的描述符总数，多出的用户请求会在服务器内核的数据接收缓冲区中等待处理。



### 请求等待时间

对于请求等待时间，需要关注俩个指标：

- 用户平均请求等待时间

  指的是服务器在一定并发用户数的情况下，对于单个用户的服务质量（等待时间）

- 服务器平均请求处理时间

  用于衡量服务器的整体服务质量，它其实是吞吐率的倒数，即单个请求的处理事件。

假设有100个用户同时向服务器发出请求，服务器一般采用多进程或多线程的并发模型，通过多个执行流来同时处理多个并发用户的请求，多执行流的设计体系是轮流交错使用CPU时间片，所以每个执行流的花费时间边长，对于用户的每个请求等待时间必然增加；而对服务器来说如果并发策略得当，每个请求的处理平均时间会减少。



### ab命令说明

- Concurrency Level

  表示并发用户数

- Time taken for tests

  表示所有请求被处理完成花费的时间。

- Complete requests

  总请求数

- Failed requests

  失败的请求数

- Request per second

  吞吐率，它等于总请求数除以完成请求花费的时间。

  Complete requests / Time taken for tests

- Time per request

  用户平均请求等待时间，等于 总时间 除以 每个用户发出请求的数量

  Time taken for tests / (Complete requests / Concurrency Level)

- Time per request (mean, across all concurrent requests)

  服务器平均处理请求的时间，它等于吞吐率的倒数；有时也被叫做响应时间（Response Time RT）。

  time taken for tests / Complete requests



- Total transferred

  所有请求的响应数据长度的总和，包括每个HTTP响应头部信息和响应内容数据的长度。

  注：不包括http请求数据的长度。

- HTML transferred

  表示所有请求响应数据中正文数据的总和，即减去了Total transferred中HTTP响应数据头头部信息的长度。

在ab.exe结果的最后部分，描述每个请求处理时间的分布情况，这里每个请求的处理时间是指用户平均请求等待时间。



### QPS

在讨论系统服务端性能一般用QPS（Query Per Second）每秒请求数来衡量，它受到响应时间（Response Time）的影响，即服务器处理响应的耗时。

响应时间是有极限的，不可能无限下降，所以又出现了另外一个维度，即通过多线程来处理请求，这样理论上QPS就成了"总QPS = (1000ms / RT) * 线程数量"，这样性能就和俩个因素相关了，一个是服务器响应的耗时，一个是处理请求的线程数。



- 响应时间与QPS

  响应时间一般由CPU执行时间和线程等待时间（例如IO等待、PRC、Sleep等）组成，即服务器处理一个请求时，一部分是CPU本身在做运算，还有一部分是各种等待。

  相反减少线程等待时间对于QPS的提供影响不是很大，虽然能减少响应时间，但是提升不是线程的。真正对响应时间有影响的是CPU的执行时间，减少CPU执行时间对QPS会有线性般的提高。



- 线程数与QPS

  线程本身占用内存空间，同时线程越多切换的成本也会变高，因此线程数不是越多越好，需要设置一个合理的数值。

  一般很多多线程的场景都会有一个默认配置，即"线程数 * CPU核心数 + 1"，当然除去该配置，还有一个根据最佳实践得出来的公式：

  > 线程数= [(线程等待时间 + 线程CPU时间) / 线程CPU时间] * CPU数量

  当然最好的办法是通过性能测试来发现最佳的线程数，换句话说要提升性能就要减少CPU的执行时间，另外就是要设置一个合理的并发线程数，通过这俩方面来提升服务器的性能。



注：吞吐率与QPS都是同一个指标。



### CPU瓶颈

对于服务器而言，出现瓶颈的地方很多，例如CPU、内存、磁盘以及网络都会导致瓶颈。此外不同的系统对瓶颈的关注度也不一样，例如对缓存系统来说，制约它的是内存，对存储型系统而言I/O更容易是瓶颈。



在秒杀场景中，瓶颈更多的是在于CPU上。对于CPU瓶颈可以使用一些CPU诊断工具，例如php语言有xhprof性能分析器，可以查看每个函数的运行时间，发现调用频繁且耗时多的函数，以此来做出优化措施。

对于CPU来说，当QPS达到极限时如果服务器的CPU使用率没有超过95%，那么表示CPU还有提升空间，要么是有锁限制，要么本地有过多的I/O等待发生。



PHP优化

如果有使用composer，使用composer dump-autoload --optimize来生成预加载文件，避免频繁过多文件影响CPU执行时间。

开启OPcache。

使用PHP最新版本。















怎么样发现瓶颈







实践

在性能测试过程中，主要是通过一定量的请求下，测试随着并发用户数的不同，查看吞吐率、用户平均等待时间等指标发生的变化。



并发策略

影响web服务器性能指标除了服务器配置外就是并发策略了。

并发策略的设计就是在服务器同时处理较多请求的时候，如何合理协调充分的利用CPU计算和I/O操作，使其在较大的并发用户数的情况下提供较高的吞吐率。





我的疑问？

如何提高QPS？

如何测试出MySQL的读取或写入的峰值？