## location解析
location有定位的意思，在nginx中主要是用于解析URI，根据URI来进行不同的定位。
在虚拟主机的配置中，location是必不可少的，它可以把网站的不同部分定位到不同的处理方式上。

### 1. 语法说明
语法：
```shell
location [=|~|~*|^~|@] patt {
}

# patt是匹配表达式
# []的内容是修饰符
```
匹配命令作用如下：
- =：进行普通字符串精准匹配
- ~：正则匹配，区分大小写
- ~*：正则匹配，不区分大小写
- ^~：表示普通字符串匹配，如果该选项匹配，只匹配该选项，不匹配别的目录，一般用来匹配目录
- @：定义一个命名的location，使用在内部定向时，例如error_page，try_files

如果没有中括号中的匹配指令，是普通字符匹配。


### 2. 匹配优先级
1. =前缀的指令严格匹配这个查询，如果找到，停止搜索。
2. 普通字符匹配，正则表达式规则和长的块规则将被优先和查询匹配，也就是说某个普通字符匹配后，Nginx还会继续查看有没有其他正则表达式匹配和更长的规则匹配。
3. ^~只会匹配该规则，Nginx会停止搜索其他匹配，否则Nginx会继续处理其他location指令。
4. 最后匹配 ~ 和 ~* 的指令，如果找到相应的匹配，Nginx会停止搜索并采用该规则；如果没有找到正则表达式匹配，那么匹配程度最长的普通字符匹配规则将会被采用。

解释：
- 先判断是否精准匹配，如果命中立即返回执行结果并结束解析过程
- 判断普通命中，如果有多个命中，"记录"下来"最长"的命中结果（注：记录但不结束，最长的为准）
- 继续判断正则表达式的解析结果，按配置里的正则表达式顺序为准，从上到下开始匹配，一旦匹配成功1个就立即返回结果，并结束解析过程。

是否可以理解成精准匹配最高，次级正则表达式，再次级是普通字符匹配。


## location example
example：精准匹配与普通匹配
```conf
location = / {
	[configuration A]
}
# 精准匹配，只匹配"/"

location / {
	[configuration A]
}
# 匹配任何请求，因为所有请求都是以/开始的
# 但是更长的字符匹配或者正则表达式会优先匹配


# blog.com，执行精准匹配
# blog.com/index.html，执行普通匹配
```

example：多个普通匹配
```
server{
	location / {
		root html
		index index.html
	}

	location /foo {
		root html
		index index.html
	}
}
# 普通字符匹配下，Nginx会将匹配结果存储起来
# 如果没有正则匹配，则会取最长字符的普通匹配作为结果返回
```

example：普通匹配和正则匹配
```
location / {
	[configuration A]
}

location ~ images {
	[configuration A]
}

# 如果普通匹配和正则匹配都成功，那么正则匹配会覆盖普通匹配的结果。
# 正则表达式是按照配置文件从上到下的顺序来进行匹配的，谁先匹配到就先返回结果。
```

### note
关于精准匹配、普通匹配、正则匹配的说明。

- 精准匹配，对uri进行精确的完全匹配，不包括参数的匹配。
- 普通匹配: nginx会从左到右匹配uri，uri的左半部分满足匹配条件，即使有多余的字符，该匹配也会生效。
- 正则匹配: 按照正则表达式的匹配逻辑来匹配uri

example:
```
location = / {}
# 精准匹配
# / 
# /?state=abcde
# 上述的uri都满足匹配条件

location /test {}
# 普通匹配
# /test
# /test?age=20
# /test/add?age=20
# 上述的uri都满足匹配条件
```
