表数据可以存储在共享表空间中，也可以是单独的文件。

```ini
innodb_file_per_table
```

控制表数据的存储方式，ON表示以单个文件存储，OFF表示存储到共享表中。

建议开启，便于管理。在开启状态下，drop table会删除表文件，同时回收磁盘空间。如果数据存储在共享表空间中，drop table的时候，空间是不可回收的。



### 数据删除流程

InnoDB的数据是以页存储的，删除一条记录时只会在页中将记录标记为删除状态，后续是可以复用该位置的。如果整个页上的记录都被删除了，则整个页是可以复用的。

由于并不是物理删除一条记录，体现在磁盘上就是表文件大小不变。



### 数据复用

记录的复用与数据页的复用是不同的。

记录的复用只限于符合范围条件内的数据。例如某个数据页上有3条记录，ID分别为200、300、400，其中300是删除的，后续插入的记录ID大于200小于400就可以复用ID300的空间。



而当整个页从B+树里面摘除之后，可以复用该页的任何位置。相邻的俩个数据页利用率都很小，系统就会把这俩个页上的数据合并到其中一个页上，另外一个页就被标记为可复用的。



### 数据空洞

由于删除数据只是将记录标记为可复用的，而没有未被使用的空间，看起来就像是"空洞"，这种情况我们称为数据空洞。



删除数据会造成空洞，插入数据也会造成空洞。如果数据是按照索引递增顺序插入的，索引将会是紧凑的；如果数据是随机插入的，就有可能造成索引的数据页分裂。

数据页分裂指的是某个数据页的记录满了，这时候如果要往该页中插入数据，就需要分裂出一个新的页来存储数据。



更新索引上的值，可以理解为删除一个旧的值，再插入一个新的值，这也是会造成数据空洞的。也就是说经过大量增删改查的表，都有可能是存在空洞的。





### 重建表

如果能够复用数据空洞，那么表所占用的磁盘空间会变小很多。我们知道递增的插入数据索引将会是紧凑的，因此可以执行以下步骤来收缩表空间：

- 建立一张临时表，表结构与要收缩的表结构一致
- 将收缩表的数据插入到临时表中
- 重命名收缩表，然后将临时表的名字改为收缩表的名字

这3个步骤就可以达到清除数据空洞的目的，这种方式的缺点是在复制数据期间，不允许有对收缩表进行更新，否则复制后表与要收缩的表数据不一致。





MySQL在5.6版本中引入了Online DDL，允许在重建表的过程中去更新这种表。

```sql
alter table table_name engine=innodb;
```

Online DDL实际上是在上述的第二个步骤中，引入了一个row log的概念，在复制数据的期间，row log会记录下对原有表的操作，当数据复制完毕后，对新的表执行row log日志的变动，这样新表与旧表的数据就一致了。

执行alter语句时，在启动时会获取MDL写锁，而在复制数据期间会退化到MDL读锁，这是为了允许其他线程能够对原表进行更新操作，同时防止其他线程对原表执行DDL操作。



### inplace

Online DDL的过程中，数据会放在临时文件中，这个临时文件是InnoDB创建出来的。整个DDL过程都是在InnoDB完成。对于server层来说，没有把数据移动到临时表，是一个"原地"操作，这个过程就叫做inplace。



重建表的语句alter table t engine=innodb，其实真正的意思是：

```sql
alter table t engine=innodb, algorithm=inplace;
```

与inplace对应的是拷贝表的方式，

```sql
alter table t engine=innodb, algorithm=copy;
```

copy相当于手动重建表的流程。

