### n叉树

二叉搜索树是一颗每个节点的左子节点小于父节点，而父节点又大于右子节点的数据结构。它的搜索复杂度是$O(logN)$，一般为了维持$O(logN)$的复杂度，树都会实现为平衡的。

二叉搜索树之所以不应用在磁盘存储中是因为从磁盘读取一个数据块的寻址时间太长了，从机械磁盘读取一个数据库大概需要10ms的寻址时间。

假设一颗100万节点的二叉平衡树，树高20，一次查询就需要访问20个数据库，大约需要200ms，这个访问速度是不可接受的，因此采用n叉树。

- 优点

  多路树能够很好的配合磁盘的读写特性，减少单次查询的磁盘访问次数。

  二叉树是一个节点下有俩个子节点，而n叉树则是一个节点下有n个子节点，相对于二叉树，每一层可挂在的子节点增加了，树的高度变小了，磁盘的寻址时间相对就减少了。

- 应用场景

  n叉树非常适配磁盘的访问模式，广泛的应用于数据库存储引擎。

在MySQL中，n叉树的N取决于数据块的大小。例如以InnoDB的一个整数字段索引为例，这个N差不多1200，如果这棵树高度是4，可以存储1200的3个次方数量的值。









### InnoDB的索引模型

在InnoDB中，表都是根据主键顺序以索引的形式存放的，InnoDB使用B+数索引模型，所以数据是存储在B+树中的。每个索引在InnoDB中对应一颗B+树。



根据叶子节点的内容，索引类型分为俩种：主键索引和非主键索引。

在主键索引中，叶子节点存储的是整行数据，主键索引一般被称为聚簇索引（clustered index）；非主键索引中，叶子节点存储的是主键的值，因此非主键索引也被称为二级索引（secondary index）。



主键索引和二级索引在查询上的区别：

```sql
create table T(
    id int primary key,
    k int not null,
    name varchar(16),
    index(k)
)engine=InnoDB;
/* 假设表中有数据：(100, 1), (200, 2), (300, 3), (400, 4), (500, 5) */
```

- select * from T where ID = 500

  主键索引的查询只需要搜索ID这颗B+树，直接获取500节点上的数据。

- select * from T where k = 5

  普通索引的查询方式，会先搜索k索引树，得到ID的值为500，再去主键索引树上进行查询。

对于二级索引的查询，需要多扫描一颗索引树。



### 索引维护

当一个节点的数据页写满了，就需要进行分裂。当页的数据变少了，就会进行合并，分裂与合并都是消耗性能的。

自增的顺序的插入新纪录，这种追加操作不涉及挪动其他记录，不会触发叶子节点的分裂；如果不能保证有序的写入的话，写数据的成本会变高。



为什么主键索引一般是自增的呢?

- 性能考虑

  自增主键的插入数据模式是递增插入记录的，每插入一条记录都是追加操作，不涉及挪动其他记录，也不会出发叶子节点的分裂。

- 存储考虑

  如果主键列的数据类型比较大，由于普通索引叶子节点上存储的是主键索引的值，因此也会导致普通索引占用更多的存储空间。

  例如将身份证作为主键索引存储的话，假设数据类型是varchar(18)，那么二级索引树的每个子节点占用约20个字节。如果使用int型主键，只需要4个字节。

当然也有将业务逻辑的字段作为主键索引，典型的有KV场景，即只有一个索引，且该索引是唯一索引。



### 回表

```sql
mysql> create table T (
ID int primary key,
k int NOT NULL DEFAULT 0, 
s varchar(16) NOT NULL DEFAULT '',
index k(k))
engine=InnoDB;

insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
```

> select * from t whert k between 3 and 5

该SQL语句的执行流程如下：

1. 在k索引树上找到k=3的记录，取得ID=300。
2. 在主键索引上找到ID=300的记录
3. 在k索引树上找到k=5的记录，取得ID=500。
4. 在主键索引上找到ID=500的记录
5. 在k索引树上取下一个值k=6，条件不匹配返回。

从二级索引树上回到主键索引树搜索数据的过程称为回表，在上面过程中，步骤1、3、5是在k索引树上搜索，2、4步骤是回表操作。



### 索引覆盖

覆盖索引指的是不需要经过回表操作查询到主键索引的过程。例如上面例子中，如果执行语句是：

> select id from t where k between 3 and 5

该SQL语句就不需要回表获取数据，因此查询的ID字段挂在k索引树的子节点下。覆盖索引能够减少树的搜索次数，是一种常见的优化手段。



### 最左前缀

B+树这种索引结构，可以利用索引的"最左前缀"来定位记录。

这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。

- 联合索引

  多个字段组成的索引

比如有name、age俩个字段组成的联合索引，索引树会按照定义的字段顺序来对数据进行排序，类似：

> ('lisi', 20), ('wangwu', 30), ('zhangsan', 10), ('zhangsan', 10), ('zhangsan', 20)

当查询逻辑是查询'zhangsan'时，可以快速定位到所有'zhangsan'的数据；或者使用like查询'zhang'字符串，满足该条件的记录都会被匹配到。



建立联合索引的原则：

- 如果通过调整顺序，可以少维护一个索引，那么这个顺序一般是有限考虑的
- 如果既有联合索引，又不得不维护另外一个索引，那么优先选择占用空间小的字段来做索引。



### 索引下推

最左前缀可以用于在索引中定位记录，在索引遍历过程中，对于索引中包含的字段会先做判断，直接过滤掉不满足条件的记录，以减少回表次数。

注：索引下推是MySQL5.6版本引入的



比如联合索引（name，age），如果需求是查询名字是'zhang'而且年龄是10岁的男孩，SQL语句会这样写：

> select * from tuser where name like 'zhang%' and age=10 and ismale=1;

InnoDB在扫描索引时，会优先寻找字符串'zhang'的记录，同时由于age是联合索引的一部分，因此会进行age字段的判断，如果不满足条件则遍历下一条记录，如果满足条件则会回表去继续判断。



