### N叉树

二叉搜索树是一颗每个节点的左子节点小于父节点，而父节点又大于右子节点的数据结构。它的搜索复杂度是$O(logN)$，一般为了维持$O(logN)$的复杂度，树都会实现为平衡的。



二叉搜索树不应用在存储引擎中是因为从磁盘读取一个数据块的寻址时间太长了，假如一颗100万节点的平衡二叉树，树高20，那么一次查询可能读取20个数据块，从机械硬盘读取一个数据块大概需要10ms的寻址时间，20次就需要200ms，这个速度是很慢的。



为了让查询尽量少读取磁盘，就需要在查询过程中尽可能访问少的数据块，因此使用N叉树。

N叉树的N取决于数据块的大小，例如已InnoDB的一个整数字段索引为例，这个N差不多1200，如果这棵树高度是4，可以存储1200的3个次方数量的值。

多路树能够很好的配合磁盘的读写特性，减少单次查询的磁盘访问次数。







### InnoDB的索引模型

在InnoDB中，表都是根据主键顺序以索引的形式存放的，InnoDB使用B+数索引模型，所以数据是存储在B+树中的；每个索引在InnoDB中对应一颗B+树。



根据叶子节点的内容，索引类型分为俩种：主键索引和非主键索引。

在主键索引中，叶子节点存储的是整行数据，主键索引一般被称为聚簇索引（clustered index）；非主键索引中，叶子节点存储的是主键的值，因此非主键索引也被称为二级索引（secondary index）。



基于主键索引与二级索引的区别：

假设有一个主键列为ID的表，表中有k字段，并且是一个索引。

```sql
create table T(
    id int primary key,
    k int not null,
    name varchar(16),
    index(k)
)engine=InnoDB;
```

- select * from T where ID = 500

  即从主键ID=500中获取数据即可。

- select * from T where k = 5

  从普通索引查询k等于5的节点，从该节点中获取对应主键索引的值，再通过该值去主键索引树中寻找数据。

  这个过程称为回表。

也就是说基于非主键索引的查询需要多扫描一颗索引树，因此建议在应用中尽量使用主键索引。







### 页分裂

当一个节点的数据页写满了，就需要进行分裂；当页的数据变少了，就会进行合并。分裂与合并都是消耗性能的。



自增的有序的插入新纪录，这种追加操作不涉及挪动其他记录，不会触发叶子节点的分裂；如果不能保证有序的写入的话，写数据的成本会变高。



自增主键索引应用场景：

- 性能考虑

  有序写入比无序写入性能好。

- 存储考虑

  如果主键列的数据类型比较大，由于普通索引叶子节点上存储的是主键索引的值，因此也会导致普通索引占用更多的存储空间。

注：这里的自增是指主键的值自增，并不是指主键的类型。



业务主键的应用场景：

- 只有一个索引，且该索引是唯一索引

其实就是一个键值对场景的应用，业务主键指的是主键的值是有业务生产的。



### 覆盖索引

举个例子说明一条SQL语句在索引中的执行过程：

```sql
mysql> create table T (
ID int primary key,
k int NOT NULL DEFAULT 0, 
s varchar(16) NOT NULL DEFAULT '',
index k(k))
engine=InnoDB;

insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
```

select * from t whert k between 3 and 5，该SQL语句的执行流程如下：

在k索引树上找到k=3的记录，取得ID=300。

在主键索引上找到ID=300的记录

在k索引树上找到k=5的记录，取得ID=500。

在主键索引上找到ID=500的记录

在k索引树上取下一个值k=6，条件不匹配返回。

回到主键索引搜索的过程被称为回表。





在上面的例子中，如果语句是：select id from t between 3 and 5，由于主键ID的值已经在k索引树下了，因此不需要回表，在一个查询里面，索引k覆盖了查询的需求，所以被称为覆盖索引。

覆盖索引能够减少树的搜索次数，是一种常见的优化手段。



