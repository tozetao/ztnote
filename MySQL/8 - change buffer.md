在读取数据的时候，InnoDB的是按数据页为单位来读写的，当读取一条记录时并不是将这个记录本身从磁盘读取出来，而是以页为单位，将其整体读入内存。

InnoDB中每个数据页的大小默认是16kb。

通过索引树，找到对应的数据页，再通过数据查找记录?



将数据从磁盘读取内存涉及随机IO的访问，将数据从内存中随机写入到磁盘上，这俩种操作的成本都很高。因此才有redo log和change buffer的存在。



什么是数据页？





### change buffer

change buffer用于解决更新数据时，随机读取磁盘数据页造成的IO开销。

当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果数据页不在内存中，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读取这个数据页去进行更新了。

当下次需要访问这个数据页时，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。

- merge

  将change buffer中的操作应用到原数据页的过程，称为merge。除了访问数据页会触发merge外，系统后台线程也会定时merge，数据库正常关闭的过程中也会执行merge操作。

简单的说，change buffer通过缓存数据页的更新操作，以此达到减少随机读取磁盘的IO开销，而merge过程则保证了查询时数据的正确性。



example：举例说明change buffer是如何运行的

```sql
create table t(
	id int primary key,
    k int,
    index(k)
);
insert into t values(100, 1),(200, 2),(300, 3),(500, 5),(600, 6);
-- 创建表并插入基本数据
```

```sql
insert into t(id, k) value(400, 4)
```

假设现在执行一条insert语句，那么会有俩种情况

- 如果这个记录要更新的目标页在内存中，对于普通索引来说，找到3和5之间的位置，插入这个值，语句执行完毕；
- 如果目标页不在内存中，对于普通索引则是将更新记录在change buffer中就执行完毕了。



change buffer只限于普通索引，而不适用于唯一索引。



### 应用场景

写多读少的业务场景，页面在写完以后马上被访问到的概率比较小，change buffer的使用效果最好。例如账单类、日志类的系统。





### redo log

```sql
insert into t(id,k) values(id1, k1),(id2, k2);
-- 使用上面的表，继续插入俩条记录
```

假设在k索引树中，查找到位置后，k1所在的数据页在内存中（InnoDB buffer），k2所在的数据页不在内存中。这里的更新会涉及4个部分：

![](https://static001.geekbang.org/resource/image/98/a3/980a2b786f0ea7adabef2e64fb4c4ca3.png)

- InnoDB buffer

  该缓冲区存储了k的数据页，也包括change buffer，它会存储k2的更新操作，即插入一条新的记录。

- redo log

  记录了数据页的操作，对应MySQL var目录下的ib_log_fileX文件

- 系统表空间

  对应MySQL var目录下的ibdata1文件

- 数据表空间

  t表的表文件，真正存储该表数据的地方。

该更新语句做了以下操作：

1. k1的page1数据页在内存中，直接更新内存
2. k2的page2数据页不在内存中，就在内存的change buffer区域，记录下要往page2插入一行记录的信息
3. 这俩个动作都会记录在redo log日志中

执行到这里事务就完成了，可以看到执行一条更新语句就是写了俩处内存，然后写了一次redo log日志，俩次操作合并成一次操作，而且是顺序写的。

总结来说，更新数据时，会有以下操作：

- 先判断记录对应的数据页是否在内存中（InnoDB buffer）
- 如果在内存中就直接更新数据页，如果不在内存中，则将更新数据页的操作存储到change buffer中。
- 然后再将对数据页的操作存储到redo log日志中，这里其实还涉及到俩次提交操作，即同步bin log日志操作。

到此更新事务就执行完毕了，MySQL会在合适的时机，将更新记录一次写入到对应的表文件。





```sql
select * from t where k in(k1, k2);
```

如果现在需要查询刚插入的俩条记录，由于读语句发生在更新之后，内存中的数据还在，因此会有以下操作：

1. k1对应的数据页在内存中，因此直接读取
2. k2的数据页不再内存中，需要从表文件中读取数据页，然后执行change buffer中对应数据页的变更操作，再读取k2的数据

可以看到需要读取k2对应的数据页时，这个数据页才会被读入内存。



对于redo log和change buffer，它们的优化方向不一样。redo log主要节省的是随机写磁盘的IO消耗，转成顺序写，而change buffer主要是节省了随机读取磁盘的IO消耗。











