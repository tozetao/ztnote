## 数据结构设计
遵循数据库设计范式，数据库范式主要避免数据冗余和数据维护异常。

### 1. 数据库第一范式
数据库表中的所有字段都只具有单一属性，单一属性的列是由基本的数据类型组成的，并且设计出来的表都是简单的二维表。

### 2. 数据库第二范式
凡是符合第二范式的表同时也要满足第一范式。

第二范式要求一个表中只具有一个业务主键，也就是说符合第二范式的表中不能存在非主键队列对部分主键存在部分依赖关系，非主键列跟部分主键所存在的部分依赖关系只能存在于复合主键中。
```sql
create table student(
	student_no int,
	name varchar(20),
	course varchar(10), 
	score int,			#成绩
	course_point int,	#学分
	primary key(student_no, course)
)
# 学号与课程组成了复合主键，这张表记录学生在每门课程上的成绩，
# 也记录了每门课程的学分，字段都是原子级别的，不可再次分割了。

# student表中，学分（course_point）只对course（课程）列产生主键依赖
# 因此产生了非主键队列对部分主键产生部分依赖关系，这是不正确的。

# 优化：将学生信息当做一张表，课程作为一张表，学生在没门课程上的成绩也作为一张表。
```

### 3. 数据库第三范式
指每一个非主键列既不部分依赖也不传递依赖于业务主键，也就是在第二范式的基础上消除了非主键列对主键的依赖传递。
```sql
create table student(
	student_no int,
	name varchar(20),
	birth_date timestamp,
	school_name varchar(20), #学院名
	school_tel varchar(15)	 #学校电话
)
# 该表满足第一、第二范式，所有列都是原子级别并且所有非主键列都依赖于主键，
# 学号（student_no）可以确定学生所在的学院（school_name），
# 通过学院又能确定学院电话（school_tel），学院电话和学号是有传递依赖关系。

# 改进：将学院表独立成一张表，学生表删除学院字段，保留一个学院id，与学院表关联即可
```

### 4. 反范式设计
为了性能和读取效率或者是业务逻辑上的考虑适当的对数据库设计范式的要求进行违反，而允许存在少量的数据冗余，换句话说用空间换取时间。

以下是几个需要进行反范式设计的案例。

需求：商城网站的订单模块设计
按照3范式来进行设计的话，将会有这订单表、订单商品关联表、商品表，表结构如下：
```sql
create table order(
	订单编号
	下单用户名
	下单日期
	物流单号
)

create table order_goods(
	订单编号
	商品id
	商品数量
)

create table goods(
	商品id
	商品价格
	商品分类id
)

create table category(
	category_id,
	category_name,
	...
)

# 需求1：假设现在要查询每个用户的订单总金额，SQL语句大体是：
select o.pay_user_name, sum(g.goods_price * og.count) from order o 
	inner join order_goods og on o.order_id = og.order_id
	inner join goods g on og.goods_id = g.goods_id
	group by o.pay_user_name

# 该SQL语句在商品价格发生变化下，订单的价格也会发生变化
# 从范式设计来看是没有错误的，但是在业务结果上是错误的，所以在设计上需要将下单时的商品价格记录在订单商品表上。


# 需求2：编写SQL语句查询出下单用户和订单详情，假设下单用户就是商品收货人
select * from order o
	inner join user u on o.pay_user_name = u.user_name
	inner join order_goods on o.order_id = og.order_id
	inner join goods on g.goods_id = og.goods_id
# 该语句是根据用户名去关联用户表查询用户信息，如果用户修改了自身的信息，会导致收货人信息也发生改变，这样也是错误的，
# 在设计上需要将用户信息记录在订单表中，不去关联用户表
```

改进后的表结构：
```sql
create table order(
	订单编号
	下单用户名
	下单手机号
	下单地址
	下单日期
	物流单号
	订单总金额
)

create table order_goods(
	订单编号
	商品id
	商品数量
	商品下单价格
)

create table goods(
	商品id
	商品价格
	商品分类id
)

# 查询用户的订单总金额
select sum(total_amount), pay_user_name from order
	group by pay_user_name

# 查询订单信息和收货人信息
select * from order o
	inner join order_goods og on o.order_id = og.order_id
```


## 物理定义
对表列的数据类型，表的字段设计统称为物理定义。

### 1. 数据类型的选择
当一个列能够选择多种数据类型时，应该优先考虑数字类型，其次是日期是二进制类型，最后是字符类型；对于相同级别的数据类型，应该优先选择占用空间小的数据类型。

原因：
- 在对数据进行比较时，比如查询条件，join条件关联排序时，字符处理是与当前排序规则相关的，而数字不需要参考字典这种排序规则，是按照二进制大小比较的，同样的处理，字符串处理往往要比数字处理慢的多

- 在数据库中数据是以页为单位的，每个页数据存储量大小是固定的，在innodb中是16k，列的长度越小，意味着在页中能够容纳的数据行就越多，这样在加载同样的数据宽度小的就要比宽度大的所要加载的数据页小的多，从而减少了磁盘I/O

### 2. varchar要点
varchar是变长字符串类型，所谓的变长指的是会根据存储字符的长度来决定存储的空间大小，varchar会使用额外的1-2个字节来存储这个可变长度，小于255个字符使用1个字节，大于255个字节使用2个字节。

在使用varchar时，要使用最小符合需求的长度来定义，主要有2点原因：
- 如果定义的长度过小，在生产环境中修改表结构时会锁表，这样对性能的影响是非常大的，会造成对该表访问连接的阻塞。
- MySQL为了能够更有效的优化查询，所以在内存中对字符串使用的是固定的宽度，所以宽度定义的太长消耗的内存会更多。

varchar的使用场景：
- 字符串列的最大长度比平均长度大很多
- 字符串列很少被更新，因为varchar类型的更新由于字符串的长度会产生变化，会引起存储页的分裂，这样会增加更多的磁盘碎片
- 使用了多字节字符存储字符串，比如utf8字符集，存储英文会使用1个字节，存储中文会使用3个字节

注：innodb一行记录的最大存储值是65535个字节，如果超过65535个字节，需要使用text其他类型

### 3. char
char是定长字符串，存储空间来固定长度的，字符串存储在char类型的列中会删除末尾的空格，最大宽度是255.

char的适用场景：
- 适合存储长度近似或固定的值，比如md5值、身份证
- 存储短字符串

### 4. datetime
datetime类型，以YYYY-MM-DD HH:MM:SS[.fraction]格式存储日期时间，
datetime类型与时区无关，占用8个字节的存储空间，时间范围是公园1000年-公园9999年。

fraction：该参数定义了存储微秒的位数，比如d1 datetime(6)，存储6位微秒数字。

### 5. timestamp
时间戳，存储格林尼治时间1970年1月1日到当前时间的秒数，以YYYY-MM-DD HH:MM:SS[.fraction]格式显示时间，实际是以int存储的，占用4个字节。

timestamp显示依赖于时区，它的时间范围是：1970年-2038年1月19日。

```sql
set time_zone='-10:00';

create table test_date(
	d1 datetime,
	d2 timestamp
);
insert into test_date values(now(), now());

set time_zone='+10:00';
```

### 6. date和time
MySQL5.7的新特性所支持的类型。

date：存储日期时间的日期部分，比如YYYY-MM-DD
time：存储日期时间的时间部分，比如HH:MM:SS

