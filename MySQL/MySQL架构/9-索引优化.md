## Btree索引
MySQL的索引是在存储引擎层上实现的，不同的存储引擎索引的实现是不同的。

Btree使用b+树结构来存储数据，在b+树种，每一个叶子节点都包含一个指向下一个叶子节点的指针，这样可以方便的对叶子节点进行遍历。

MyISAM和Innodb引擎的索引就是以Btree索引来实现的，虽然索引的类型相同，但是底层的具体实现方式是不一样的。

### 1. B-tree的特点
- 以b+树结构来实现
- b-tree索引能够加快存储引擎查找速度
- b-tree索引是顺序存储的，更适合进行范围查找

### 2. b-tree的查找方式
从索引的根节点开始搜索，在索引的根节点中存放了指向下层节点的指针，存储引擎根据这些指针从下层查找，通过比较节点叶的值和要查找的值得到合适的指针进入下层的子节点，而这些指针实际上是定义了子节点中值的上限和下限，最终存储引擎要查找的值要么存储，要么不存在。

叶子节点比较特别，它的指针是指向索引对应的数据，Innodb存储引擎叶子节点指向的是数据的主键，而在MyISAM存储引擎叶子节点指向的是数据的物理行。

### 3. B-tree的应用场景
- 全值匹配，例如：order_sn = '9876541233'
- 匹配列前缀查询，例如：order_sn like '12345%'，
- 匹配最左前缀的查询，常见于联合索引
- 匹配范围值的查询，order_sn > 987456654 and order_sn < 123654789
- 精确匹配最前列并范围匹配另外一列

在排序和分组中，B-tree索引也是能够生效的。

### 4. B-tree的限制
- not in和!=是无法使用到索引的
- 如果查询中有某个列的范围查询，则其右边所有列都无法使用到索引。

使用索引所命中的数据占据表中大部分的数据时，MySQL就不会使用索引而进行全表扫描。

## 哈希索引

### 1. hash索引特点
- Hash索引是基于Hash表实现的，只有查询条件精确匹配Hash索引中的所有列时，才能够使用到hash索引，也就是说hash索引只能用于等值查询，在范围查询和模糊查询中hash索引是不生效的。
- 对于hash索引中的所有列，存储引擎会都会为每一行计算一个hash码，hash索引中存储的就是hash码

### 2. hash索引限制
在hash表中存储了哈希码所对应行记录的物理指针，hash索引查找数据必须进行俩次读取，先通过hash索引找到对应的哈希码，在通过哈希码找到数据。

- 数据的读取必须进行俩次操作
- 无法排序，因为是按照哈希码来存储的，数据是无序随机的
- 只允许全值匹配，不支持部分索引查找也不支持范围查找
- 哈希码可能会产生冲突，一般是由于列值的识别度不够高而产生的


## 为什么使用索引
1. 索引减少了存储引擎需要扫描的行数
2. B-tree索引避免排序时使用临时表排序
3. 索引能够将随机I/O变成顺序I/O，因为索引是顺序存储的，而数据在磁盘是随机存储的

## 索引优化策略

### 1. 索引列上不能使用表达式或函数
```sql
select ... from product
	where to_days(out_date) - to_days(current_data) <=30
# out_date字段是索引字段，但是由于使用函数进行计算，所以该索引不生效

# 修改
select ... from product
	where out_date <= date_add(current_date, interval 30 day)
```
### 2. 前缀索引和索引列的选择性
```sql
create index index_name on table (col_name(n))
# 指定索引列的宽度，在innodb宽度是767个字节，myisam表索引列的宽度最大值是1000
```

索引列的宽度越大，索引的唯一性就越高，选择性自然也越高。
这里的选择性是指不重复的索引值和表的记录数的比值，索引的选择性越高，查找效率就越快，所以主键索引和唯一索引的效率是最高的。

注：在创建前缀索引的时候，要在索引的长度和唯一性之间做一个平衡。

### 3. 联合索引
联合索引时按照左前缀匹配规格来进行匹配的，索引列顺序要按照该规则来进行创建。

- 经常会被使用到的1个或多个列优先创建
- 选择性高的列优先创建
- 宽度小的列优先使用，不违反选择性高的前提下创建，宽度越小意味着一页所能存储的索引越多，使用索引过滤时I/O会越小，也加快了查找效率

### 4. 覆盖索引
定义：B-tree索引的叶子上存储了索引列的值，所以如果能通过索引直接获取查询到的数据，这样也就没有必要去读取数据行的信息了，这种包含了所有需要查询的字段的全部值的索引，被称为覆盖索引。

这里的全部值不仅是where条件查询的字段，还包括order by、group by从句中的字段。

优点：
- 可以优化缓存，减少磁盘I/O操作
- 可以减少随机I/O，将随机I/O变为顺序I/O
- 避免innodb主键索引的二次查询
- 避免myisam表对系统的调用

innodb的主键索引的叶子节点是直接绑定了数据，而二级索引的叶子节点保存的是行的主键值，通常情况下如果是利用二级索引来查询数据，在查找到相应的键值后，还需要利用主键来查询相应的记录。


### 5. 使用索引扫描来优化排序 
使用索引扫描时，由于只需要从一条索引记录移动到下一条索引记录，所以查询速度是很快的。

- 索引的列顺序和order by子句的顺序完全一致
- 索引中所有列的方向（升序，降序）和order by子句完全一致
- 在多个表的关联查询中，order by中的字段全部在关联表中的第一张表中

所谓的列顺序和order by子句顺序完全一致，指的是在有联合索引的情况下，例如：
```sql
# 假设有一个联合索引：rental_date(rental_date, inventory_id, customer_id)

select * from rental
	where rental_date = '2016-6-1' order by inventory_id, customer_id
# 索引列顺序要与order by子句一致，也就是满足左前缀匹配规则


select * from rental
	where rental_date = '2016-6-1' order by inventory_id, customer_id desc
# 将会使用filesort，因为所有列的升序、降序不一致。

select * from rental
	where rental_date > '2016-6-1' order by inventory_id, customer_id
# 会使用filesort，因为不满足如下规则
# B-tree索引如果左边的列使用到范围查询，右边的列将不会起作用
```


### 6. 模拟hash索引优化查询
MySQL的B-tree索引长度是有限制的，如果要在一个很长字符的列上创建索引，一般我们会使用前缀索引限制索引的长度，然而这样又会使索引的唯一性变得很差，在这种情况下可以通过模拟hash索引来实现优化查询。

实现：
- 在表中增加一个32位字符长度的字段，并将其作为索引创建
- 将原本要创建索引的列的值进行md5转换再跟新到新增字段中

通过这种方式，我们只需要将原本很长字符列的值进行MD5转换，再从数据库中查询即可，
这样在索引的唯一性和长度控制上就达到一个比较好的平衡。


### 7. 利用索引来优化锁
innodb存储使用的是行级锁，只有在修改行时才会对这行记录加锁，但是是在innodb存储引擎层在过滤掉不需要的行时，才会有效，

如果存储引擎层不能过滤不需要的行则会对所有行记录进行锁定，然后在内存中通过where条件来过滤，所以通过使用索引来减少锁定的行数。

- 索引可以减少锁定的行数
- 索引加快了处理速度，同时也加快了锁的释放

```sql
# 开启俩个事务，分别在有索引和无索引的条件下做排它锁查询测试

# 事务1
select * from actor where last_name

# 事务2
```


### 8. 索引的维护和优化
MySQL允许在相同的列上建立多个索引，对于这些索引MySQL都会单独维护，并且在查询优化器优化中还会被这些索引进行选择，对于数据库性能是会造成影响的。

### 重复索引
例如：
```sql
primary key(id), unique key(id), index(id)
```

### 冗余索引
例如：
```sql
index(a), index(a,b)
primary key(a), index(a,id)

# 这些都是冗余索引，冗余索引可以按照情况决定是否保留。
```