## Innodb
在MySQL5.5版本之后，Innodb成为了MySQL的默认存储引擎。
Innodb事务型存储引擎，支持ACID特性，innodb的设计更适合大量的小事务。


### 1. 数据存储方式
Innodb有表空间的概念，表中的数据是存储在表空间的。

具体存储在哪个表空间，由innodb_file_per_table参数决定，该参数是on，会为每个innodb表建立一个以idb为扩展名的系统文件，也就是独立的表空间；如果是off，则会把数据存储到系统的共享表空间，也就是idbdatax中，x是代表一个数字，从1开始。

```sql
show VARIABLES like 'innodb_file_per_table'

set global innodb_file_per_table='on';
# 设置不同参数值，查看文件存储方式的改变
```

### 2. 系统表空间与独立表空间的选择
- 系统表空间无法简单的收缩文件大小
如果在磁盘空间不足的时候，为了释放磁盘空间一般会选择删除表中无效的数据或者长期不会使用到的日志数据，但是在删除后系统表空间并不会缩小。

- 独立表空间可以通过optimize table命令收缩系统文件

- 系统表空间会产生I/O瓶颈：在对多个表进行数据刷新，在系统层面上是顺序执行的
- 独立表空间可以同时向多个文件刷新数据

总结：通过上述对比，建议使用独立表空间来配置。



### 3. 系统表空间转独立表空间
- 使用mysqldump导出所有数据库表数据，包括存储过程、触发器、计划事件等
- 停止MySQL服务，修改参数，并删除innodb相关文件
- 重启MySQL服务，重建Innodb系统表空间
- 重新导入数据

迁移

### 4. 特性
Innodb是一种事务型存储引擎，完全支持事务的ACID特性。
Redo Log和Undo Logo实现了事物的原自行、一致性、持久性，而隔离性是通过锁来实现的。

### Redo Log
Redo Log是重做日志，主要用于实现事务的持久性，主要有俩部分组成。

一个是内存中的重做日志缓冲区，由innodb_log_bffer_size参数配置，
另外一个是重做日志文件，文件一般在MySQL的data目录下，名字是ib_logfilex，x是数字，大小是innodb_log_files_in_group决定的。

```sql
show VARIABLES like 'innodb_log_bffer_size'
# 重做日志缓冲区，单位为字节，由于最多每隔一秒就会将数据刷新到磁盘上，因此该值并不需要特别大

innodb_log_files_in_group
# 决定重做日志文件的数量
```

### Undo Log
Undo Log是回滚日志，主要是帮助未提交事务进行回滚和实现mccc多版本并发控制，Redo Log存储的是以提交的事务，Undo Log存储的是未提交的事务。

默认执行SQL语句时，innodb引擎会开启一个事务来执行，因此在修改innodb表的数据，不仅会产生Redo Log，还会产生Undo Log信息，这样用户执行的语句或者事务由于某种原因失败，在使用rollback回滚时，就会利用到undo log文件中的信息了。

通过上面的介绍已知Redo Log是顺序写入的，在数据库运行时不需要对数据进行读取操作，而Undo Log是需要进行随机读写的。

### 支持行级锁
行级锁的特点是在进行写入操作时，所需要锁定的资源更少，支持的并发会更多。
innodb的行级锁是在存储引擎层实现的，MySQL完全不知道innodb引擎的实现方式。

### 锁的类型
锁是数据库系统区别于文件系统的一个重要标志，锁的作用如下：
- 用于管理共享资源的并发访问
- 锁用于实现事务的隔离性

锁的类型有：
- 共享锁：读锁，读锁是共享锁的，多个线程可以读取同一个资源而不会阻塞
- 独占锁：写锁，写锁是独占的，一个写锁会阻塞其他写锁和读写，这是为了数据的完整性考虑，只有这样才能保证在给定的时间里只有一个线程写入数据，并防止其他用户读取正在写入的数据。

写锁与其他锁不兼容，读锁与读锁兼容，跟写锁不兼容。
这里要注意的是innodb的锁是针对行级的，当然实际上回更复杂的多。

说明：我们可以通过lock和unlock关键字来加锁，实现对俩中不同类型锁的测试。

### 锁的粒度
锁的策略，被加锁资源的最小单位，如加锁的数据是一行数据，最小单位是行级，加锁的数据是数据页，是页级锁，如果加锁的数据是整张表，那么就是表级锁。

MySQL支持的锁粒度：
- 表级锁：表锁开销小，并发性低。表锁会在加锁时锁定整张表，一个用户在做写入的时候这时候需要解锁，会阻塞其他用户，只有解锁时其他用户才能获取读取
- 行级锁：行锁开销大，并发性高。

问题：什么情况下MySQL会加锁，锁的类型是什么，粒度如何决定？
锁的粒度是由存储引擎实现的，锁的类型是由用户的操作类型决定的，查询一般对应共享锁，修改对应排它锁。

### 阻塞和死锁
- 阻塞：因为不同锁之间兼容性的关系，在有些时刻一个事物中的锁需要等待另一个事物中的锁释放它所占用的资源，这就形成了阻塞。

- 死锁：指俩个或俩个以上的事物在执行过程中，相互占有对方等待的资源而产生的异常，

阻塞是指阻塞事物占用了被阻塞事物的资源，而死锁则是俩个事物互相占用对方的资源，这是阻塞和死锁之间的不同之处。对于死锁，MySQL会选出占用资源做少的事物来进行回滚操作，让其他事物正常运行。

### 拥有独特的性能监控工具
这是innodb引擎独有的命令：show engine innodb status;

包含了innodb存储引擎在一定时间内的平均值的统计信息，这些平均值是上次输出结果后生成的统计数，所以想要使用该命令，需要间隔至少30秒进行采样。


### 5. 使用场景
由于现在innodb存储引擎非常强大，所以在应用中除非需要使用innodb存储引擎不支持特性的功能，例如全文索引或者空间应用等应用，这种情况只能选择MyISAM引擎。



## 存储引擎的选择
从4个方面来考虑：
- 事物支持
- 热数据备份
- 奔溃恢复
- 存储引擎特性



MyISAM存储引擎在系统崩溃后出现数据损坏的几率比Innodb存储引擎高，并且回复速度也没有innodb快。

最后才是从存储引擎特性来决定选择存储引擎的使用。

建议不要混合使用存储引擎，例如MyISAM和Innodb的混合使用，例如在进行事物回滚，MyISAM存储引擎的表无法实现回滚，在做热数据备份的时候，MyISAM引擎的表也不支持热数据备份。