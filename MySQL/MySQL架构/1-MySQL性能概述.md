## 影响数据库性能

### 1. QPS和TPS
QPS是每秒钟所处理的查询量，例如一个处理一个SQL是10ms，1秒中就能处理100个，这时候QPS是小于100。

在当前5.x系列版本中，MySQL是不支持多cpu并发运算的，每一个SQL只能用到一个CPU，QPS和TPS是我们衡量SQL的处理效率。

超高的QPS和TPS下，效率低下的SQL会带来恶劣的影响。
例如在电商大促下访问量会大幅增长，随着网络量的增长必然会有超高的QPS和TPS，在这种情况下每条SQL语句的处理时间就非常重要了。

说明：在以往的经验中，大多数数据库性能瓶颈是由满查询引起的，大多数数据库问题可以通过优化SQL语句来处理。

### 2. 大量的并发和超高的CPU使用率
- 并发量
指同一时刻数据库服务器所处理请求的数量，高并发会使数据库连接数被占满。

- 连接数
连接量一般要比并发量要大的多，现在的前端服务器（nginx、apache）都会与数据库建立多个连接，在这众多的连接当中通常只有几个是在请求数据库处理的，其他的大多数连接都是处于sleep状态。
连接数在MySQL中是由max_connection决定的，默认值是100，如果连接数超过参数限制，其他真正有用的前端服务器就会无法连接数据库了。

- 超高的CPU使用率会使计算机的CPU资源耗尽而导致宕机。

### 3. 磁盘IO
磁盘IO是影响数据库性能的一个重要指标，常发生的问题是磁盘IO性能突然下降，这种问题经常发生在热数据远远大于服务器可用内存的情况下，解决方案：

- 使用更快的磁盘设备
- 调整大量消耗磁盘性能的计划任务（调整计划任务）

### 4. 网卡流量
网卡流量被占满，会导致其他请求无法连接数据库。
一千兆的网卡约等于100MB（1000Mb/8）每秒流量，解决方案：

- 减少从服务器的数量，因为从服务器需要去主服务器复制日志，从服务器越多用到的流量就越大。
- 进行分级缓存，避免前端大量缓存失效，对数据库造成大量的冲击。
- 避免使用select *进行查询，查询出不用的数据会浪费网卡IO流量。
- 分离业务网络和服务器网络。

## 大表
大表都是相对而言，对于不同的存储引擎会有不同的限制，例如innodb并没有定义每个表最大行数是多少，只要存储空间允许就允许插入数据。

从二个纬度来定义大表
- 记录行数巨大，单表超过千万：如果这个表只是insert和少量select操作，并不会影响操作，例如日志表。
- 表数据库文件巨大，表数据文件超过10G

### 1. 大表带来的问题
- 慢查询：大表意味着会带来慢查询，很难在一定时间内过滤出所需要的数据
- 对DDL操作的影响：建立索引需要很长的时间，造成长时间的主从延迟，由于锁表会影响针对这张表的数据库连接访问，造成大量的数据库连接长时间阻塞。

注：MySQL<5.5建立索引会锁表，>=5.5虽然不会锁表但是会引起主从延迟。

### 2. 大表的处理
- 分库分表：把一张大表分为多个小表，难点是分表主键的选择，第二个难点是分表后跨分区数据的查询和统计
- 大表的历史数据归档：减少对前后端业务的影响，难点1是归档时间点的选择、难点2是如何进行归档操作。

## 事物
事物：是数据库系统区别于其他一切文件系统的重要特性之一，是一组具有原子性的SQL语句集合，或者是一个独立的工作单元。	

原子性、一致性、隔离性、持久性。

### 1. 原子性
一个事物必须是一个不可分割的最小工作单元，整个事物中的操作要么全部成功，要么全部失败，不可能只执行其他一部分操作。

### 2. 一致性
一致性是指事物将数据库从一种一致性状态转换到另外一种一致性状态，在事物开始之前和事物结束后数据库中数据的完整性没有被破坏。

### 3. 事物的隔离性
隔离性要求一个事物对数据库中数据的修改，在未提交完成前对于其他事物是不可见的。
在SQL标准定义了4种隔离性，
- 未提交读（read uncommited）：在未提交读这种事物隔离级别中，事物中对数据进行的修改，即使事物还没有提交，对于其他事物也是可见的，这里引起一个脏读的概念，事物能够读取未提交事物的数据，称为脏读，读取的数据叫做脏数据（不准确的数据）

- 已提交读（read commited）：一个事物开始时只能看到已提交事物的修改，另外一种说法是一个事物在未提交之前，其他事物是无法看到该事物的修改的。这是大多数数据库系统的默认隔离级别，例如Oracle、SQL Server等，但是MySQL是个例外。

- 可重复读（repeatable read）：该隔离级别保证了在同一个事物中多次读取同样的记录的结果是一致的，相比已重复读，以提交读又被成为不可重复读。

- 可串行化（serializable）：可串行化是最高的隔离级别，会在读取	的每一行数据上都加锁，可能会导致大量的锁超时和锁争用的问题，在实际业务中很少使用，除非是严格要求数据一致性并且在没有并发的情况下才考虑使用。

这4个隔离级别，隔离性由低到高，而并发性由高到低。

注：在MySQL中，innodb的隔离级别默认是可重复读。

### 可重复读与以提交读的区别
```sql
show variables like '%iso%';
# 显示当前事物的隔离级别

set session tx_isolation 'read-committed';
# 设置隔离级别为已提交读
# repeatable-read

create table sequence(
	id int primary key
)engine myisam charset=utf8
insert into sequence values(1),(3),(5),(7),(9),(11)

# mysql connection1，隔离级别是可重复读
begin;
select id from sequence where id < 8;
# 显示1,3,5,7

# mysql connection2
begin
insert into sequence values(2)
commit
# 开启一个事物插入数据，再次执行connection1的查询，数据仍然是1 3 5 7，如果隔离级别是以提交读，则能查询到2的记录。

# 这点是可重复读与以提交读的区别

```

### 4. 持久性
一旦事物提交，所有修改会永久保存在数据库中，此时即使系统奔溃，已经提交的修改数据也不会丢失，

这是从数据库的角度来说的，不包括外部因素影响，例如磁盘损坏影响到的。


## 大事务
定义：运行时间比较长，操作的数据比较多的事务。

例如余额宝用户的收益，在每一天结束后需要计算所有用户每个人的收益，再跟新到用户的余额中，但是数以亿计的用户事务的更新可能需要数个小时，一旦中间出现问题事物会回滚，更新的时间就不可估量，更不要说在更新过程中会对所有用户加锁，造成用户无法访问的问题。

这样的事务就称为大事务，当然余额宝余额更新并不会是在一个事务中进行的。


风险
- 锁定太多的数据，造成大量的阻塞和超时
- 回滚时所需要的时间比较长
- 执行时间长，容易造成主从延迟

解决：
- 避免一次处理太多的数据，分批处理事务
- 移除不必要在事务中的select操作