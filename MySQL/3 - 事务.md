隔离性与隔离级别

隔离性是指事务的ACIP中的I，即Isolation。

当数据库上有多个事务同时执行的时候，就会出现脏读、不可重复读、幻读等问题，隔离级别就是为了解决这些问题。要知道，隔离级别越高，运行效率就越低。

- 读未提交

  read uncommitted，一个事务在未提交时，它所做的更改可以被其他事务看到。

- 读提交

  read committed，一个事务的更改只有在提交时才能被其他事务看到。

- 可重复读

  repeatable read，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据时一致的。

  当然在可重复读隔离级别下，未提交的变更对其他事务也是不可见的。

- 串行花

  serializable，对于同一行记录，写会加写锁，读会加读锁。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成才能继续执行。



### example

设置事务的隔离级别

```sql
-- 设置当前回话的隔离级别
set session transaction isolation level repeatable read;

-- 当前回话的隔离级别
select @@tx_isolation;

-- 设置全局事务的隔离界别
set global transaction isolation level read committed;

-- 全局隔离级别
select @@global.tx_isolation;


select * from test where id = 1;
update test set name = 'qwer' where id = 1;
```



案例说明：

|        事务A        |        事务B        |
| :-----------------: | :-----------------: |
| 启动事务，查询A的值 | 启动事务，查询A的值 |
|                     |   将A的值由1该为2   |
| 查询A的值，得到值a  |                     |
|                     |      提交事务       |
| 查询A的值，得到值b  |                     |
|        提交         |                     |
| 查询A的值，得到值c  |                     |

- 如果隔离级别是"读未提交"，事务A的值a、值b和值c都是2。

- 如果是"读提交"级别，值a是1，值b是2，值3是2。
- 如果是"可重复读"，值a和值b是1，值c是2。
- 如果是"串行化"，事务B在更改时会被锁住，直到事务A执行完毕后才允许事务B执行。所以值a和值b是1，值c是2.

在实现上，数据库会创建一个视图，访问的时候是以视图的逻辑结果为准。

在"可重复读"隔离级别下，数据库会在事务启动的时候创建一个视图，整个事务存在期间都使用该视图；在"读提交"隔离级别下，事务是在每个SQL语句开始执行的时候创建的。

要注意的是"读未提交"隔离级别下直接返回记录上的最新值，没有视图概念；而"串行化"是直接以加锁的方式来避免并行访问的。



note：可重复读的应用场景，例如数据校对，因为事务启动时的视图可以认为是静态的，不收其他事务的影响。



### 回滚日志

每条记录在更新的时候都会记录一条回滚高作。记录上的最新值，通过回滚操作可以得到前一个状态的值。



在没有事务使用回滚日志的时候，回滚日志将会被删除。（事务视图?）



>   在可重复读的隔离级别下，如何理解**当系统里没有比这个回滚日志更早的 read-view 的时候**，这个回滚日志就会被删除？
>
> 这也是**尽量不要使用长事务**的主要原因。
>
> 比如，在某个时刻（今天上午9:00）开启了一个事务A（对于可重复读隔离级别，此时一个视图read-view A也创建了），这是一个很长的事务……
>
> 事务A在今天上午9:20的时候，查询了一个记录R1的一个字段f1的值为1……
>
> 今天上午9:25的时候，一个事务B（随之而来的read-view B）也被开启了，它更新了R1.f1的值为2（同时也创建了一个由2到1的回滚日志），这是一个短事务，事务随后就被commit了。
>
> 今天上午9:30的时候，一个事务C（随之而来的read-view C）也被开启了，它更新了R1.f1的值为3（同时也创建了一个由3到2的回滚日志），这是一个短事务，事务随后就被commit了。
>
> ……
>
> 到了下午3:00了，长事务A还没有commit，为了保证事务在执行期间看到的数据在前后必须是一致的，那些老的事务视图、回滚日志就必须存在了，这就占用了大量的存储空间。
>
> 源于此，我们应该尽量不要使用长事务。  



### 长事务

长事务就是从事务开始到提交，这期间时间很长

在系统中存在着很老的事务视图。

由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能使用到的回滚日志必须保留，不仅会占用很大的存储空间，而且占用锁资源，也可能会拖垮整个库。



> set autocommit = 1;
>
> 执行SQL语句时，会自动开启与提交事务
>
> set autocommit = 0;
>
> 执行SQL语句时，只会启动事务，但是不会自动提交。



```sql
select * from information_schema.innodb_trx TIME_TO_SEC(timdiff(now(), trx_started) > 50
```



避免长事务：

确认是否开启事务的自动提交，set autocommit=1。

业务连连接数据库的时候，根据业务本身的预估，通过set max_execution_time命令，来控制每个语句的执行时间。

从数据库角度来看：

监控information_schema.Innodb_trx表，设置长事务的阈值，超过就报警或者kill掉。

Percona 的 pt-kill 这个工具不错，推荐使用；

在业务功能测试阶段要求输出所有的 general_log，分析日志行为提前发现问题。











