### 隔离级别

为什么会有隔离级别?

当数据库上有多个事务同时执行的时候，就会出现脏读、不可重复读、幻读等问题，隔离级别就是为了解决这些问题。隔离级别越高，运行效率就越低。

隔离级别有四种：

- 读未提交

  read uncommitted，一个事务在未提交时，它所做的更改可以被其他事务看到。

- 读提交

  read committed，一个事务的更改只有在提交时才能被其他事务看到。

- 可重复读

  repeatable read，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据时一致的。

  当然在可重复读隔离级别下，未提交的变更对其他事务也是不可见的。

- 串行化

  serializable，对于同一行记录，写会加写锁，读会加读锁。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成才能继续执行。

简单的说，一个事务对数据进行操作的时候，不同隔离级别下会对其他事务发生什么影响。



### example

测试不同隔离级别下，事务的不同行为。

```sql
-- 设置当前回话的隔离级别
set session transaction isolation level repeatable read;

-- 当前回话的隔离级别
select @@tx_isolation;

-- 设置全局事务的隔离界别
set global transaction isolation level read committed;

-- 全局隔离级别
select @@global.tx_isolation;

create table T(A int) engine=InnoDB;
insert into T(A) values(1);

select * from test where id = 1;
update test set name = 'qwer' where id = 1;
```



案例说明：

|        事务A        |        事务B        |
| :-----------------: | :-----------------: |
| 启动事务，查询A的值 | 启动事务，查询A的值 |
|                     |   将A的值由1该为2   |
| 查询A的值，得到值a  |                     |
|                     |      提交事务       |
| 查询A的值，得到值b  |                     |
|        提交         |                     |
| 查询A的值，得到值c  |                     |

- 如果隔离级别是"读未提交"，事务A的值a、值b和值c都是2。

- 如果是"读提交"级别，值a是1，值b是2，值3是2。
- 如果是"可重复读"，值a和值b是1，值c是2。
- 如果是"串行化"，事务B在更改时会被锁住，直到事务A执行完毕后才允许事务B执行。所以值a和值b是1，值c是2.

在事务隔离级别的实现上，数据库会创建一个视图，访问的时候是以视图的逻辑结果为准。

- 在"可重复读"隔离级别下

  数据库会在事务启动的时候创建一个视图，整个事务存在期间都使用该视图的数据。

- 在"读提交"隔离级别下

  这个视图是在每个SQL语句开始执行的时候创建的，它的作用范围只限于当前执行的SQL语句。

比较特殊的是"读未提交"隔离级别下会直接返回记录上的最新值，没有视图概念，而"串行化"是直接以加锁的方式来避免并行访问的。

note：可重复读的应用场景，例如数据校对，因为事务启动时的视图可以认为是静态的，不受其他事务的影响。



### 事务隔离的实现

MVCC

同一条记录在系统中可能存在多个版本，它们之间不冲突，这是数据库的多版本并发控制（MVCC）。

所谓的多版本是指在查询一条记录时，不同时刻启动的事务会有不同的read-view（视图），这里的视图可以理解为数据副本，将当前已持久化的数据创建副本，通过读取副本数据来达到事务隔离效果。

当然视图（数据副本）在不同隔离界别下会有不同的变化：

- 对于重复读，不同时刻启动的事务的视图数据在事务周期内都是相同的。
- 对于读提交，每条SQL语句会启动一个视图，它只作用于该条SQL语句。

所谓的不冲突是指同一条记录多个版本的事务提交时，MySQL会通过锁机制来控制事务并发的提交。



undo log（回滚日志）

同时每条记录在更新的时候都会记录一条回滚操作（回滚段），记录上最新的值可以通过回滚段来进行回复。我们知道同一条记录会有不同版本的事务，因此每个版本的事务都会有对应的回滚段。

这些回滚段都记录在回滚日志中，只有当系统里面没有比当前回滚日志更早的read-view的时候，也就是没有事务使用这些老的回滚日志时，它们才会被删除。



### 长事务

长事务就是从事务开始到提交，这期间时间很长。

长事务可能占用锁资源，一个长事务在修改某条记录时，其他修改该记录的事务会被阻塞。

长事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能使用到的回滚日志必须保留，所以事务还占用存储空间。



因此在开发中要尽量避免长事务：

- 配置autocommit

  将autocommit设为1，每次执行SQL语句时都会自动提交事务。如果设为0，意味着执行SQL语句时，启动的事务不会自动提交

- 显示启动事务

  begin、start transaction、commit或rollback。

- 监控长事务的发生

  在information_schema库中的innodb_trx表中查询长事务，比如：

  > select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(), trx_started)) > 60

Percona 的 pt-kill 这个工具不错，推荐使用；在业务功能测试阶段要求输出所有的 general_log，分析日志行为提前发现问题。





### 命令

> show variables;	//显示MySQL所有配置参数
>
> show variables like 'transaction_isolation';	//单独显示某个配置



