一条更新语句的执行过程。

```sql
create table T(ID int primary key, c int);
update T set c = c + 1 where ID = 2;
```

更新语句同查询语句一样，也是要执行相同的流程的。但是与查询语句不通，更新语句还涉及到俩个重要的日志模块。



### redo log

如果每一次的更新都是写入磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个I/O成本、查询成本都很高。



更新一条日志时，InnoDB引擎会把记录写到redo log里面，并更新内存，这时更新就算完成了。只有在空闲的时候，InnoDB引擎才会把这个操作记录更新到磁盘里面。

如果redo log写满了，引擎会擦除一部分记录并更新到磁盘中，为新记录的更改挪出空间。



InnoDB的redo log是固定大小的，比如配置为一组4个文件，每个文件大小是1G，总共可以记录4G的操作。引擎会定义write pos指针和checkpoint指针。

write pos指向当前记录的位置，一边写一边后移，写到最后一个文件末尾会回到0号文件开头。checkpoint指针指向当前要擦除的位置，也是向后推移并且循环的，擦除记录前会把记录更新到数据文件中。



有了redo log，MySQL就有了crash-safe能力，即InnoDB可以保证数据库发生异常重启，之前提交的记录不会丢失。



### bin log

MySQL的Server层也有自己的日志，称为binlog（归档日志），用于归档。

在没有InnoDB引擎之前，MySQL是没有crash-safe能力的，所以InnoDB引擎才引入了redo log日志来实现crash-safe能力。

这俩个日志的不同点在于：

- redo log是InnoDB引擎特有的；而binlog日志是MySQL的Server层实现的，所有引擎都可以使用。
- redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是语句的原始逻辑，比如给"id=2这一行的c字段加1"
- redo log是循环写的，空间固定会用完；binglog是可以追加写入的，一个文件写到一定大小后会切换下一个，并不会覆盖之前的日志





在了解俩个日志的概念后，来看看执行器和InnoDB引擎在执行这个update语句的内部流程。

- 执行器先找引擎取ID=2这条记录，ID字段是主键，引擎会通过树搜索来寻找这一行。如果ID=2这行所在的数据页本来就在内存中，就直接返回给执行器；否则需要从磁盘中读取内存，然后再返回。

- 执行器拿到引擎给的这行数据，把这个值加上1，得到一行新的记录再调用存储引擎写入这行新数据。

- 引擎将这行新数据更新到内存中，同时将这个更新记录记录到redo log里面，此时redo log处于prepare状态，然后告知执行器执行完成了，可以随时提交事务。
- 执行器生成这个操作的binlog，并把binlog写入磁盘。
- 执行器调用存储引擎的提交事务接口，引擎会把刚才写入的redo log改为提交（commit）状态，更新完成。



### 俩阶段提交

为什么把redo log分为prepare和commit俩个阶段提交？这是为了保证俩个日志之间的逻辑状态一致。

假设不分为俩阶段提交，要么就是写完redo log再写binlog，或者相反过来，这俩种方式会有这些问题。

先写redo log再写binlog

同样是更新id=2这条记录，假设c字段初始化为0，在更新为1时写入redo log日志，这时如果crash，没有写入binlog日志。

那么InnoDB在恢复时id=2这行记录就为1，可是使用binlog进行归档时，这行id=2这条记录就与原库不一样了。



先写binlog再写redo log

如果先写binlog之后crash，由于redo log还没写，奔溃以后这个事务无效，所以这一行的值是0。但是binlog已经记录了"把c=0改为1"这个日志。所以之后使用binlog来恢复的时候就多出一个事务来，与原库的值不同。



1. redo log prepare阶段
2. binlog写入阶段
3. redo log commit阶段

当在2之前奔溃时，重启恢复发现redo log没有commit，进行回滚。而备份恢复时，没有binlog日志，所以俩个日志保持一致。

当在3之前奔溃时，虽然redo log没有commit，但是满足preapre和binlog完成，所以重启后会commit redo log。而备份恢复时，有binlog，保持一致。





参数

innodb_flush_log_at_trx_comit，该参数建议为1，表示事务每次的redo log都直接持久化到磁盘中，保证MySQL异常重启后数据不丢失。

sync_binlog，表示每次事务的binlog都持久化到硬盘，可以保证MySQL异常重启之后数据不丢失。

