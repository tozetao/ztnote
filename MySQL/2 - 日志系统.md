一条更新语句的执行过程。

```sql
create table T(ID int primary key, c int);
update T set c = c + 1 where ID = 2;
```

更新语句同查询语句一样，也是要执行相同的流程的。

首先程序与MySQL服务器进行连接，在执行SQL语句时，分析器会通过词法分析和语法分析知道这是一条更新语句，接着优化器会选择ID这个索引，生成执行计划，最后由执行器找到该条记录进行更新。

与查询语句不同，更新语句还涉及到俩个重要的日志模块。



### redo log

redo log日志主要用于降低更新操作的IO成本。

如果每个更新一条记录都是写入磁盘，那么需要先从磁盘中找到对应的那条记录然后再更新，整个IO和查询成本很高。而将更新操作收集起来，顺序的写入到redo log中，等到空闲时再写入磁盘，整体的IO效率会提升很多。



因此更新记录时，会有俩种情况：

- 记录对应的数据页在内存中

  会先更新内存中的数据页，然后在redo log日志上记录数据页的变化

- 记录对应的数据页不在内存中

  将数据页的更新操作记到change buffer中，同样会再redo log日志上记录数据页的变化。

这种先写入日志，再写入磁盘的方式被称为Write-Ahead Logging，简称WAL。



### redo log的实现

redo log日志是固定大小的，例如配置一组4个文件，每个文件大小1G，那么可写空间就是4G。MySQL会从第一个文件开始写，写到最后一个文件写完时会重头开始写。

循环写是通过write pos指针与check point指针实现的。write pos指针指向当前写入地址，一边写一边往后移动，如果写到末尾文件会回到0号文件开头；check point指针则指向要擦除的地方，即把日志记录写入到磁盘。

write pos与check point之间的部分是可以写入的空间，如果write pos碰到check point，那么check point指针会就擦除一部分数据，留出可以写入日志记录的空间。

通过redo log，InnoDB就可以保证数据库发生异常重启，数据也不会丢失。这种能力被称为crash-safe。



### flush

更新操作是先写内存，再写日志。内存中的数据页相对于磁盘上的数据页总是最新的，因此需要在某种情况下进行同步，这个同步过程就是flush。

根据数据页的状态可以分为脏页和干净页：

- 脏页

  内存数据页的数据与磁盘数据页的数据不一致，那么该内存页被称为脏页

- 干净页

  内存页写入磁盘后，内存和磁盘上的数据页的内容一致了，就称为干净页。

MySQL偶尔抖动一般是触发刷脏页了（flush），引发flush的情况有4种：

- redo log日志写满了

  日志写满时，writepos指针会追上checkpoint指针，这时系统会停止所有更新，把checkpoint向前推进，预留出写空间。而推进的部分，对应的脏页会写入到磁盘中。

- 内存不足

  当InnoDB buffer pool不够用时，就会淘汰掉一部分不常使用的数据页，空出空间给新的数据页使用。如果淘汰的是脏页就写入磁盘。

  flush脏页就写磁盘是为了性能考虑，flush脏页就写磁盘可以保证每个数据页有俩种状态：一种是在内存中的数据页就一定是正确的结果，可以直接返回；另一种是内存中没有数据，就可以肯定数据文件上的结果是正确的，读入内存后返回，这样效率最高。

- MySQL关闭时

- 系统空闲时



刷新脏页对于性能的影响主要看前俩种情况。

对于第一种写满redo log就刷新脏页的时候，会导致整个系统的更新就停止了，从监控上更新数会跌为0，建议redo log文件不能太小，否则系统会频繁的抖动。



而第二种情况，内存不够用，要先将脏页写到磁盘，这种情况是常态。InnoDB用缓冲池（buffer pool）管理内存、缓冲池中的内存页有三种状态：

- 没有使用过的
- 使用过了且是干净页
- 使用过了且是脏页

InnoDB策略是尽可能的使用内存，对于一个长时间运行的系统来说，未被使用过的页很少。它在淘汰一个数据页时，会把缓冲池中最久未使用的页淘汰掉。

虽然刷脏页是常态，但是如果一个查询要淘汰的脏页太多，会导致查询的响应时间变长，因此InnoDB有控制脏页比例的机制，来避免上述俩种情况。

也就是说查询时如果发生flush脏页，那么该查询会变慢。



### 刷脏页的控制策略

刷新脏页的刷新速度过慢，会导致内存脏页太多，redo log日志也容易写满。而太快的话，占用磁盘全部IO也不行。

刷新脏页的速度会考虑俩个因素：一个是内存脏页比例，一个是redo log写盘速度。

InnoDB会根据这俩个因素计算出俩个0-100的数值，取其中较大的一个数值，我们标记为R%，然后乘以磁盘IO能力来控制脏页的写入速度。



从内存脏页比例因素来考虑的话，该数值的计算伪代码类似这样：

```sql
F1(M) 
{
	if M >= innodb_max_dirty_pages_pct then
		return 100;
	
	return 100 * M / innodb_max_dirty_pages_pct;
}
```

```sql
show status like 'Innodb_buffer_pool_pages_dirty';
--该参数是当前脏页数量
show status like 'Innodb_buffer_pool_pages_total';
--该参数是数据页总数。
```

innodb_max_dirty_pages_pct参数是脏页比例上限，默认值是75%，M是脏页比例，可以通过当前脏页数量和脏页总数来计算出来。

从redo log写盘速度因素来考虑，该数值的计算逻辑如下：

- InnoDB每次写入redo log都有一个序号，该序号与checkpoint指向的序号的差值，我们标记为N
- InnoDB会根据N计算出一个0-100的数值，N越大，InnoDB计算出来的数值就越大。计算逻辑复杂，略。



还有需要设置告知InnoDB磁盘的IO能力

```ini
innodb_io_capacity
```

该参数可以动态调整刷新脏页的数量，默认值是200，单位是页。该参数的大小取决于磁盘的IOPS，即每秒读写次数。

注：磁盘的读写能力可以通过fio软件测试。



```ini
innodb_flush_neighbors 
```

连坐机制，在刷新一个脏页时，如果发现旁边的数据页也是脏页，也会一起刷掉，并且该机制是会继续蔓延的。1表示开启该机制，0则关闭。

对于机械硬盘设置为1，固态硬盘设置为0.



### bin log

redo log是InnoDB引擎特有的日志，而bin log日志是MySQL Server层的日志，提供归档功能。

俩个日志的不同之处在于：

- redo log是物理日志，记录的是在某个数据页上做了什么修改；bin log是逻辑日志，记录的是这个语句的原始逻辑，比如给ID=2这一行的c字段加1

- redo log是循环写的，空间固定会用完；binglog是可以追加写入的，一个文件写到一定大小后会切换下一个，并不会覆盖之前的日志





### 两阶段提交

在了解了redo log与bin log后，再来看update语句在执行器与InnoDB存储之间的执行过程。

> update t set c = c + 1 where ID = 4

- 执行器先通过引擎获取到ID=4这条记录

- ID是主键，引擎会通过树搜索这行记录。如果ID=4这行记录的数据页本来在内存中，就直接返回给执行器，否则需要从磁盘中读取到内存，然后再返回。

- 执行器在拿到这行记录后，将c字段的值加1，再通过引擎写入这行新数据。

- 引擎将这行新数据更新到内存中，同时将这行记录写入到redo log日志中，此时这行记录在redo log日志中的状态为prepare，接着引擎会告知执行器redo log日志写入完毕，可以提交事务了。

- 执行器将该语句的执行逻辑写入到bin log日志中

- 执行器通过调用引擎的提交事务接口，将ID=4这行记录的在redo log中的状态改为commit状态

至此记录更新完毕。



俩阶段提交指的是redo log日志记录的俩种状态，它是为了保证数据在redo log和bin log日志文件中是一致性的。

如果redo log日志的记录没有俩种状态，在执行上面那条update语句过程中先写入第一个日志后，第二个日志没写完期间发生了crash（崩溃），会出现俩种情况：

- 先写入redo log，再写入bin log

  当MySQL重启时会根据redo log日志恢复崩溃之前的数据，由于bin log没写完MySQL就崩溃了，所以bin log日志这时候数据库恢复后的数据就与bin log日志的记录不一致了。

  如果使用bin log来恢复数据库，那么恢复的数据会不正确。

- 先写入bin log，再写入redo log

  如果先写入bin log日志后发生崩溃，由于redo log没写，在崩溃恢复之后该事务无效，所以要更新行的记录未修改成功，这就导致bin log与当前库的数据不一致了。

所以不用俩阶段提交，数据库的状态可能会和bin log日志恢复出来的库的状态不一致。





### 相关参数

- innodb_flush_log_at_trx_comit

  该参数建议为1，表示每次事务的redo log都直接持久化到磁盘中，保证MySQL异常重启后数据不丢失。

- sync_binlog

  表示每次事务的bin log都持久化到硬盘，可以保证MySQL异常重启之后数据不丢失。





备份的思考

一周一次备份 VS 一天一次备份

系统的对应指标是回复目标时间，一周一备只能回复上周之前的数据，一天一备可以回去昨天之前的数据，即最长回复时间更短。

