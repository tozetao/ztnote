在InnoDB中，有共享锁、独占锁。

共享锁是读锁，独占锁是写锁。它们的互斥关系为：读读不互斥，读写互斥，写写互斥。默认的查询不加锁，除非手动加锁，而更新会加独占锁。



### 共享锁

共享锁是当前读，即读取记录最新的数据版本。

```sql
select * from t where id = 10 lock in share mode;
```

该SQL对id=10的记录加共享锁，它会读取这行记录最新的数据版本。如果有其他线程持有这行记录的独占锁，该语句会被阻塞，直到对方释放独占锁。



### 独占锁

独占锁也是当前读，更新操作默认会加独占锁，也可以手动加锁。

```sql
select * from t where d = 5 for update;
```





### 幻读

一个事务在前面俩次查询同一个范围的时候，后一次查询看到前一次查询中没有看到的行。幻读在RR隔离级并且是当前读的情况下才出现的，也就是说RR级别下，普通的select语句是快照读，是不会产生幻读的。

假设有以下场景：

|      |                          session a                           |                          session b                           |           session c            |
| :--: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------: |
|  t1  | begin; select * from t where d = 5 for update; update t set c = 100 where d = 5; |                                                              |                                |
|  t2  |                                                              | update t set d = 5 where id = 0; update t set c = 5 where id = 0; |                                |
|  t3  |           select * from t where d = 5 for update;            |                                                              |                                |
|  t4  |                                                              |                                                              | insert into t values(1, 1, 5); |
|  t5  |           select * from t where d = 5 for update;            |                                                              |                                |
|  t6  |                           commit;                            |                                                              |                                |

在RR隔离级别下，假设session a的select语句只对d=5的记录加锁了，在t1时刻session a看到的记录只有(5, 5, 5)一条记录。

在t3时刻，session a由于是当前读，所以能看到session b的更新操作，这时看到的记录是(0, 5, 5), (5, 5, 5)俩行记录，这里破坏了sesion a查询语句的语义性。当执行到t5时刻，session a能看见session c插入的记录，这种情况就是幻读了。

上述的执行场景，除了产生幻读和对SQL语句的语义性破坏，还破坏了数据的完整性。三个session执行完毕后，binlog会根据事务的提交顺序记录更新的语句，大致如下：

```sql
--session b
update t set d = 5 where id = 0; 
update t set c = 5 where id = 0;

--session c
insert into t values(1, 1, 5);

--session a，最后提交的事务
update; update t set c = 100 where d = 5;
```

session a是最后提交事务的，它的更新语句会对前俩个session的数据造成破坏。



实际上为了维护数据完整性，在RR模式下，select语句处于当前读时，会对所有扫描过的行进行加锁，避免其他线程去更新当前线程扫描过的记录，所以session b会被阻塞。

而由于新插入的记录是无法加锁的，针对这点InnoDB使用间隙锁（Gap Lock），防止产生幻读。



### Gap Lock

在session a中的select语句，除了对扫描过的行加锁外，还在行与行之间进行了加锁，因此叫做间隙锁。

间隙锁只会对往记录间隙中插入新的记录这个操作产生阻塞，间隙锁与间隙锁之间不阻塞。比如：

| session a                           | session b                           |
| ----------------------------------- | ----------------------------------- |
| begin; select * from t where d = 9; |                                     |
|                                     | begin; select * from t where d = 9; |

由于没有d=9的记录，所以这条查询语句只会产生间隙锁，而间隙锁之间是不会互斥的，只有当其他线程发生插入这个操作才会阻塞，所以session b不会阻塞，只有当它要插入记录时才会阻塞，因为session a在(5,10)之间加了间隙锁。



间隙锁是开区间的，索引树默认会有一个最小值-∞，最有一个最大值∞，如果表中只有id=1一行记录，会有俩个间隙锁：（-∞, 1)，（1, ∞）。

一行记录对应上下俩个间隙锁，只要插入的记录在这俩个间隙之间，就会阻塞。比如通过索引查询扫描到一行记录，





缺点：间隙锁带来更大的加锁范围，也容易发生死锁。假设a、b线程都获得了某个间隙锁，当它们分别要插入记录时就会触发死锁，相互等对方释放间隙锁。











问题：如果select使用索引查询，会怎么加锁?

在RR级别下，select如果是当前读，只会针对扫描过的行数加行锁，会在扫描过的行记录之间加间隙锁。比如说通过索引扫描到一行记录，那么InnoDB只会对这行记录加行锁，



