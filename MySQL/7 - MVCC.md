MVCC即多版本并发控制，主要用于实现事务的隔离，它是通过一致性视图与数据版本来进行实现的。

MVCC是由InnoDB存储引擎实现的，并不是MySQL Server层实现的。



### 数据版本

一行记录在系统中是可能有多个数据版本的，数据版本可以理解为快照。

每个事务更新时都会产生新的数据版本，并把Transaction ID赋值给这个数据版本的事务ID，记为row trx_id。同时旧的数据版本会保留，而从新的数据版本能够拿到旧数据版本。

- Transaction ID

  每个事务都由自己的一个ID作为标识（transaction id），该事务ID是在事务开始时向系统申请的，并且是按照申请顺序严格递增的。

- row trx_id

  数据版本的事务ID

数据版本不是物理上真实存在的，而是每次在需要时根据当前版本和undo log计算出来的，也就是说每次更新时其实存储的是undo log日志。



- 数据版本的可见性

  更新时才会产生数据版本，而查询是根据当前隔离级别，选择对它来说可见的数据版本。



### 一致性视图

这里的视图不是查询语句定义的虚拟表，而是指InnoDB在实现MVCC时用到的一致性视图，即consistent view，用于支持RC（Read Committed）和RR（Repeatable Read）隔离级别的实现。

它没有物理结构，作用是事务执行期间用来定义"我能看到什么数据"。



创建时机：一致性视图是在执行第一个快照读语句时创建的，当然也可以执行

> start transaction with consistent snapshot

该语句会在事务启动时创建一致性视图，但是对于RC级别是无效的。



RR一致性视图的实现：

以RR（可重复读）进行说明，在实现上InnoDB为每个事务构建了一个数组，用以保存这个事务启动瞬间当前所有在执行中的事务。

数组里面事务ID的最小值记为低水位，当前系统已经创建的事务ID的最大值加1记为高水位。这个视图数组和高水位，就组成了当前事务的一致性视图。

而数据版本的可见性就是就是根据该一致性视图与数据版本的row trx_id对比结果得到的。这个视图数组把row trx_id分为三种情况：

1. 小于低水位的数据版本，表示已提交过的事务或者当前事务是自己发生的，是可见的

   低水位是视图数据中事务ID最小的值，并且视图数组记录的是执行中的事务，小于低水位自然是已提交的数据版本。

2. 大于等于高水位的数据版本是未开始的事务，或者说是将来提交的事务，是不可见的

3. 低水位与高水位之间的数据版本，是未提交的事务。

   这里分为俩种情况，如果数据版本的row trx_id是在数组中的，那么是不可见的；

   如果在视图数据外，那么是已经提交了的视图生成的，是可见的。

在有了一致性视图后，系统里面随后发生的更新，都跟这个事务看到的内容是无关的，因为之后的更新，生成的数据版本一定属于上面的2和3（3的第一种）的情况，对它来说这些新的数据版本都是不可见的。



### example

表结构

```sql
create table t(
	id int primary key,
    k int
)engine=innodb, charset=utf8;
insert into t values(1,1), (2,1);
```

多个事务执行流程如下：

|                    事务A                    |                           事务B                            |             事务C             |
| :-----------------------------------------: | :--------------------------------------------------------: | :---------------------------: |
| start transaction with consistent snapshot; |        start transaction with consistent snapshot;         |                               |
|                                             |                                                            | update set  k=k+1 where id=1; |
|                                             | update set k=k+1 where id=1; select k from t where id = 1; |                               |
|     select k from t where id=1; commit;     |                                                            |                               |
|                                             |                          commit;                           |                               |

在隔离级别是RR（可重复读），事务B k的值为3，事务A k的值为1。分析如下：

假设当前数据版本（1,1）的row trx_id为90，系统中只有一个活跃事务，它的事务ID是99。而事务A的ID为100，事务B的ID为101，事务C的ID为102。

那么事务A的视图数组为{99, 100}，事务B的事务数组为{99, 100, 101}，事务C的视图数组为{99, 100, 101, 102}。

- 对于事务C

  在更新k的值时会读取当前数据版本，它的row trx_id小于数组数组的低水位，因为k读取到的值是1，更新后为2，这是产生一个新的数据版本，row trx_id为102

- 对于事务B

  在更新k时读取当前数据版本，即事务C刚产生的数据版本，k的值为2，更新后为3并且产生一个数据版本，row trx_id为101.

  事务B查询时当前数据版本是101，即自身事务进行的更新，因此查询到的值为3.

- 对于事务A

  事务A查询时，当前数据版本101大于它的高水位，是不可见的。于是寻找上一个数据版本，它的ID也大于高水位，于是继续寻找直到数据版本90，小于它的低水位，该数据版本是可见的。

  所以事务A查询的值是1.



RR（可重复读）隔离级别的一致性视图实现，可以总结为一个数据版本，对于一个事务视图来说，除了自身的更新是可见的外，有三种情况：

- 版本未提交，不可见
- 版本已提交，但是在事务视图创建后提交的，不可见
- 版本已提交，但是在事务视图创建之前提交的，可见的

可重复读隔离级别的定义就是上述说的三种情况。



### 当前读

对于一条查询语句（不加锁时），上述规则是适用的；但是对于更新语句来说有一点不同，更新语句执行时是先读后写的，它只能读当前的值，这被称为当前读（current read）。

当前读是为了避免丢失其他已经提交事务的数据，除了update外，如果select语句加锁，也是当前读。

> select k from t where id = 1 lock in share mode;	//共享锁（S锁）
>
> select k from t where id = 1 for update;			// 排他锁（X锁）



读提交（RC）的事务隔离实现与可重复读（RR）实现逻辑差不多，不同的是：

- RR是在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图（视图数组）。
- RC是每个语句执行前都会重新算出一个新的视图。

