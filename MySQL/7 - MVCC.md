可重复读：一个事务启动时，能够看见所有已经提交的事务结果。但是之后事务执行期间，其他事务的更新对它都是不可见的。



transaction id，事务ID，在事务开始时向InnoDB的事务系统申请的，事务ID是顺序递增的。





数据版本的概念?

每行数据有多个版本。

每个事务更新时都会产生新的数据版本，并把transaction id赋值给这个新的数据版本，记为row trx_id。同时旧的数据版本会保留，并且在新的版本中能够有信息可以直接拿到旧的数据版本。

一行记录有多个版本（row），每个版本都有自己的row trx_id（对应的事务id）。



redo log：多版本只是一个概念，实际上不是物理存在的，一行记录的某个版本是通过redo log计算出来的。



注意：事务中只有更新操作会产生数据版本，而事务中的查询是选择合适的数据版本的过程。





数据有多个版本，那么查询时如何确定使用哪个版本呢?

当一个事务启动时，以它启动的时刻为准，如果一个数据版本是在我启动之前就生成的，就认可这个数据版本，否则不认可向上寻找之前的数据版本，直到该数据版本是可见的，或者是自己更新的数据版本。



实现上，InnoDB为每个事务构建了一个数组，用来保存这个事务启动瞬间，当前所有未提交的事务。

数组里面事务ID的最小值记为低水位，当前系统已经创建的事务ID的最大值加1记为高水位。这个视图数组和高水位，就组成了当前事务的一致性视图。



重点来了，数据版本的可见性规则，是基于数据版本的row trx_id和这个一致性视图（视图数组）的对比结果得到的。

这个视图数组把所有数据版本的rot trx_id分为三种情况：

- 低水位之前的数据版本是已经提交过的事务。

  因为低水位就是所有未提交事务的最小事务ID，所以低水位之前得数据版本是可见的。

- 高水位之后的数据版本是未开始的事务。

- 低水位与高水位之间的数据版本，是未提交的事务。

  这里分为俩种情况，如果数据版本的row trx_id是在数组中的，那么是不可见的；如果在视图数据外，那么是历史数据版本，是可见的。



当前事务自己更新的数据版本，为什么可以算作可见的。为什么可以算作归属于已经提交过的事务。







redo logo是不是记录了数据版本的日志？并且每个数据版本可以回退到上一个数据版本，得到上一个数据版本的值。











查询是否会产生新的数据版本？