大体来说，MySQL可以分为俩层，Server层和存储引擎层。

Server层包括连接器、查询缓存、分析器、优化器和执行器，这里包括了所有非存储引擎的功能，包括内置函数、视图和存储过程等。

而存储引擎层负责数据的存储和提取，它是插件式架构的，常见的存储引擎有InnoDB，Myisam，Memory等多个存储引擎，从5.5.5版本InnoDB成为默认存储引擎。



### 连接器

负责客户端连接的连理、查询权限、管理和维持连接。

```sql
mysql -h$ip -P$port -u$user -p
```

mysql是客户端工具，用来跟服务端建立连接，在完成经典的TCP连接后，连接器就会认证你的身份。

- 如果用户名和密码不对会返回一个"Access denied for user"的错误，然后客户端程序结束连接。
- 如果验证通过连接器会查询出你拥有的权限，之后这个连接里面的权限逻辑判断都依赖于此时查询出的权限



连接成功后没有后续动作，这个连接就处于空闲状态，可以使用 show processlist 命令查看连接信息，Commond列显示Sleep表示该连接处于空闲状态。

如果连接断开后太长时间没动静，连接器就会将它断开，这个时间由参数 wait_timeout控制，默认是8小时。对断开的连接发出请求将会受到错误，这时候就需要重连。



长连接和短连接

数据库的长连接是指连接成功后，如果客户端持续有请求则一直使用该连接。短连接则是每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。

建立连接的过程是很复杂的，因此建议使用长连接。但是全部使用长连接后，有些时候MySQL占用内存涨的很快，这是因为MySQL在执行过程中临时使用的内存是管理在当前连接对象里面的。这些资源只有在断开的时候是否，所以长时间积累下来可能会导致内存占用过大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。

可以考虑俩种方案避免这种问题：

- 定期断开长连接。使用一段时间，或者程序判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。
- 如果使用MySQL5.7以上的版本，可以在每次执行一个比较大的操作后，通过执行mysql_reset_connection来重新初始化连接资源。





### 查询缓存

连接建立后可以执行执行语句了，这时候MySQL逻辑会来查询缓存。

MySQL拿到一个查询请求后，会先到缓存中查看，之前是否直系过该查询。之前执行的语句以及结果可能会以key-value的形式存储在内存中。key是查询的语句，value是查询结果。如果有查询到结果则直接返回，如果没有会执行后续部分。



大多数情况建议关闭查询缓存，因为每次更新表数据时所有查询缓存都会被情况，缓存利用率是非常低的，可以设置参数query_cache_type成DEMAND，默认不使用SQL缓存。

注：在MySQL8.0中查询缓冲模块已经被删除了。



### 分析器

如果没有命中缓存，就要开始执行SQL查询语句了，MySQL会先对SQL语句做解析。

分析器会先做词法分析，判断出语句的字符串分别是什么，代表什么，例如：

```sql
select * from t where ID = 1;
```

MySQL会从输入的select关键字识别出来这是一条查询语句，它会把 t 识别为表名t，把字符串ID识别为列ID。识别后会做语法分析，判断SQL语句是否有语法错误，如果不对就会报错。



### 优化器

分析出语句要做什么了，在执行之前会先进行优化。

优化器是在表里面有多个索引时决定使用哪个索引；或者在一个语句有多表关联时决定各个表的连接顺序。总之优化器会根据自己的优化逻辑，选出它认为执行效率高的方案来执行语句。



### 执行器

在采用优化方案后，就是执行SQL语句的过程。

```sql
select * from T where ID = 1;
```

开始执行时会判断对表T是否有执行权限，如果没有会返回没有权限错误；如果有权限则打开表继续执行，执行器会根据表存储引擎的定义去使用这个引擎提供的接口。

例如上面这条SQL语句中表T的ID字段没有索引，它的执行流程是这样的：

- 调用Innodb引擎接口取这个表的第一行，判断ID是不是1，如果不是则跳过，如果是则存储在结果集中。
- 调用引擎接口取下一行，重复相同的逻辑判断，直到表的最后一行
- 执行器将上述遍历过程满足匹配条件的结果集返回给客户端。

在慢查询会有一个rows_examined字段，表示指向这个语句过程中扫面了多少行。这个值就是在执行器每次调用引擎接口获取数据行的时候累加的。

