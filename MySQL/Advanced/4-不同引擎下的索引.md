
## 不同引擎下的索引表现
### 1. MyISAM表的索引
对于myisam表的索引来说，主键索引和次索引都是指向磁盘上的物理行。

我们知道索引的查询是非常快的，这是因为MYSQL将索引字段的值码放好后形成索引树，查找某个字段的值时只需要去索引树中寻找某个叶子节点，叶子节点的指针直接指向磁盘上位置，即记录所在的位置。

所以说MyISAM表的索引都是指向磁盘上的物理行。

### 2. Innodb表的索引（聚簇索引）
Innodb主键索引树的叶子节点挂载了对应的记录，而次索引是指向主键索引的引用。

具体意思是innodb主键索引树下的叶子节点是直接聚集了对应的行记录数据，而次索引叶子节点的指针是直接指向主键索引的叶子节点，Innodb这种将主键索引的值和记录绑定在一起的结构被称做聚簇索引。

在MyISAM表中通过索引来查找记录是这样的，先查找字段值在索引中的位置，再通过索引的指针查找磁盘上的记录，无论主键索引还是次索引都是一样的查找方法。

而在Innodb表中通过主键索引来查找记录是先找到主键索引的位置，由于主键索引的叶子节点都是绑定了数据所以可以直接获取，

而Innodb表的次索引查找数据，先要查找字段值在次索引树中的位置，找到后再通过叶子节点的指针去查找主键索引树的叶子节点位置，再通过该叶子节点来获取数据，相对比MyISAM表的索引，Innodb表的次索引要多绕了一圈来获取数据。

## 叶子节点分裂效率对比
当表有新的记录的时候，索引树的叶子节点就会分裂，

对于MyISAM表，叶子节点存储的是物理行的地址，所以索引文件体积小，同时索引文件可以缓存在内存中，对于大批量的新增记录，MyISAM节点表的叶子分裂速度是很快的。

而对于Innodb表，大批量记录的创建对于聚簇索引的影响是比较大的，尤其当表的每行记录存储的内容比较多的时候，叶子节点的分裂效率会更低，这是因为叶子节点下存储了行记录，节点分裂的同时还需要移动数据。
同时无规律的主键索引在叶子分裂下的效率更低，因此建议选择递增的整形来作为主键索引的类型。

说明：在MyISAM中，索引文件是能被缓存到内存中的，因为MyISAM引擎的索引文件并没有绑定记录，只是一份索引树，相对来说文件较小，所以可以直接缓存。


分裂效率对比：myisam叶子分裂效率 > innodb有规律主键叶子分裂效率 > innodb无规律主键叶子分裂

**实验：小数据大批量记录插入对比**
**实验环境：虚拟机CPU个数1，2核心，mysql5.1**
```sql
create table split1(
	id int auto_increment primary key,
	name varchar(100)
)engine myisam charset utf8;

create table split2(
	id int auto_increment primary key,
	name varchar(100)
)engine innodb charset utf8;
```
```php

function microtime_float(){
	list($usec, $sec) = explode(' ', microtime());
	return $sec + $usec;
}

set_time_limit(0);
$conn = mysql_connect('192.168.0.125', 'root', '');

mysql_query('use test', $conn);
mysql_query('set names utf8', $conn);


// 测试不同引擎表的插入速度，在主键ID类型相同情况下
$start = microtime_float();
$str = 'abcdefghijklmnopqrstuvwxyz0123456789';
$temp = '';
for($i=0; $i < 20000; $i++){
	$temp .= substr($str, mt_rand(0, strlen($str) - 1), 1);
	$sql = "insert into split2 values(default, '" . $temp . "')";
	if(!mysql_query($sql)){
		echo mysql_error();
	}
}
$end = microtime_float();
echo ($end-$start);

# 实验结果：
# 第一次执行时间，1w记录
# myisam：4.6491141319275，innodb：6.9200351238251

# 第二次执行时间，2w记录
# m：17.634104013443，innodb：20.409944057465

# 实验结论：
# 在int类型主键下，各自插入2W条记录，每条记录100个字符 * 3字节大小
# 从中看出myisam在大量节点的分裂上，也就是大量新增数据上要比innodb相对快的多，秒级别的效率上，但是相差不是我期望的那么大，猜想可能是记录字节偏小，innodb能处理的过来。 

# 注：进行随机数运算拼接字符串的操作比较很耗费时间
```

**实验：大数据批量记录的插入**
```sql
create table split1(
	id int auto_increment primary key,
	name1 varchar(250),
	name2 varchar(250),
	name3 varchar(250),
	name4 varchar(250),
	name5 varchar(250)
)engine myisam charset utf8;

create table split2(
	id int auto_increment primary key,
	name1 varchar(250),
	name2 varchar(250),
	name3 varchar(250),
	name4 varchar(250),
	name5 varchar(250)
)engine innodb charset utf8;
```
```php
// 大数据批量记录插入
$str = 'abcdefghijklmnopqrstuvwxyz0123456789';
$str = str_shuffle($str) . str_shuffle($str) . str_shuffle($str);
$str .= $str;

$start = microtime_float();

for($i=1; $i<=10000; $i++){
	$sql = sprintf("insert into split2 values(%d, '%s', '%s', '%s', '%s', '%s')", $i, $str, $str, $str, $str, $str);
	$sql = s
	if(!mysql_query($sql)){
		echo $i, 'failure<br/>';
	}
}

$end = microtime_float();
echo 'result: ', $end - $start;

# MyISAM：1.962706089019		INNODB：5.2447230815887 
# MyISAM：1.906172990799		INNODB：4.4368550777435

# 随着行记录大小的增加，效率也就越低下
```

说明：随机主键就不实验了。。。

相关命令：
```sql
show variables like '%innodb%';	--查看和innodb相关的变量

show variables

show status;
# 显示mysql状态信息
# show命令可以跟like命令想结合查询自己想看的内容

Innodb_page_size
Innodb_page_writen
# innodb引擎分裂页数大小
```