## 树简介

### 1. B-tree索引
b-tree索引从大的方向都是用平衡树实现的，各引擎的实现上略有不同，例如NDB引擎使用的是T-tree。

myisam、innodb默认用B-tree索引，b-tree是一种排好序的快速查找的数据结构，这里要注意的是排好序的。

### 2. hash索引
memory引擎使用的是hash索引，hash的时间复杂度为O（1），指的是一次查找就能定点数据。

hash索引的缺点：
- hash函数的计算结果是随机的，如果以hash生成的结果作为主键来存储数据，那么每条记录都是随机在磁盘上存储的。
- 无法对范围查询进行优化。
- 无法利用左前缀进行匹配，例如name字段的值是zhangsan，name是B-tree索引实现的，在匹配zhang和zhangsa这俩个值，该索引都会生效，而使用hash索引的话，hash（zhang）和hash（zhangsa）这俩者是随机的。
- 排序也无法使用hash索引来进行优化。


## 联合索引
俩个或俩个以上的列的索引叫做联合索引，也叫做复合索引，例如：
> key(id,price)


### 1. 联合索引生效原理
联合索引是由多个字段组成的索引，索引之间有一个左前缀匹配规则，

即先使用第一个字段的索引进行匹配，在此基础上再用第二个字段的索引进行匹配，以此类推，中间如果有一个字段的索引没有匹配到，后面字段的索引都不会利用到的。

案例对比：
```sql
key(id), key(name)
# 分别建立id、name俩个索引

select * from user where id=5 and name='z'
# mysql在执行这条语句的时候，只会选择一个字段的索引来进行匹配
# 在匹配到的数据上再做另外一个字段条件的判断，但是这里是不会利用上索引的


key(a,b,c)
# 创建一个联合索引

select * from demo where a=3 and b=5 and c=10
# 这条语句在执行的时候，满足左前缀匹配规则，3个索引都用到了
# 首先在a索引上匹配到的记录也是在b字段的基础上做了索引排序的

# 再次根据b索引匹配到的记录也是跟c字段做了索引优化的
# 最后a、b字段匹配到的记录也是在c字段上做了索引优化

# 所以这3个索引都被使用到了
```

### 2. 左前缀匹配规则
左前缀匹配规则是匹配的时候必须按照联合索引的字段从左到右依次进行比较，如果中间出现断层，断层后面的字段索引是不会生效的。

左前缀的说明：
```sql
key(a,b,c)

where b=7 and c=3
# 这个查询条件的联合索引是不会生效的

where a=4 and c=3
# 该查询条件a索引生效了，其余俩个字段不会生效
```

key_len的分析：
```sql
# 主要测试不同类型的字段的索引长度
create table test_keylen(
	name char(1) not null,
	age int not null,
	sex tinyint not null,
	key(name),
	key(age),
	key(sex)
)engine=myisam charset=utf8;

insert into test_keylen values('ab', 20, 1);
# 插入多条测试数据

explain select * from test_keylen where name='c'\G
# 解析name索引的key_len长度是3个字节，因为字符集是UTF-8，用3个字节来存储字符

alter table test_keylen change name name char(1)
# 将字段属性改为允许null
# 再次解析的长度是4，这意味着null要特殊字符来标记自己，所以会占用多1个字节

explain select * from test_keylen where age=1\G
# age是int，长度为4个字节，ken_len长度是4个字节

explain select * from test_keylen where sex=1\G
# sex是tinyint，1个字节，所以ken_len的长度是1个字节
```

联合索引的生效判断：
```sql

create table t_nums(
	a int not null default 1,
	b int not null default 2,
	c int not null default 3,
	d int not null default 4,
	key(a,b,c,d)
)engine=myisam charset=utf8;

insert into t_nums values(1,2,3,4);
insert into t_nums values(1,2,3,4);
insert into t_nums values(1,2,3,4);
insert into t_nums values(1,2,3,4);
insert into t_nums values(1,2,3,4);
insert into t_nums values(1,2,3,4);

key(a,b,c,d)
# 一个有a、b、c、d字段组成的索引

explain select * from t_nums where a=3\G;
# 生效

where a=3 and b=5 	
# 生效，使用到a、b俩列

where a=3 and b=5 and c>4	
# 生效，使用到abc，key_len长度是12

where b=3 | where c=5		
# 不生效，a字段索引没被匹配到

where a=3 and c=4
# a字段索引生效

where a=3 and b>10 and c=7
# a与b字段索引生效，c无法生效，因为b索引是范围性的条件，范围性是无法确定一个值的

where a=3 and b like xxx and c=7	
# 同上
```

### 3. 排序与索引
order by asc/desc
对于排序，索引是可以发挥作用的，无论是升序还是倒叙，因为索引的记录本身就是有序的。

filesort，文件排序，并不是说通过磁盘文件排序，而是告知你mysql使用了filesort，在使用order by关键字的时候，如果查询的内容并没有利用到索引，那么mysql可能会进行filesort操作。

### 4. 分组与索引
group by的工作原理
1. 创建内存临时表，根据分组字段一边排序一边将记录有序存放到临时表中
2. 最后在临时表中进行聚合或者是其他操作

因为有使用临时表排序，所以group by分组索引也是能发挥作用的。

案例测试：
```sql
create table shop(
	id int primary key auto_increment,
	type_id tinyint not null,
	price int not null,
	key(type_id)
)engine=myisam charset=utf8;

insert into shop values(default, 1, 100);
insert into shop values(default, 1, 80);
insert into shop values(default, 2, 90);
insert into shop values(default, 3, 80);

explain select * from shop group by type_id
# using temporary; using filesort

# 通过explain命令，可以看到mysql使用到临时表（temporary）
# 临时表的作用只是为了得到一个排好序的表记录
# 而索引的记录是已经排序好的，所以索引在group by的时候能发生作用。

alter table shop add index(type_id);
# 添加一个索引
# 多插入一些数据进行测试

explain select * from shop group by type_id
# 再次分析，发现仍然使用temporary、filesort，
# 这是因为查询的是整张表，
# mysql认为查询整张表会比使用索引随机查询记录效率高，
# 所以使用temporary和filesort。

explain 
	select * from shop where type_id > 1 group by type_id
# 增加索引字段查询条件，让mysql使用索引
# 再次分析发现没有使用temporary和filesort了。
```

## 联合索引测试

假设某个表有一个联合索引（c1、c2、c3、c4），下面哪条语句只能使用联合索引的c1、c2、c3部分。
```sql
create table t1(
	c1 char(1) not null default '',
	c2 char(1) not null default '',
	c3 char(1) not null default '',
	c4 char(1) not null default '',
	c5 char(1) not null default '',
	key(c1,c2,c3,c4)
)engine=myisam charset=utf8;

insert into t1 values('a', 'b', 'c', 'd', 'e');
insert into t1 values('A', 'b', 'E', 'd', 'e');
insert into t1 values('B', 'b', 'c', 'd', 'e');
insert into t1 values('B', 'b', 'c', 'a', 'e');
insert into t1 values('B', 'b', 'c', 'a', 'e');


where c1 = 'x' and c2 = 'x' and c4 > 'a' and c3 = 'x'
# 由于所有字段都是以and来进行判断，mysql会进行优化，所以所有字段的索引都会生效的
# 通过explain分析的key_length字节长度是12，说明4个字段发生作用

where c1 = 'x' and c2 = 'x' and c4 = 'x' order by c3
# order by c3，c3本身也是索引，在c1、c2查找到的数据上沿着索引c3升序来进行查找，
# 数据本身就是有序的，最终mysql在有序的数据上查找c4=x的记录。
# key_length字节长度=6，同时没有filesort
# 注：c3无论升序倒叙都会生效

where c1 = 'x' and c5 = 'x' order by c2,c3
# c1、c2、c3生效

where c1 = 'x' and c2 = 'x' and c5 = 'x' order by c3,c2
# c1、c2、c3生效，因为c2是一个固定值，相当于order by c3


where c1 = 'x' and c4 = 'x' group by c2,c3
# 因为查询条件是and，所以mysql会进行优化
# 以c1作为索引查询的数据，在c2、c3索引基础上分组，最后查询c4

# c2、c3因为分组有利用到索引，c4我认为没利用上，因为分组后查询出来的数据跟c4的索引就无关了。
# 如果and改成or，就无法利用到索引了

where c1 = 'x' and c4 = 'x' group by c3,c2
# 只有c1索引生效，group by是先对c3分组，再对c2分组，所以无效。
```