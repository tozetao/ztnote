## 索引覆盖
我们知道索引是一种数据结构，通过索引去查找字段的值是非常快的，但是在去磁盘中获取数据这个过程是比较慢的。

这里有个回行的概念，指的是由索引到磁盘中取数据的过程。

### 1. 什么是索引覆盖
如果要查找字段的值本身就在索引中，这种情况就叫做索引覆盖，
索引覆盖的SQL语句执行效率是非常高的，因为MYSQL不需要去回行获取数据。

例如：
```sql
key(username)
# username字段是key

select username where username = 'zhangsan'
# 这条SQL语句就不需要回行获取磁盘上的记录。

select username,age,address from user where username = 'zhangsan'
# 而这条SQL语句则需要回行获取数据了，因为是获取多个字段的值，查询条件只有username一个索引
```

### 2. 实验
**实验1：**
```sql
# 建立一个有1000W条数据的表，测试索引覆盖和非索引覆盖下的查询效率。
create table conver_index(
	id int not null,
	name char(10) not null,
	age int not null
)engine=myisam charset utf8;

alter table conver_index add index(id); 

select id from conver_index where id = 990000;
select id,name,age from conver_index where id = 990000;

# 我用一张100W表的记录进行测试，效率确实高一些，可能是数据量太小了，所以体现不出来。 
```

### 3. 综合问题实践
```sql
create table pro_1(
	id varchar(64) primary key,
	var int,
	key(id,var)
);
```
概述：这个表中，id是主键，id、var是联合索引，同时还有几个比较长的字段

问题：select id from t2 order by id和select id from t2 order by id,var俩条SQL语句，第一条SQL语句的执行特别慢，而第二条特别快，分析原因。

分析：
如果这个表是myisam引擎，2条SQL语句应该不会有性能差异，因为id和id,var都是索引，
同时SQL语句使用到了索引覆盖不需要回行，mysql在执行的时候会加载对应的索引文件，order by排序是直接在索引文件的数据上进行，初步判断使用的引擎应该是innodb。

如果是innodb引擎，在id主键上做排序，由于主键索引和行记录是绑定在一起的，虽然使用了索引覆盖，但是主键索引文件过大，MYSQL在这个基础上做数据的排序效率就低下了，

而第2条SQL语句是使用id,var联合索引文件来进行排序，id,var的联合索引文件并没有绑定数据，所以排序速度就上来了。

测试1：上述问题
```sql
create table covert_m(
	id char(24) primary key,
	ver int not null default 0,
	str1 varchar(500),
	str2 varchar(500),
	str3 varchar(500)
)engine myisam charset utf8;

create table covert_i(
	id char(24) primary key,
	ver int not null default 0,
	str1 varchar(500),
	str2 varchar(500),
	str3 varchar(500)
)engine innodb charset utf8;
```

```php
for($i=1; $i<=10000; $i++){
	$sql = sprintf("insert into covert_i values('%s', %d, '%s', '%s', '%s')", 'hello' . $i, $i, $str, $str, $str);

	if(!mysql_query($sql)){
		echo $i, 'failure<br/>';
	}
}
```

实验结果：
```sql
# innodb表的测试数据

alter table covert_i add index(id,ver);
# 添加联合索引

select id from covert_i order by id;
# 0.06秒
select id from covert_i order by id,ver;
# 0.02秒
select id,ver,str1 from covert_i order by id,ver;
# 0.1秒

# myisam表的测试数据
alter table covert_m add index(id,ver);
# 添加联合索引
select id from covert_m order by id;
# 0.2
select id from covert_m order by id,ver;
# 0.2
select id,ver,str1 from covert_m order by id,ver;
# 0.1
```
测试结果基本验证了我们上述的分析。

**测试2**
测试innodb引擎覆盖索引的效率，
```sql
alter table covert_i add index(ver); 
# 添加ver索引

select id from covert_i where id = 'hello900000';
select * from covert_i where id = 'hello900000';
# 测试主键索引回行和非回行的效率
# 结论：看不出差别


select ver from covert_i where ver=900000;
select * from covert_i where ver=900000;
# 测试次索引回行和非回行效率
# 结论：总体上覆盖索引的SQL语句效率高一点

```

### 一些问题
可能是我测试数据量过小，总记录才100W，在测试innodb引擎覆盖索引和非覆盖索引的数据不是很准备，回头有空再测试。


另外字符串类型来做主键，效率太低下了，尤其是在innodb引擎的情况下做主键，效率超低低下。