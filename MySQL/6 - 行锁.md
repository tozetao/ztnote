### 行锁

行锁是针对数据表中行记录的锁，行锁由存储引擎实现，与MySQL Server层无关。



### 俩阶段锁

在一个事务里面，分为加锁（lock）阶段和解锁（unlock）阶段，这被称为俩阶段锁。

行锁是在需要的时候才加上的，例如在事务中更新ID=1记录的时才进行加锁，但并不是执行完毕后就立即释放，而是要等到事务结束时才释放。

- 用处

  俩阶段锁是为了保证事务的隔离性，即多个事务在并发的情况下等同于串行的执行。

由于俩阶段锁的特性，如果在事务中有多个SQL语句时，要把最可能造成锁冲突，最影响并发度的锁放到事务最后面，以提高事务的并发度。

比如有个影院系统的业务逻辑，顾客A要在影院B购买票，那么涉及的业务操作有：

1. 扣除顾客A账户的余额

2. 增加影院B账户的余额

3. 插入一条日志记录

由于买票的不止只有顾客A，也会有很多人买票要向影院B的账户转账，因此操作2的锁冲突最高，如果将操作2放到最后一步执行，会降低其他事务锁冲突等待的时间，这样并发度就相对提高了。





### 死锁

在并发中，不同线程出现循环资源依赖，涉及的线程都在等待对方释放锁资源时，这种情况就是死锁。

|                  线程A                  |             线程B              |
| :-------------------------------------: | :----------------------------: |
| begin; update t set k=k+1 where id = 1; |             begin;             |
|                                         | update set k=k+1 where id = 2; |
|     update set k=k+1 where id = 2;      |                                |
|                                         | update set k=k+1 where id = 1; |

在上面俩个事务中，事务A在等待事务B释放ID=2的锁资源，因此事务A会阻塞。而事务B执行时又在等待事务A释放ID=1的锁资源，它们之间形成一个互相依赖的关系，进入死锁状态。



针对死锁，MySQL提供了俩种策略：

- 设置锁超时时间

  innodb_lock_wait_timeout，通过该参数来设置锁等待的时间，如果发生超时将会释放掉锁。

- 发起死锁检测

  MySQL会检测事务中是否出现死锁，如果有的话会主动回滚死锁链条中的某一个事务。

  innodb_deadlock_detect，该参数设置是否检测死锁，默认值为on

我们一般采用主动进行死锁检测的策略，但是该策略的问题在于性能损耗比较高。每当一个事务被锁的时候就需要判断它锁住的资源是否被其他线程锁住，同时检查是否出现了循环等待。

比如上面的例子中，事务B有id=1、id=2的锁，在对id=2加锁时它就进行检查，发现事务A也在对id=2加锁，同时检测到事务A拥有id=1的锁，倆者出现了循环等待。

死锁的检测时间复杂度是比较高的，每个新来的线程在被阻塞时，都会检测自身的加入是否会带来死锁，这是一个O(n^2)的时间复杂度。即使检测的结果没有发生死锁，这期间也会消耗大量的CPU资源。



优化方向

控制并发度，在对同一行记录更新时进行排队处理，比如同时只有100个线程在进行更新，分批处理。