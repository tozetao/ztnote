<?php
/*
1. 锁
	协调多个进程或线程 并发 访问某一资源的控制，锁主要用于保证数据并发访问的一致性，有效性。
	锁冲突也是影响数据库并发访问性能的一个重要因素。

2. mysql锁机制
	mysql的锁机制比较简单，由存储引擎决定，不同的存储引擎支持不同的锁机制。
	比如myisam和memory存储引擎采用的是表锁(table-level-locking)，innodb存储引擎支持行级锁(row-level-locking)，也支持表级锁。

	表级锁：开销小，加锁快；不会出现死锁，锁定粒度大，发生锁冲突的概率最低，并发度最小。

	行级锁：开销大，加锁慢；会出现死锁，锁定粒度最小，发生锁冲突的概率最高，并发最高。

	页面锁：开销和加锁时间介于表级锁和行级锁之间，会出现死锁，锁定粒度介于表锁和行锁之间，并发度一般。

3. 表锁
	在mysql中，myisam存储引擎只支持表锁。
	
	3.1 查询表级锁争用情况
		show status like 'table%';

		Table_locks_immediate：表示立即释放的表锁数。
		Table_locks_waites：表示需要等待的表锁数，如果该参数的值较高，则说明存在着较严重的表级锁争用情况。
	
	3.2 表锁的锁模式
		mysql的表级锁有俩种模式：表共享读锁(Table Read Lock)和表独占写锁(Table Write Lock)。

		读锁模式：对myisam表的读操作，不会阻塞其他用户对同一表的读操作，但是会阻塞对同一表的写操作，读锁模式下只能对加锁的表进行查询操作。
		
		写锁模式：会阻塞其他用户对同一表的读和写操作。

	3.3 表锁的加锁方式
		默认的，在对myisam引擎的表执行select语句前，会自动给涉及的所有表加读锁，在执行更新操作(update、delete、insert)前，会自动给涉及的表加写锁，这个过程由mysql自动进行的，并不需要用户干预。

	3.4 lock、unlock命令
		lock tables tb_name read
		lock tables tb_name write

		上述俩条命令是显式加锁，在使用lock tables给表显示加锁的时候，只能访问显示加锁的表，不能访问未加锁的表，同时如果加的是读锁，则只能进行读取操作，而不能执行更新操作。

		在自动加锁的情况下也是如此的，myisam总是一次性获取SQL语句的全部锁，这也是myisam不会出现死锁的原因。

		注：当一条sql语句中有表的别名时，也需要对别名进行加锁，否则会报错。

	3.5 并发插入
		myisam表的读写操作是串行的，你可以理解成读操作和写操作是以一个队列的方式排列存储起来的，在一定情况下myisam表也支持查询操作和插入操作并发进行。

		concurrent_insert：myisam引擎专有，专门控制并发查询与插入的行为，值是0/1/2，0是不允许并发插入，1是无数据空洞则允许并发插入，2是无论是否有数据空洞，都允许在表尾插入记录，默认值是1。

		example：
			lock tables t1 read local

			“local”选项，其作用就是在满足MyISAM表并发插入条件的情况下，允许其他用户在表尾并发插入记录。

			通过这种方式加表读锁，可以发现其他用户是可以插入数据的。	只有读锁才能增加local选项，写锁是没有的。

	3.6 myisam表锁的调度
		myisam引擎的读锁和写锁是互斥的，读写操作是串行的。
		
		如果一个进程请求某个myisam表的读锁，同时另外一个进程也请求同一个表的写锁(注意是同时)，这种情况下写进程会优先获取锁，不仅如此在锁请求队列中，即使读请求先到锁等待队列，写请求后到，写请求会插入到读请求前面。

		这种现象是因为mysql认为写操作比读操作重要，这一点也造成myisam不太适合同时有大量更新操作和查询操作的应用。

		因为大量的更新会造成查询操作很难获得读锁，从而可能永远阻塞，当然这种情况是可以优化的。

		a. 指定启动参数low-priority-updates，让myisam引擎给予读请求以优先的权利
		b. 执行命令set low_priority_updates=1，使该连接发出的更新请求优先级最低
		c. 通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。

		总结：
			读锁和写锁的互斥、读操作和写操作的串行。
			因为读写操作是串行的，且写操作比读操作获取锁的优先级高，所以大量的更新操作容易导致查询操作很难获得读锁，从而阻塞。
		
		解决：
			提交读操作的优先级，降低写操作的优先级，同时进行并发查询插入的优化。
		
		注意：
			这种方案要避免长时间查询的sql语句，因为长时间的查询操作会使写进程"饿死"，建议不要总想着一条select语句来解决问题，看似巧妙的sql语句，往往比较复杂，这种时候可以拆分语句，使每条语句的执行时间降低到最低，从而减少所冲突。

4. 行级锁
	在mysql中，innodb引擎实现了事务，并采用了行级锁。

	4.1 什么是事务
		在mysql的innodb引擎中，事务是默认开启的，这意味着每个sql语句的执行都会被当做一个单独的事务进行处理。

	4.2 并发事务带来的问题

	4.3 行级锁的模式
		共享锁(S)
			允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
			一个事务获得一行数据的共享锁，另外一个事务也可以获取这行数据的共享锁。

		排他锁(X)
			允许获得排他锁的事务更新数据，阻止其他事务获得相同数据集的共享读锁和排他写锁。

		意向共享锁(IS)
			事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。

		意向排他锁（IX）
			事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

		如果一个事务请求的锁模式与当前的锁兼容，innodb就将请求的锁授予该事务，反之如果俩者不兼容，该事务就要等待锁释放。

		跟myisam的读锁和写锁互斥是不同的，innodb是对比锁模式的兼容问题，来决定事务是需要加锁，还是需要等待锁释放。

		在innodb中，意向锁由innodb引擎负责，需要用户干预。为了允许行锁和表锁共存，innodb还有俩种内部使用的意向锁，这俩种都是表锁。
	
	4.4 加锁方式
		默认的，在innodb引擎中，每条sql语句都是一个单独事务的执行。

		对于select语句，innodb不会加任何锁。
		对于update、delete和insert语句，innodb会自动给涉及的数据集加排他锁（X）。

	4.5 显式加锁
		事务可以显示通过以下方式来显式加共享锁和排他锁。
		共享锁(I)：
			select * from tb_name where ... lock in share mode
			主要用于需要数据依存关系时来确定某行记录是否存在，并确保没有人对这个记录进行update和delete操作，但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁。

			对于锁定行记录后需要进行更新操作的应用，应该使用select...for update方式获得排他锁。

			经过测试，当前事务对一条记录加共享锁的时候，其他事务是不能对这条记录更新和删除的，另外其他事务也不能对这条记录加排他锁，必须等当前事务执行完毕并释放锁。

		排他锁(X)
			select * from tb_name where ... for update

			使用排他锁加锁的时候，其他客户仍然可以读取该行数据。
			但是无法再次进行加锁(无论是共享锁还是排他锁)，加排他锁的记录也无法被更新和删除，必须等待加锁用户进行事务提交再释放锁才能加锁。

	4.6 innodb行锁的实现方式
		innodb行锁是通过给索引上的索引项加锁来实现的，这种加锁方式意味着，只有通过索引条件检索数据，innodb才使用行级锁，否则使用表级锁。

		注：在实际应用中一定要注意这一点，否则会导致大量的锁冲突，从而影响性能。

	4.7 索引的锁冲突
		使用相同的索引字段来作为查询条件，是会出现锁冲突的，
		
		例如id和name作为查询条件，id是索引
		where id = 1 and name = 'a'
		where id = 1 and name = 'b'
		
		上述的查询条件，会发生锁冲突，第二个SQL语句会阻塞，这个前提条件是有利用到索引字段id，如果并没有索引1的记录，那么不会出现冲突，因为并没有利用到索引。

	4.8 不同索引的锁冲突
		当表有多个索引的时候，不同的事务锁定不同的数据行，无论是主键、唯一、普通索引，innodb都会使用行锁对数据加锁。

		也就是说对某条数据加锁后，其他客户端只要有通过索引查询到这条记录，要对这条记录加锁，那么都会阻塞。

		例如id、name俩个字段都是索引，
		where id=1;	
		where name = 'a';
		
		上述的俩个条件如果查询的记录是相同的，那么也会阻塞。

		注：在检查锁冲突的时候，别忘记分析sql语句是否有使用索引。
		show status like 'innodb_row_lock%'

	4.6 间隙锁(next-key锁)
		当我们用范围条件来检索数据的时候，并请求共享锁和排他锁，innodb不仅会给查询到的记录加锁，对于键值在条件范围内，但不存在的记录，innodb也会对这个不存在的记录加锁。

		举例来说，假设emp表有101条记录，select * from emp where id>100 for update，这条语句不仅会对id=101这条记录加锁，也会对id大于101不存在的记录加锁，innodb使用间隙的目的是为了防止幻读。

		如果不使用间隙锁，其他事务插入了id大于100的任何记录，那么本事务再执行上述语句就会发生幻读。

		innodb的这种锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待，实际开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。

		需要特殊说明的是，如果使用相等条件请求一个不存在的记录加锁，innodb也会使用间隙锁。

		注：间隙锁会导致并发插入性能问题。
	
	4.7 恢复和复制的需要，
	
	4.8 什么时候使用表锁
		对于innodb表，绝大情况下都应该使用行级锁，因为事务和行锁是我们选择innodb表的理由，当然个别特殊事务下，也可以考虑使用表级锁。

		第一种情况是：事务需要更新大部分或全部数据，表又比较大，不仅这个事务执行效率低，而且会造成其他事务等待和锁冲突问题，这种情况下可以考虑使用表锁来提交效率。

		第二种情况是：事务设计多个表，比较复杂，很可能引起死锁，造成大量事务回滚，这种情况下可以考虑一次性锁定事务设计的表，从而避免死锁、减少数据库回滚带来的开销。

		当然应用中这俩种情况不能出现太多，否则该考虑使用myisam引擎。

	4.9 innodb使用表锁的要点
		a.
			只有autocommit=0、innodb_table_locks=1(默认值)时，才能加表级锁成功。
			因为表锁是由MySQLServer负责的，这俩个值设置正确innodb引擎才能识别MySQLServer加的表锁，否则innodb无法检测和处理表级的死锁。

		b.
			在用lock table对innodb表加锁要注意，要将autocommit设置为0，否则mysql不会给表加锁，事务结束前，不要用unlock tables释放锁资源，因为unlock tables会隐式的提交事务，而commit或rollback并不能释放lock tables加的表级锁，必须unlock tables才能释放锁资源。

		正确语句如下：
			set autocommit=0;
			lock tables t1 write, t2 read, ...;
			[do something]
			commit;
			unlock tables;
			
5. 死锁
	myisam表锁是deadlock free的，这是因为myisam总是一次性获取所有表的锁，要么全部满足，要么等待，因此不会出现死锁。
	但是在innodb中，除单个sql组成的事务外，锁是逐步获得的，这就决定innodb中发生死锁的可能性很大。

	5.1 案例
		session1：
			select * from t1 where id = 1 for update;	//1
			select * from t3 where id = 3 for update;	//3
		session2：
			select * from t3 where id = 3 for update;	//2
			select * from t1 where id = 1 for update;	//4
		数字代表执行步骤，

		这种循环锁等待是最典型的死锁，mysql能自动检测出来，但在涉及外部锁和表锁的时候，mysql是检测不出来的。

		对于死锁，mysql会会释放锁并回退，让另外一个事务获得锁，以便继续完成事务。

		innodb_lock_wait_timeout：锁等待超时时间，解决高并发下，大量事务无法立即获得所需的锁而挂起，占用大量计算机资源，所以需要设置锁等待超时时间。

	5.2 死锁的产生
		一般死锁的产生，都是应用设计问题，通过业务流程、数据库对象设计、事务大小和访问数据库的sql语句，绝大部分的死锁是可以避免的。

	在应用中，如果不同的程序会并发存取存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会。

	事务更新数据的时候，应该直接申请足够权限的锁，即排他锁，而不应该先申请共享锁，更新时再申请排他锁，因为当用户申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突。



作业：
	set autocommit，设置后，当前客户端的值临时变为所设置的值。

	关于innodb的锁机制
		共享锁和排他锁是互斥的
		在innodb表中，如果无显式声明，sql语句是以一个独立的事务进行的。

		select语句不加任何锁
		update、delete、insert语句会自动加排他锁

	关于myisam的锁机制
		myisam的读写操作是串行的，
		myisam的读锁和写锁是互斥的，

		select语句加读锁
		update、delete、insert语句加写锁

测试
	1. 在myisam插入大量数据，看能否在其他客户端读取数据
	2. 试试用锁机制修正解锁屏幕添加好友的bug


什么叫做数据空洞
		3.6 myisam表的数据空洞
		例如现在有一张myisam表，有一个主键id，有一个name字段。
		我们现在插入4条数据，然后删除表中的一条数据，那么这条数据就形成了一个空洞，无论这条数据是第一条还是最后一条，

		在下次插入数据的时候，mysql会检查空洞是否能容纳新的数据，可以的话直接在该空洞的位置插入数据，否则会把数据保存在数据文件的结尾。

		这是在myisam表的情况。
		更新数据并不会产生空洞。

		根据myisam存储引擎的插入特性，我们可以将concurrent_insert系统变量设置为2总是允许并发插入，来解决查询和插入的锁争用。

		通过定期在系统空闲时段执行 OPTIMIZE TABLE语句来整理空间碎片，收回因删除记录而产生的中间空洞。

不知道共享锁是干嘛用的。


因为innodb的锁粒度

	innodb引擎的表读写操作不是并行的。
	一个事务读取数据集，其他事务不能更改，但是可以读取，也能读写当前事务未操作的数据。
	
	一个事务在更新数据集，其他事务可以读取，但是不能更改，其他事务可以读取其他的数据集。