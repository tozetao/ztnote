
8. 视图
	view，是SQL语句的查询结果，又被称为虚拟表，查询一个view，也就是执行了这条SQL语句。
	view无法更新和删除，创建一个视图，相应的数据库文件夹中会产生一个表结构文件。
	
	语法：
		create view view_name as select ...(查询语句)
	
	4.1 单表视图
		create view stu_v1 as select s_id,s_name,height from pro_student;
		#将select语法的结果集作为一个view。

	4.2 多表视图
		select语句是从多张表中得到的数据
		PS：多表视图中不允许存在同名字段，有同名报错。

	show tables;	
	#能查看到视图，所以说也是一个表结构文件。
	desc view_name	
	#查看视图结构
	show create table view_name		
	#查看view创建语句
	
	select * from vew_name	
	#查看视图数据
	通过视图所看到的数据，都不是视图本身保存的数据，而是通过执行视图的select语句所即时查询到的数据。

	4.3 修改视图
		修改视图就是修改视图的select语句

		语法：alter view view_name as select...
		
		example：
			alter view stu_v1 as select u_id,u_name,u_pwd from student;

	4.4 删除视图
		drop view vew_name
		删除视图，系统会删除视图，同时删除视图结构文件。

	2.3 作用
		权限控制，某几个列让用户查询，其他列不允许。要将权限精确控制到列，就需要用到视图。
		简化复杂的查询。

	2.4 view的操作
		视图中的每条记录(中的列)是与物理表一一对应的，对view的更改会影响到物理表。
		如果视图中的记录是物理表中多行记录计算的结果，因为无法映射，所以view无法更改，会报错。
		example：
			create view vdemo as select avg(price) as avgprice,count(*) as num from goods group by cat_id;
			#这个视图是平均价格，分类数量的统计，无法映射，所以对视图无法更改。
		
		a. 单表视图数据操作
			insert、update、delete、select，可以执行。

			基表结构：T：a not null，b，c not null，d
			视图1：select a，b，c from T
				插入数据的时候，因为视图没有d字段，而且d字段允许null，所以插入成功。
			视图2：select a，b，d from T
				插入数据的时候，因为视图没有c字段，而c字段不允许null，所以会插入失败。
			
			视图的插入成功与否，全看视图中的字段。
			如果视图中的字段包含了基表中全部不为null的字段，那么插入成功，否则插入失败。(前提：该实体是单表视图)
			PS：主键如果有自增，那么可以不用在视图中，就插入成功。

		b. 多表视图
			可以执行select、update。
			
			视图权限：
				所有表或者视图的权限(增删改查操作)，我们可以通过用户权限来限定，
				一般情况下，视图的操作权限，都只有查看。

		c.whit check option
			在通过视图进行更新语句的时候，with check option会进行结果判断，修改后的记录要能够被视图所查询到。
			如果不能被视图查询到，那么更新失败。

			create view 视图名 as
				select 语句 where 字段=值
				--当字段=某个值的时候的视图表。
				
				--所以如果值被修改了，那也就看不到这个视图了
				--该视图只能获取2班的学生
				create view stu_v3 as select * from pro_student where c_id=2;

				--该视图只能获取3班的学生，要求在更新的时候，对c_id进行验证
				create view stu_v4 
					as select * from pro_student where c_id=3 with check option;

	2.5 视图算法
		当视图被查询的时候，系统会根据一定的解释方式来对SQL语句进行处理操作。
		a. merge
			这种算法，只是单纯的存储创建view的select语句。当我们查询视图的时候，就会将建视图的select语句跟查视图的SQL语句合并来进行查询。
			example：
				create view vdemo as select u_id,u_name,u_age from user;
				
				需求：从视图中查询年纪最大的三人
				select * from vdemo order by u_age desc limit 3;
				
				mysql合并：select u_id,u_name,u_age from user order by u_age desc limit 3;

		b. temptable
			临时表，将视图先执行，把结果存放成一张临时表，然后外部的select语句对临时数据进行操作

		c. undefined
				未定义，默认。系统会根据自己的判断来确定具体使用哪种算法：merge，temptable，大部分的情况下，系统会使用merge，因为merge的效率比temptable高
		
		b. 指定视图算法
			create algorithm=temptable view 视图名字 as select语句
			--创建一个以年龄降序的视图
			create view stu_desc_age as select * from pro_student order by s_age desc;
			--查询视图中每个班级最大的学生
			select * from stu_desc_age group by c_id;
			--上面的语句会出问题，因为视图有算法的。


			--上面的语句等价于下面这条语句
			select * from pro_student group by c_id order by age;

			--从语法上等价，但是实际解析上不一样，这个是temp算法
			select * from (select * from pro_student order by age) as s group by c_id;
			--这条SQL语句是先对子查询操作，是主语据对数据源的操作。外部是对子查询结果的一个操作。
			--而视图这俩条语句的执行结果不一样，因为视图是merge算法，外部语句和视图语句会合并
			
			--merge算法过程
			--合并拿到语句
			--select * from (select * from pro_student order by s_age desc) as s group by c_id
			--算法优化，同一个表查询，所以优化成这样了，但是有语法问题
			--select * from pro_student order by s_age desc group by c_id
			--继续优化
			--select * from pro_student group by c_id order by s_age desc 
			--所以查询结果就跟我们的不一样了。



10. 触发器
	进行开发的时候，有时候会碰到表中的某些数据改变，希望同时引起其他相关数据改变的需求，触发器就能满足这样的需求。

	触发器是一类特殊的事务，可以监视某种数据操作(insert/update/delete)，并触发相关操作(insert/update/delete)
	SQL 1能触发SQL N

	语法：
		delimiter 临时符号
		create trigger trigger_name time event_type on table_name for each row
		begin
			触发器的内容，可以是各种SQL语句。
		end
		临时符号
		delimiter; --改回语句结束符
	说明：
		trigger_name：触发器的名字
		time：触发时间
		event_type：触发的事件类型
		table_name：表名

		触发器的内容都是以行为单位，每行都有一个结束符号，结束符号是分号，所以在创建触发器之前，都需要临时的修改语句符号：delimiter 临时符号

		同一种触发器(时间和类型)只能在表中有一个。一张表最多有6个触发器。

	10.1 监视地点
		即table，你的触发器要监视哪种表的数据改变

	10.2 监视事件
		即监视表是发生了哪种事件，insert、update、delete。

	10.3 触发时间
		after、before
		一旦监视某张表的某个事件发生了，你在发生前或发生后触发事件

	10.4 触发事件
		insert、update、delete
		触发哪种事件类型
	
	example：
		需求：
			有一张商品表，里面有商品的数量（库存），还有一张订单表。当订单生成之后，商品对应的库存应该减少。
		分析：
			监视谁：order
			监视事件：insert
			触发时间：after
			触发事件：update
			
		--创建一张商品表
		create table goods(
			id int not null primary key auto_increment,
			name varchar(10) not null,
			inv int unsigned default 0,
			price decimal(7,2) default 1.0
		);
		--创建一张订单表
		create table `order`(
			id int primary key auto_increment,
			order_num char(10) not null,
			g_id int not null,	--商品ID，不同商品本身
			g_num int not null --购买商品的数量
		);
		insert into goods values
			(null,'苹果1袋',50,2000),
			(null,'苹果2袋',50,3000),
			(null,'苹果3袋',50,4000),
			(null,'苹果4袋',50,5000),
			(null,'苹果5袋',50,6000);

		insert into `order` values
			(null,'item10099',2,2);
		#这里插入一条订单数据，也就是下单了，这时候商品表的库存需要减一。
		update goods set inv=inv-1 where id=1;
		
		声明触发器：
			delimiter $	#将分隔符定义为$
				create trigger t1 after insert on order for each row
				begin
					update goods set inv=inv-2 where id=1;
				end$
			delimiter;	#将分隔符重新定义为;
					
		调用触发器
			向order插入一条记录，触发goods表的事件。
			insert into order values(null,'item1000',2,1);
		
		delimiter关键字
			因为我们的触发器中的内容是多条SQL语句，SQL语句都是以;号结尾的，所以MYSQL会认为SQL语句已经结束，所以创建触发器就会报错。
			delimiter关键字就是重新定义SQL语句的分隔符。
		
		查看触发器
			show triggers like 'patterm';

		删除触发器
			drop trigger 触发器名字
		
		语句结束符
			分号：;普通语句结束符
			\g：与分号一样的效果。
			\G：表示将得到的数据结果纵向显示

		注：不能创建同一张表同一个事件且触发时间相同的触发器。

	10.5 触发器的引用行变量
		上述中的触发器SQL语句只能一直更改固定商品的固定数量，实际开发中是需要引用监视事件的记录的。
		mysql提供了new、old俩个关键字来引用监视事件的记录。

		old.字段名
		new.字段名

		delete：
			before
			------------
			这是一条记录
			old
		update：
			before				after
			-------------------------------------
			这是记录1			这是记录1，更新后的(update)
			old					new
			#当更新记录2，在更新之前，记录2是old，更新后，记录2是new

		insert：
			before				after
			-------------------------------------
			这是记录1			这是记录1
								这是记录2，新增的(insert)
								new

		old：监视的事件发生之前的记录是old。
		new：监视的事件发生之后的记录是new。

		注1：insert没有old，delete没有new。
			这俩个关键字只能在触发器里面使用。
		
		注2：Updating of new row is not allowed in after trigger。
			所监视的表中，若发生一条更新或者插入数据，触发器中要对这条记录进行操作，必须在这条记录发生之前进行操作，也就是before insert/update on table_name

		example：重构
			delimiter $$
			create trigger order_goods_insert after insert on `order` for each row
				begin
					update goods set inv=inv-new.g_num where id=new.g_id;
				end
			$$
			delimiter ;

			insert into `order` values(null,'1000909',1,2);

	10.6 for each row
		Oracle数据库中的触发器分语句级触发器和行级触发器，mysql数据库只有行级触发器。
		example：
			create trigger tn after update on table_name for each row
			begin
				...
			end

			比如执行了一个SQL更新的语句。
			update table_name set xx=xx where id>100
			#该语句会把id大于100的记录进行更新，那么触发器会触发几次？
			#这条语句会导致触发器发出100次。
		
		监视的表的记录有多少行受影响，就触发多次次，这种叫做行级触发器。
		而在oracle中，若是不加for each row，那么只执行一次触发器。
		mysql不支持语句级的触发器。