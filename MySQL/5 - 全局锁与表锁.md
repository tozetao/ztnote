锁是指在并发访问下，控制访问共享资源的规则。

- DML

  data manipulation language，数据操作语言。

  比如select、update、insert、delete，主要对数据库的数据进行操作。

- DDL

  data definition language，数据定义语言。

  用于定义或改变表的结构，数据类型，表之间的链接和约束等初始化工作。



### 全局锁

对整个库进行加锁，只能读取库中的数据，全局加锁后，其他线程执行的数据更新语句（DML）、数据定义语句（DDL）和更新类事务的语句都会被阻塞。



- flush tables

  强制关闭所有打开的表，并刷新预准备的语句缓存。

- flush tables with read lock

  该语句会关闭所有打开的表并使用全局锁锁定所有数据库的表，使用unlock tables即可解除锁定。

有关flush命令的语法可以参考手册：https://dev.mysql.com/doc/refman/8.0/en/flush.html



应用场景

- 数据备份
- 保证备份期间数据的一致性



全局锁的影响

- 如果在主库上进行加锁备份，那么备份期间都不能执行更新，业务就得停摆。
- 如果在从库上进行备份，那么备份期间就无法同步主库的binlog日志，会造成主从延迟



其他备份方法

mysqldump工具使用参数--single-transaction的时候，导出数据之前会启动一个事务，来拿到一致性视图。由于MVCC的支持这个过程中数据是可修改的。

- 前置要求

  需要引擎支持事务，并且实现了可重复度隔离界别。







### 表级锁

手动给一张表进行加锁，表级锁同样有读锁和写锁，读读不互斥，读写和写写互斥。

- lock tables ... read/write

  给一张表加读锁或者写锁

- unlock tables;

  解表进行解锁

例如线程A lock tables t1 read, t2 write，其他线程在写t1，读写t2都会被阻塞。同时线程A在执行unlock tables之前，自身也只能读取t1表，写t2表，无法对这俩张表做其他操作，包括去操作其他表。



### metadata lock

metadata lock不需要显示使用，在访问一个表的时候会被自动加上。

注：该特性是MySQL在5.5版本中引入的。



对一个表做增删改查操作的时候，加MDL读锁；对一个表结构做更改的时候，加MDL写锁。

- 读锁之间不互斥因此多个线程可以对同一张表进行增删改查。

  如果一个线程在查询数据，另一个线程正好要删除前一个线程查询中的某条数据，会发生什么？

  InnoDB引擎支持行锁，读写同一条记录应该互斥；Myisam引擎不清楚。

- 读写锁、写锁之间是互斥的，因此一个线程修改一张表的结构，另一个线程要修改表结构时会被阻塞。亦或者是一个线程对一张表做读取数据操作，另一个线程要修改表结构时会发生阻塞，反之亦然。

值得注意的是，事务中的MDL锁，在语句执行的时候申请，但是语句执行后不会立即释放MDL锁，而是在事务提交后释放。

而且由于读写锁、写锁之间是互斥的，所以修改一张表结构的时候要特别注意，因为会阻塞后续线程的操作。如果要修改的表查询非常频繁的话，写锁可能会会导致这个库的线程很快就爆满。

example：

|       session a        |    session b     |             session c              |         session d          |
| :--------------------: | :--------------: | :--------------------------------: | :------------------------: |
| begin; select * from t |                  |                                    |                            |
|                        | select * from t; |                                    |                            |
|                        |                  | alter table t add n int; (blocked) |                            |
|                        |                  |                                    | select * from t; (blocked) |

从该表中就可以看出，session a启动一个查询事务，但是不提交。对于读锁操作不阻塞（session b），但是会阻塞写锁（session c），后续的ssion也会被阻塞。



如何安全的修改表结构?

- 清理长事务
- 停服，再去修改表结构













metadata lock release（MDL锁释放）

https://dev.mysql.com/doc/refman/5.7/en/metadata-locking.html

为了确保事务的可序列化性，服务器不允许一个会话在未完成的显式或隐式启动的事务中使用的表上执行数据定义语言 (DDL) 语句。

服务器通过获取事务中使用的表的元数据锁来实现此目的, 并延迟释放这些锁直到事务结束。表上的元数据锁可以防止对表结构的更改。此锁定方法的含义是, 在一个会话中由事务使用的表不能在其他会话的 DDL 语句中使用, 直到事务结束为止。

