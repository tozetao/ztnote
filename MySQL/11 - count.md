### count的实现

在不同的引擎中，count有不同的实现方式：

- MyISAM

  MyISAM会把一个表的总行数存储在磁盘上，因此执行count的时候会直接返回这个数值，效率很高。当然如果加入查询条件，查询速度也会变慢的。

- InnoDB

  InnoDB引擎执行count(*)的时候，需要把数据一行一行取出来，然后累积计算。

  InnoDB在执行count的时候是做了优化的，我们知道主键索引的叶子节点是数据，而普通索引的叶子节点是主键值。所以MySQL会找到那颗最小的树来进行遍历。



为什么InnoDB引擎需要全表扫描进行计算呢？

InnoDB使用MMVC实现事务，每一行记录会有不同的版本。在执行count计算时，对于这个事务来说，它需要知道哪些记录对它来说是可见的，因此需要一行一行扫描判断记录的可见性。

|        session A        |         session B         |
| :---------------------: | :-----------------------: |
|         begin;          |                           |
| select count(*) from t; |                           |
|                         | insert into t values(1,1) |
| select count(*) from t; |  select count(*) from t;  |
|         commit;         |                           |

假设t表中有10条记录，事务是从上到下按照时间顺序执行的，并且在可重复度隔离级别下。

session a启动事务执行第一条查询语句时，将会开启一个一致性视图，这时在sesion a后面开启的事务的数据版本对它来说就是不可见的，因此sesion a查询的记录数是10条，session b查询的记录数是11条。



总体来说，由于MyISAM不支持事务，而InnoDB执行count的效率又低，所以需要通过辅助手段来高效的统计数据。



### count的不同用法（InnoDB）

count()是一个聚合函数，对于返回的结果集，它会一行行判断，如果count函数的参数不为NULL，累计值就加1，否则不加，最后返回累计值。

- count(主键id)

  InnoDB会把遍历整张表，把每一行的id取出来，返回给server层。server层拿到id后判断是不可能为空的，然后按行累加。

- count(1)

  InnoDB会遍历整张表，但是不会去取值。server层对于取到的每一行，放个数字"1"进去，判断也是不可能为空的，然后按行累加。

- count(字段)

  如果字段允许为空，会把值取出来判断是否为NULL，只累加不为NULL的；

  如果字段不允许为空，一行行的从记录读出这个字段，按行累加。

count(*)、count(1)、count(主键ID)这3个都是返回满足条件的结果集的总行数，而count(字段)则表示返回满足条件的数据行里面，参数字段不为NULL的总个数。



### 性能分析原则

- server层要什么，引擎层就给什么

- 引擎层只给必要的值
- 现在的优化器优化了count(*)，它是不会取记录的所有字段值的。

