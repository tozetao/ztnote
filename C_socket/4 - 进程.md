TCP套接字的服务端是可以同时受理很多请求的，但是它只能按照序列来处理连接请求。

同时向多个连接请求提供服务的并发服务器端实现模型有：

- 多进程服务器：通过创建多个进程提供服务
- 多路复用服务器：通过捆绑并统一管理I/O对象提供服务
- 多线程服务器：通过生成与客户端等量的线程提供服务



### Process

占用内存空间的正在运行的程序叫做进程。

当打开多个应用时，系统会创建多个进程，从操作系统的角度来看进程是程序流的基本单位。如果系统的进程数量超过CPU核心数量，进程将会分时使用CPU资源，但是因为CPU运行极快所以会有感觉多个进程同时运行的错觉。

注：拥有多个运算器（核）的CPU称为多核CPU

- 进程ID：PID，由操作系统分配的ID，其值大于2



### fork

fork函数将创建调用的进程副本。

fort()函数并非根据不同的程序创建进程，而是复制正在运行的调用fork函数的进程。同时俩个进程都会执行fort()函数调用后的语句，但因为通过一个进程复制相同的内存空间，之后的程序流要根据fort()函数返回的值加以区分。

- 父进程：fork()函数子进程的id
- 子进程：fork()函数返回0

俩个进程执行fork()函数之后的代码是不会互相影响的，变量的内存地址是不一样的，fork()调用后分成了不同的进程，只是俩者共享同一段代码而已。

```c
#include <unistd.h>

int gval = 20;

int main(int argc char *argv[])
{
    int lavl = 10;
    pid_t pid;
    
    pid = fork();
    
    if(pid == 0){
        gval += 2;
        lval += 2;
    }else{
        gval -= 2;
        lval -= 2;
    }
}
```



### 僵尸进程

进程执行（执行完main函数）完毕后应该被销毁，但是有些进程会变成僵尸进程占用系统资源，这种状态的进程被称为僵尸进程。



#### 产生原因

exit()函数的参数值和main函数中的return语句返回值都会传递给操作系统，而操作系统不会销毁子进程，直到把这些值传递给产生该子进程的父进程，处于这种状态下的进程就是僵尸进程；

操作系统是不会主动将子进程的返回值传递给父进程的，需要父进程自己发起回收。



#### 销毁

子进程的销毁时机：在向创建子进程的父进程传递exit()参数欧return语句的返回值时销毁。

为了销毁子进程，父进程应该主动请求获取子进程的返回值。

#### API

```c
#include <sys/wait.h>
pid_t wait(int *statloc);
```

成功时返回终止的子进程ID，失败是返回-1，调用该函数时如果没有终止的子进程会导致程序阻塞，直到有子进程终止。

调用该函数后，如果已有子进程终止，那么子进程终止时传递的返回值将保存到函数参数所指向的内存空间，但函数参数的内存空间还保存其他信息，需要通过宏进行分离

- WIFEXITED：子进程正常退出返回true
- WEXITSTATUS：返回子进程的返回值



```c
#include <sys/wait.h>
pid_t waitpid(pid_t pid, int *statloc, int options);
```

该函数也可用于终止子进程，成功返回pid或0，失败返回-1，参数说明：

- pid：待终止的子进程id，若传递-1可以等待任何子进程结束
- statloc：该参数用于存储子进程返回结果的内存地址
- options：传递头文件sys/wait.h中声明的常量WONHANG，即使没有终止的子进程也不会阻塞程序，而是返回0



#### Demo

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>

//不会阻塞的子进程终止测试
int main(int argc, char const *argv[])
{
    pid_t pid;
    int status;
    
    pid = fork();
    
    if(pid == 0){
        sleep(15);
        return 0;
    }else{
        printf("child process pid: %d\n", pid);
        
        while(!waitpid(-1, &status, WONHANG)){
            sleep(3);
            puts("sleep 3sec");
        }
        
        if(WIFEXITED(status))
            printf("Child send one: %d\n", WEXITSTATUS(status));
    }
    
    return 0;
}
```





### 信号处理

信号是在特定事件发生时由操作系统向进程发送的消息，而为了响应该消息，执行与消息相关的自定义操作的过程称为"处理"或"信号处理"。



#### 信号注册

在进程发现自己的子进程结束时，请求操作系统调用特定函数，该过程称为"注册信号"过程。

```c
#include <signal.h>
void (*signal(int signo, void (*func)(int)))(int);
```

该函数用于注册信号，为了在产生信号时调用，返回之前注册的函数指针。

- 函数名：signal
- 参数：int signo,  void(* func)(int)
- 返回类型：参数为int型，返回void型函数指针

signo参数表示特殊情况信息，void (*func)(int)指针函数表示发生特殊情况会调用的函数。可注册的特殊情况有：

- SIGALRM：已到通过alrm()函数注册的时间
- SIGINT：输出CTRL + C
- SIGCHLD：子进程终止

例如在在子进程终止时注册信号：

```c
signal(SIGCHLD, mychild)
```



#### API

```c
#include <unistd.h>
unsigned int alarm(unsigned int seconds);
```

返回0或以秒为单位的距离SIGALRM信号发生的所剩时间，seconds参数值的不同情况：

- 如果传递的参数是正整数表示响应时间后将产生SIGALRM信号；

- 如果传递0，则之前对SIGALRM信号的预约将取消；
- 如果通过该函数预约信号后未指定该信号对应的处理函数，则终止进程（通过调用signal函数）不做任何处理。



#### example

```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

void timeout(int sig)
{
    if(sig == SIGALRM){
        puts("Timeout\n");
    }

    alarm(2);
}

void keycontrol(int sig)
{
    if(sig == SIGINT){
        puts("CTRL+C pressed\n");
    }
}

int main(int argc, char const *argv[])
{
    int i;
    signal(SIGALRM, timeout);
    signal(SIGINT, keycontrol);
    alarm(2);

    for(i=0; i<3; i++){
        puts("wait...");
        sleep(100);
    }

    return 0;
}
```

触发信号时将唤醒由于调用sleep()函数而进入阻塞状态的进程。

调用函数的主体是操作系统，但进程处于睡眠状态是无法调用函数的，因此触发信号时操作系统为了调用信号处理将会唤醒进程，所以sleep()函数即使睡眠时间未到也会被强行唤醒然后执行信号处理。



#### sigaction

sigaction()函数更加稳定且兼容多个版本的unix系统，建议使用该函数来进行信号处理。

```c
#include <signal.h>
int sigaction(int signo, const struct sigaction *act, struct sigaction *oldact);
```

- signo：信号信息
- act：信号处理函数信息
- oldact：可以获取之前注册的信号处理函数指针，不需要传0

成功返回0，失败返回-1。

```c
struct sigaction
{
    void (*sa_handler)(int);
    //信号处理函数指针
    
    sigset_t sa_mask;   
    int sa_flags;
}
```





