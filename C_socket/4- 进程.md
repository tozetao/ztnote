TCP套接字的服务端是可以同时受理很多请求的，但是它只能按照序列来处理连接请求。

同时向多个连接请求提供服务的并发服务器端实现模型有：

- 多进程服务器：通过创建多个进程提供服务
- 多路复用服务器：通过捆绑并统一管理I/O对象提供服务
- 多线程服务器：通过生成与客户端等量的线程提供服务



### Process

占用内存空间的正在运行的程序叫做进程。

当打开多个应用时，系统会创建多个进程，从操作系统的角度来看进程是程序流的基本单位。如果系统的进程数量超过CPU核心数量，进程将会分时使用CPU资源，但是因为CPU运行极快所以会有感觉多个进程同时运行的错觉。

注：拥有多个运算器（核）的CPU称为多核CPU

- 进程ID：PID，由操作系统分配的ID，其值大于2



### fork

fork函数将创建调用的进程副本。

fort()函数并非根据不同的程序创建进程，而是复制正在运行的调用fork函数的进程。同时俩个进程都会执行fort()函数调用后的语句，但因为通过一个进程复制相同的内存空间，之后的程序流要根据fort()函数返回的值加以区分。

- 父进程：fork()函数子进程的id
- 子进程：fork()函数返回0

俩个进程执行fork()函数之后的代码是不会互相影响的，变量的内存地址是不一样的，fork()调用后分成了不同的进程，只是俩者共享同一段代码而已。

```c
#include <unistd.h>

int gval = 20;

int main(int argc char *argv[])
{
    int lavl = 10;
    pid_t pid;
    
    pid = fork();
    
    if(pid == 0){
        gval += 2;
        lval += 2;
    }else{
        gval -= 2;
        lval -= 2;
    }
}
```



### 僵尸进程

进程执行（执行完main函数）完毕后应该被销毁，但是有些进程会变成僵尸进程占用系统资源，这种状态的进程被称为僵尸进程。



#### 产生原因

exit()函数的参数值和main函数中的return语句返回值都会传递给操作系统，而操作系统不会销毁子进程，直到把这些值传递给产生该子进程的父进程，处于这种状态下的进程就是僵尸进程；

操作系统是不会主动将子进程的返回值传递给父进程的，需要父进程自己发起回收。



#### 销毁

子进程的销毁时机：在向创建子进程的父进程传递exit()参数欧return语句的返回值时销毁。

为了销毁子进程，父进程应该主动请求获取子进程的返回值。



```c
#include <sys/wait.h>

pid_t wait(int *statloc);
//成功时返回终止的子进程ID，失败是返回-1
```









