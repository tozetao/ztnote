- 文件描述符

  文件描述符是分配给文件或套接字的整数，文件或套接字一般是在创建过程中分配文件描述符，便于操作系统标识该文件。

  C语言中标准输入输出和标准错误也被分配了文件描述符，0是标准输入，1是标准输出，2是标准错误。

  ​


以_t后缀的数据类型，都是在sys/types.h文件头中定义的；



协议：

为了完成数据交换而约定的规则，即通信规则。

```c
int socket(int domain, int type, int protocol);
/*
domain
	套接字使用的协议族信息
type
	套接字数据传输类型
protocol
	计算机通信使用的协议信息
*/
```

协议族，即协议分类信息。

PF_INET：IPv4互联网协议族

PF_INET6：IPv6互联网协议族

PF_LOCAL：本地通信的UNIX协议族

PF_PACKET：底层套接字的协议族

套接字的协议分类决定了第三个参数的协议信息。



###套接字类型

指的是套接字的数据传输方式，协议族是不能决定数据传输方式的，同一个协议族有多种数据传输方式。



#### 面向连接的套接字

SOCKET_STREAM参数表示面向连接，它的优点有：

- 传输数据的过程中数据不会消失
- 按序传输数据
- 传输的数据不存在数据边界




为什么无数据边界?

传输数据端可以多次发送数据，接收数据的套接字内部是有缓冲区的，即字节数组，接收的数据会保存到缓冲区中，因此受到数据后不一定会立即调用read()函数读取数据，可能会等缓冲区满了读取，也有可能分成多次读取，也就是write()和read()函数的调用次数没有太大意义，所以说面向连接的套接字是不数据边界的。

测试数据边界，可以在接受数据段多次读取数据，如果读取的数据是完整的，表示数据是没有边界的。



客户端的缓冲区已满是否会造成数据丢失?

首先调用read()函数会从缓冲区读取部分数据，所以缓冲区不一定一直是满的。但是如果read()函数读取的速度比接收数据的速度慢，缓冲区可能会被填满。

这种情况下传输端套接字会停止传输数据，面向连接的套接字会根据接收端的状态来传输数据，如果传输数据出错还会提供重传服务。因此说面向连接的套接字除特殊情况不会发生数据丢失。



面向连接的套接字是必须一一对应的，面向连接的套接字只能用另外一个同样特性的套接字进行连接，总结的话，面向连接的套接字是一种可靠的、按序传递的、基于字节的面向连接的数据传输方式



#### 面向消息的套接字

第二个参数的SOCK_DGRAM值表示面向消息的套接字，面向消息的套接字有以下特点：

- 强调快速传输而非传输顺序
- 传输的数据有数据边界
- 传输的数据有大小限制
- 传输的数据可能会丢失或损坏

面向消息的套接字相当于把数据打包成多个数据包来进行传输，由于是分成多个数据包进行传输，它具有更快的传输速度，但无法避免数据丢失。另外传输的数据大小有限制并存在数据边界，这意味着接收数据的次数和传输数据的次数相同。



总结：面向消息的套接字是不可靠、不按序传输，以数据高速传输为目的的一种数据传输方式。




### 协议的最终选择

一般协议族和套接字的传输数据方式确定的话，就可以创建套接字。但是如果协议族中存在多个数据传输方式相同的协议，就需要指定最终的传输方式。

例如基于IPv4协议族的面向连接的套接字只有TCP协议，所以在socket()函数中，第三个参数也就是传输数据的协议选择TCP协议，所以写默认值0即可。

socket()函数第三个参数的值有：

- IPPROTO_TCP
- IPPROTO_UDP




### 地址族

地址族指的是IP协议，IP是Internet Protoal(网络协议)的缩写，为了计算机在网络中能通信，需要为其分配IP地址，IP地址可以分为俩类：

- IPv4

  4个字节长度的地址协议族

- IPv6地址协议族

  16个字节长度的地址协议族



IPv4标准的4字节IP地址主要由网络地址和主机地址组成

- 网络地址

  为了区分网络而设置的一部分IP地址

- 主机地址

  区分计算机的地址



如何向一个IP地址发送数据?

​	向一个IP地址发送数据时，并不是直接浏览所有4字节IP地址，而是先寻找4字节IP地址中的网络地址，向其发送数据，再由网络地址（构成网络的路由）根据主机地址路由主机，向主机发送数据。

假设有202.35.69.133IP地址，它的域名是abc.com，网络地址是202.35.69，主机地址是133，向相应的网络地址传输数据实际上是向构成该网络的路由器或交换机传输数据的。



网络地址分类与主机地址边界

​	IP地址可以分为A、B、C、D和E类型。

- A类型：网络地址占据1个字节，主机地址占据3个字节
- B类型：网络地址占据2个字节，主机地址占据2个字节
- C类型：网络地址占据3个字节，主机地址占据1个字节
- D类型：多播IP地址

		只需要通过IP地址的第一个字节即可判断网络地址占用的字节数。

- A类地址的首位是以0开始

- B类地址的首位是以10开始

- C类地址的首位是以110开始

  这里的位指的是二进制位，通过这种方式数据收发到网络中后就可以找到正确的主机。



### 端口号

IP地址是用于区分计算机，只IP地址才能向目标主机发送数据。而端口号是同一个操作系统为了区分不同套接字而设置的。

一个端口是无法分配给多个套接字的，端口号是由俩个字节构成，可分配的范围是0-65535；虽然端口号不能重复，但TCP套接字和UDP套接字不会共用端口号，所以允许重复。



### 网络字节序

不同CPU中，保存数据的方式是不同的。例如一个4字节整型数值1的2进制如下：

> 0000 0000 0000 0001

某些CPU会以顺序保存，而有些CPU会以倒序保存。

> 0001 0000 000 0000

如果不考虑数据存储的顺序，收发数据自然会产生问题。



字节序

CPU向内存保存数据的方式有2种，这意味着CPU解析数据的方式也分2种：

- 大端序（Big Endian）：高位字节存储到低位地址
- 小端序（Little Endian）：高位字节存储到高位地址

高位字节指的是数据位，低位或高位地址指的是内存地址。

举例来说，如果在0x20内存地址中保存4字节int型整数0x12345678，大端序字节存储方式如下：

| 内存地址 | 0x20 | 0x21 | 0x22 | 0x23 |
| -------- | ---- | ---- | ---- | ---- |
| 数据     | 0x12 | 0x34 | 0x56 | ox78 |

小端字节序的存储方式是：

| 内存地址 | 0x20 | 0x21 | 0x22 | 0x23 |
| -------- | ---- | ---- | ---- | ---- |
| 数据     | 0x78 | 0x45 | 0x34 | 0x12 |

如果发送方以大端序来发送数据，接收放将接收的数据以小端序来解析的话，数据就不是我们预期想要的了；因此通过网络传输数据时约定使用大端序，这边是网络字节序。

发送数据时先把数组转换成大端序格式再进行网络传输，小端序的系统传输数据时也应转化成大端序排列方式。



### TCP/IP

根据数据传输方式的不同，基于网络协议的套接字一般分为TCP套接字和UDP套接字，因为TCP是面向连接的，也被称为基于流的套接字。



TCP/IP协议栈

TCP/IP协议栈分为4层，也就是说数据的收发分为4个层次化过程，分别是应用层、TCP层、IP层和链路层，各个层次之间是互通的。

分层的好处：分层是为了制定标准，层与层之间依赖标准制定的接口而不关注具体实现，例如路由器是按照IP层的标准来实现的，那么只要符合IP层的标准，哪个厂商的路由器都是通用的。

- 链路层

  计算机与计算机连同的物理层面，它指定了LAN、WAN、MAN等标准。

- IP层

  决定向目标传输数据时要选择的路径。

  IP本身是面向消息的、不可靠的协议；每次传输时都会选择路径，但是不一致；如果传输过程中发生路径错误会重新选择其他路径，但是发生数据错误或丢失则无法解决。

- TCP层

  以IP层提供的路径来传输数据，因此也被叫做传输层。

  数据传输的基本单位叫做包，IP层只关注1个数据包的传输过程。也就是说多个数据包传输时，数据包传输的顺序和数量是否正确IP层是无法确定的。

  基于IP层按照TCP协议来传输数据包可以保证数据的正确性，在每次传输数据包的时候，发送放都会等待接收方回传信息来判断数据包是否传输正确，包括数据包是否完整接收，数据包的数量和发送次序是否正确。

  如果不正确将会发送方将会重传以此来保证数据的正确性。

- 应用层

  选择数据传输路径、数据确认的过程都被隐藏到套接字内部。

  我们只需要利用套接字来进行编程，根据程序特点决定服务器端和客户端之间的数据传输规则（规定），这便是应用层协议。

  网络编程大部分都是设计并实现应用层该协议。




#### TCP服务端

- socket()

- bind()

  为套接字绑定IP地址和端口

- listen(int sock, int backlog)

  进入等待连接请求状态，sock是创建的套接字描述符，backlog是连接请求等待的队列。

  所谓的进入等待连接请求状态，是指客户端在请求连接时，服务端在受理请求连接前会使请求处于等待状态，这些请求都会被放入连接请求等待队列中。

  服务端的套接字在这里相当于接收请求连接的一个门。

- accept(int sock, struct sockaddr *addr, socklen_t * addrlen)

  sock是服务器套接字文件描述符，addr指针用于保存连接请求的客户端地址信息，addrlen存储客户端地址长度。

  服务器端套接字相当于门卫，用于等待连接请求并存储连接请求到队列中；受理连接请求并与客户端连接请求进行交换数据需要另外一个套接字。

  accpet()函数负责处理请求，它会从连接请求队列中取出当前要处理的连接请求，创建用于数据I/O的套接字，I/O套接字是自动创建的，与客户端建立连接也是自动化的。

  注：如果连接请求队列为空，accept()函数是不会返回的，程序将会阻塞直到队列中有新的连接



#### TCP客户端

- socket()

  创建客户端套接字

  ​

- connect()

  connect()函数会使用创建的套接字向服务端发起请求，在服务端listen()调用创建请求连接等待队列后，客户端即可请求连接。

  connect()函数会在服务端接收连接请求后返回或者网络连接中断返回。这里的接收连接请求是指服务端将连接请求加入到等待队列中，因此connect()函数返回后并不会立即进行数据交换。

  真正进行数据交换是在服务端accept()函数执行之后，这时候客户端connect()函数也执行完毕，然后服务端和客户端相互进行I/O交互。

  ​

- read()/write()

- close()



客户端套接字的IP地址和端口是在调用connect()函数时自动分配的，无需调用bind()函数进行分配。TCP服务端和TCP客户端并不是独立的，俩者是相互关联的。

服务器在调用listen()函数进入等待连接请求状态时，TCP客户端才能通过connect()进行连接，同时要注意的是客户端调用connect()之前，服务端可能会进入accept()阶段，这时候会进入阻塞状态直到客户端调用connect()函数为止。





### TCP与应用层协议

TCP是面向连接的，传输数据是没有边界的，因此需要定义应用层协议。

应用层协议的制定是为了让服务端或客户端知道读取数据的边界，这样才能正确的通信。



TCP服务端和TCP客户端的write()和read()函数是对应的，

例如客户端先调用write()，再调用read()函数，服务端调用read()再调用write()函数，如果服务端read()调用后阻塞，客户端也会阻塞等待服务端传输数据。





### TCP的IO缓冲

TCP套接字是有I/O缓冲区的，即输入缓冲区和输出缓冲区。

I/O进行数据交互时，write()函数会将数据移动到输出缓冲区，在适当时候将数据传向对方的输入缓冲区(分批传送或一次性传送)，这时对方将调用read()函数从输入缓冲区读取数据，

注：write()函数并不会在向对方主机传输数据完成后返回，它是在将数据传输到输出缓冲区后返回。

I/O缓冲区特性有：

- 每个套接字都有I/O缓冲区
- I/O缓冲在创建套接字完成
- 即使关闭套接字也会继续传递输出缓冲区中遗留的数据
- 关闭套接字会丢失在输入缓冲区的数据

除了I/O缓冲，TCP协议还拥有Sliding Window协议，该协议可以控制数据流，即传输的数据不会超过输入缓冲区的大小。



### TCP握手

TCP套接字从创建到消失的过程分3步：

- 与对象套接字建立连接
- 与对方套接字进行数据交换
- 断开与对方套接字的连接



套接字的连接：

TCP在实际通信过程中也会经过3次对话过程，简称三次握手（Three-way handshaking）。套接字是以全双工（Full-duplex）方式工作的，也就是说它可以双向传递数据，因此收发数据前需要一些准备。



假设现在主机A向主机B发起连接，它的3次握手过程如下：

- [SYN] SEQ:1000,  ACK::-

  这是首次连接时使用的信息，又称SYN，表示收发数据前传输的同步消息。

  SEQ是1000，ACK为空。SEQ1000的意思是当前数据包的序号是1000，如果主机B接收无误的话，请通知我向您传递1001序号的数据包。

- [SYN+ACK] SEQ:2000, ACK:1001

  这是主机B对主机A首次传输的数据包的确认消息，ACK1001表示SEQ1000的数据包接收无误，请传递1001的数据包。

  SEQ2000是为主机B传输数据做准备的同步消息的捆绑发送，它表示现在传递的数据包序号是2000，如果接收无误请向我传递2001的数据包。

- [ACK] SEQ:1001, ACK:2001

  ACK2001表示收到2000序号的数据包，现在传递SEQ为2001序号的数据包，在这一步主机A和主机B建立了连接。



套接字的数据交换

假设有200字节的数据需要进行传输，传输过程中分2次（2个数据包），具体过程如下：

- SEQ 1200, 100byte data

  主机A向主机B传递100字节数据，数据包序列号是1200

- ACK 1301

  主机B为了确认收到数据，回传1301消息，这里1301的序号是为了确定接收到数据，并且确定下一次接收的数据包序号，计算公式是：ACK号 = SEQ号 + 传递的字节数 + 1

- SEQ 1301, 100byte data

- ACK 1402

如果在传递第二个数据包时发生数据包丢失，例如超时等原因，那么主机A在迟迟等不到主机B回传的ACK就会尝试数据包重传。

为了完成数据包重传，TCP套接字是会启动计时器以等待ACK应答的，若相应计时器发生超时重传。