- 文件描述符

  文件描述符是分配给文件或套接字的整数，文件或套接字一般是在创建过程中分配文件描述符，便于操作系统标识该文件。

  C语言中标准输入输出和标准错误也被分配了文件描述符，0是标准输入，1是标准输出，2是标准错误。






以_t后缀的数据类型，都是在sys/types.h文件头中定义的；





协议：

为了完成数据交换而约定的规则，即通信规则。

```c
int socket(int domain, int type, int protocol);
/*
domain
	套接字使用的协议族信息
type
	套接字数据传输类型
protocol
	计算机通信使用的协议信息
*/
```

协议族，即协议分类信息。

PF_INET：IPv4互联网协议族

PF_INET6：IPv6互联网协议族

PF_LOCAL：本地通信的UNIX协议族

PF_PACKET：底层套接字的协议族

套接字的协议分类决定了第三个参数的协议信息。



###套接字类型

指的是套接字的数据传输方式，协议族是不能决定数据传输方式的，同一个协议族有多种数据传输方式。



#### 面向连接的套接字

SOCKET_STREAM参数表示面向连接，它的优点有：

- 传输数据的过程中数据不会消失
- 按序传输数据
- 传输的数据不存在数据边界




为什么无数据边界?

传输数据端可以多次发送数据，接收数据的套接字内部是有缓冲区的，即字节数组，接收的数据会保存到缓冲区中，因此受到数据后不一定会立即调用read()函数读取数据，可能会等缓冲区满了读取，也有可能分成多次读取，也就是write()和read()函数的调用次数没有太大意义，所以说面向连接的套接字是不数据边界的。

测试数据边界，可以在接受数据段多次读取数据，如果读取的数据是完整的，表示数据是没有边界的。



客户端的缓冲区已满是否会造成数据丢失?

首先调用read()函数会从缓冲区读取部分数据，所以缓冲区不一定一直是满的。但是如果read()函数读取的速度比接收数据的速度慢，缓冲区可能会被填满。

这种情况下传输端套接字会停止传输数据，面向连接的套接字会根据接收端的状态来传输数据，如果传输数据出错还会提供重传服务。因此说面向连接的套接字除特殊情况不会发生数据丢失。



面向连接的套接字是必须一一对应的，面向连接的套接字只能用另外一个同样特性的套接字进行连接，总结的话，面向连接的套接字是一种可靠的、按序传递的、基于字节的面向连接的数据传输方式



#### 面向消息的套接字

第二个参数的SOCK_DGRAM值表示面向消息的套接字，面向消息的套接字有以下特点：

- 强调快速传输而非传输顺序
- 传输的数据有数据边界
- 传输的数据有大小限制
- 传输的数据可能会丢失或损坏

面向消息的套接字相当于把数据打包成多个数据包来进行传输，由于是分成多个数据包进行传输，它具有更快的传输速度，但无法避免数据丢失。另外传输的数据大小有限制并存在数据边界，这意味着接收数据的次数和传输数据的次数相同。



总结：面向消息的套接字是不可靠、不按序传输，以数据高速传输为目的的一种数据传输方式。




### 协议的最终选择

一般协议族和套接字的传输数据方式确定的话，就可以创建套接字。但是如果协议族中存在多个数据传输方式相同的协议，就需要指定最终的传输方式。

例如基于IPv4协议族的面向连接的套接字只有TCP协议，所以在socket()函数中，第三个参数也就是传输数据的协议选择TCP协议，所以写默认值0即可。

socket()函数第三个参数的值有：

- IPPROTO_TCP
- IPPROTO_UDP




### 地址族

地址族指的是IP协议，IP是Internet Protoal(网络协议)的缩写，为了计算机在网络中能通信，需要为其分配IP地址，IP地址可以分为俩类：

- IPv4

  4个字节长度的地址协议族

- IPv6地址协议族

  16个字节长度的地址协议族



IPv4标准的4字节IP地址主要由网络地址和主机地址组成

- 网络地址

  为了区分网络而设置的一部分IP地址

- 主机地址

  区分计算机的地址



如何向一个IP地址发送数据?

​	向一个IP地址发送数据时，并不是直接浏览所有4字节IP地址，而是先寻找4字节IP地址中的网络地址，向其发送数据，再由网络地址（构成网络的路由）根据主机地址路由主机，向主机发送数据。

假设有202.35.69.133IP地址，它的域名是abc.com，网络地址是202.35.69，主机地址是133，向相应的网络地址传输数据实际上是向构成该网络的路由器或交换机传输数据的。



网络地址分类与主机地址边界

​	IP地址可以分为A、B、C、D和E类型。

- A类型：网络地址占据1个字节，主机地址占据3个字节
- B类型：网络地址占据2个字节，主机地址占据2个字节
- C类型：网络地址占据3个字节，主机地址占据1个字节
- D类型：多播IP地址

		只需要通过IP地址的第一个字节即可判断网络地址占用的字节数。

- A类地址的首位是以0开始

- B类地址的首位是以10开始

- C类地址的首位是以110开始

  这里的位指的是二进制位，通过这种方式数据收发到网络中后就可以找到正确的主机。



### 端口号

IP地址是用于区分计算机，只IP地址才能向目标主机发送数据。而端口号是同一个操作系统为了区分不同套接字而设置的。

一个端口是无法分配给多个套接字的，端口号是由俩个字节构成，可分配的范围是0-65535；虽然端口号不能重复，但TCP套接字和UDP套接字不会共用端口号，所以允许重复。



### 网络字节序

不同CPU中，保存数据的方式是不同的。例如一个4字节整型数值1的2进制如下：

> 0000 0000 0000 0001

某些CPU会以顺序保存，而有些CPU会以倒序保存。

> 0001 0000 000 0000

如果不考虑数据存储的顺序，收发数据自然会产生问题。



字节序

CPU向内存保存数据的方式有2种，这意味着CPU解析数据的方式也分2种：

- 大端序（Big Endian）：高位字节存储到低位地址
- 小端序（Little Endian）：高位字节存储到高位地址

高位字节指的是数据位，低位或高位地址指的是内存地址。

举例来说，如果在0x20内存地址中保存4字节int型整数0x12345678，大端序字节存储方式如下：

| 内存地址 | 0x20 | 0x21 | 0x22 | 0x23 |
| -------- | ---- | ---- | ---- | ---- |
| 数据     | 0x12 | 0x34 | 0x56 | ox78 |

小端字节序的存储方式是：

| 内存地址 | 0x20 | 0x21 | 0x22 | 0x23 |
| -------- | ---- | ---- | ---- | ---- |
| 数据     | 0x78 | 0x45 | 0x34 | 0x12 |

如果发送方以大端序来发送数据，接收放将接收的数据以小端序来解析的话，数据就不是我们预期想要的了；因此通过网络传输数据时约定使用大端序，这边是网络字节序。

发送数据时先把数组转换成大端序格式再进行网络传输，小端序的系统传输数据时也应转化成大端序排列方式。



### TCP/IP

根据数据传输方式的不同，基于网络协议的套接字一般分为TCP套接字和UDP套接字，因为TCP是面向连接的，也被称为基于流的套接字。



TCP/IP协议栈

TCP/IP协议栈分为4层，也就是说数据的收发分为4个层次化过程，分别是应用层、TCP层、IP层和链路层，各个层次之间是互通的。

分层的好处：分层是为了制定标准，层与层之间依赖标准制定的接口而不关注具体实现，例如路由器是按照IP层的标准来实现的，那么只要符合IP层的标准，哪个厂商的路由器都是通用的。

- 链路层

  计算机与计算机连同的物理层面，它指定了LAN、WAN、MAN等标准。

- IP层

  决定向目标传输数据时要选择的路径。

  IP本身是面向消息的、不可靠的协议；每次传输时都会选择路径，但是不一致；如果传输过程中发生路径错误会重新选择其他路径，但是发生数据错误或丢失则无法解决。

- TCP层

  以IP层提供的路径来传输数据，因此也被叫做传输层。

  数据传输的基本单位叫做包，IP层只关注1个数据包的传输过程。也就是说多个数据包传输时，数据包传输的顺序和数量是否正确IP层是无法确定的。

  基于IP层按照TCP协议来传输数据包可以保证数据的正确性，在每次传输数据包的时候，发送放都会等待接收方回传信息来判断数据包是否传输正确，包括数据包是否完整接收，数据包的数量和发送次序是否正确。

  如果不正确将会发送方将会重传以此来保证数据的正确性。

- 应用层

  选择数据传输路径、数据确认的过程都被隐藏到套接字内部。

  我们只需要利用套接字来进行编程，根据程序特点决定服务器端和客户端之间的数据传输规则（规定），这便是应用层协议。

  网络编程大部分都是设计并实现应用层该协议。




TCP服务端的默认函数调用顺序：

- socket()

- bind()

  为套接字绑定IP地址和端口

- listen(int sock, int backlog)

  进入等待连接请求状态，sock是创建的套接字描述符，backlog是连接请求等待的队列。

  调用listen()函数后，套接字会进入等待连接请求状态，客户端在请求服务端套接字时，受理请求之前都将处理等待状态，这些请求都会被放入连接请求等待队列中。

  注：listen()执行后客户端的connect()函数调用才不会调用失败。

  服务器端是接收请求连接的一个门。

  ​