socket，套接字的意思，它是计算机之间进行通信的一种约定。通过这种约定，一台计算机可以接受其他计算机的数据，也可以先其他计算机发送数据。



### IP地址（IP Address）

IP地址是用于定位计算器位置的一种方式，例如114.114.114.114是国内第一个、全球第三个开放的DNS服务地址。

当要通信时，会将IP地址封装到数据包中，交由路由器处理。路由器有很高效的算法，可以通过IP地址找到对应的计算机，将数据包传递给它，以完成一次单向通信。



### 端口（Port）

有了IP地址，虽然可以找到目标计算机，但是仍然不能通信。一台计算机可以提供多种服务，例如web服务、FTP服务、SMTP服务等等，仅有IP地址计算机虽然可以正确接受数据包，但是无法知道将数据包交给哪个网络服务处理，所以通信失败。

为了区分不同的网络程序，计算器会为每个网络程序分配一个独一无二的端口号（Port Number），例如web服务的端口号是80，FTP服务的端口号是21。

端口是一个虚拟的概念，可以将端口理解为一道门。数据通过这道门流入流出，每道门有不同的编号，就是端口号。



### 协议（Protoal）

协议就是网络通信的约定，通信的双方必须都遵守才能正常收发数据。

协议有很多种，例如TCP、IP、UDP等，通信的双方必须使用同一协议才能通信；协议由计算机组织定义，规范了很多细节，例如如何建立连接，如何相互识别等。



协议族（Protocol Family），就是多个协议的统称，最常见的是TCP/IP协议族。它包含IP、TCP、UDP、Telnet等上百个互为关联的协议，由于TCP和IP是俩种常见的底层协议，所以统称为TCP/IP协议族。



### 数据传输方式

计算机之间有很多种数据传输方式，其中TCP、UDP协议是俩种很常见的数据传输方式。

- SOCK_STREAM

  表示面向连接的数据传输方式，数据可以准确的传输到另一台计算机。

  如果损失或丢失，可以重新发送，但是效率较慢。常见的HTTP协议就用SOCK_STREAM传输数据，因为要保证数据的正确性。

- SOCK_DGRAM

  表示无连接的数据传输方式，计算机只管传输数据，不做数据验证。

  如果数据在传输过程中丢失或损坏，是无法挽救的。由于不做数据验证，因此传输效率较高。

协议与数据传输方式是俩个不同的概念。

协议是计算机通信规范，例如IP协议定义通信过程中如何寻找一台计算机，而TCP、UDP协议则定义通信过程中数据的传输方式。

有可能多种协议使用同一种数据传输方式，因此编程中要指定使用的协议和数据传输方式。





### Functions

在linux中，一切都是文件，硬件、socket都可以认为是文件。所有在Linux系统中创建的文件都有一个int型的编号，称为文件描述符，使用文件时只需要知道编号即可。

socket也是一种文件，所以在网络数据传输时可以使用与文件I/O相关的函数，可以认为俩台计算机之间的通信，实际上是俩个socket文件的相互读写。



```c
#include <sys/socket.h>
int socket(int af, int type, int protocal)
```

创建一个socket。

- af

  address family，地址族的意思。表示IP地址的类型，常用的有AF_INET和AF_INET6，AF_INET表示IPv4地址，AF_INET6表示IPv6地址。

  也可以使用PF前缀，Protocal Family的意思。PF_INET等于AF_INET，PF_INET6等于AF_INET6。

- type

  数据传输方式，例如SOCK_STREAM、SOCK_DAGRM

- protocal

  表示传输协议，TCP协议为IPPROTO_TCP，UDP协议为IPPROTO_UDP。

说明：因为可能有多张协议支持同一个数据传输方式和地址族，所以需要protocal参数。TCP协议与UDP协议都只有一种情况满足，所以protocal参数可以写0



```c
bind(int sock, struct sockaddr *addr, socklen_t addrlen);
```

sockt()用于确定套接字的属性，bind()函数用于将套接字与特定的IP地址和端口绑定起来。只有这样，流经过该IP地址和端口的数据才能交给套接字处理，而客户端需要使用connect()函数建立连接。

sock参数是socket文件描述符，addr参数是一个sockaddr的结构体，指定绑定的IP与端口等信息，addrlen参数是该结构体的大小。

```c
struct sockaddr {
    sa_family_t sin_family;	//地址族
    char sa_data[14];		//IP地址和端口号
}

struct sockaddr_in {
    sa_family_t sin_family;	//地址族，也就是地址类型
    uint16_t sin_port;		//16位的端口号
    struct in_addr;			//32位IP地址
    char sin_zero[8];		
}
```

sockaddr和sockaddr_in结构体的长度一致，都是16个字节，sockaddr是使用sa_data成员将IP地址和端口合并到一起，它的赋值比较麻烦，所以一般会使用sockaddr_in结构来代替sockadd结构。

sockaddr_in的各个参数意义如下：

- sin_family

  地址族，与socket()函数的参数一致，占用俩个字节。

- sin_port

  端口号，uint16_t长度为俩个字节，端口号需要使用htons()转换。

- in_addr

  in_addr是一个只包含一个成员的结构体。

  ```c
  #include <netinet/in.h>
  in_addr_t s_addr;
  ```

  in_addr等价于unsigned long，长度为4个字节。s_addr是一个整数，所以需要使用inet_addr()函数转换。

- sin_zero

  一般填充为0，没什么用。

sockaddr_in结构用于表示IPv4的地址，如果要表示IPv6的地址，可以使用sockaddr_in6结构。

```c
struct sockaddr_in6 { 
    sa_family_t sin6_family;   //地址类型，取值为AF_INET6
    in_port_t sin6_port;  	   //16位端口号
    uint32_t sin6_flowinfo;    //IPv6流信息
    struct in6_addr sin6_addr; //具体的IPv6地址
    uint32_t sin6_scope_id;    //接口范围ID
};
```



```c
int connect(int sock, struct sockaddr *serv_addr, socklen_t addrlen); 
```

用于连接连接，它的参数与bind()基本相同。



```c
listen(int sock, int backlog);
```

在绑定IP地址与端口后，就需要让套接字进入被动监听状态。sock是需要进入监听状态的套接字，backlog为请求队列的最大长度。

- 所谓被动监听

  指当没有客户端请求时，套接字处于"睡眠"状态，只有当收到客户端请求时，套接字才会被"唤醒"来相应请求。

- 请求队列

  当套接字正在处理客户端请求时，如果有新的请求进来，套接字是无法处理的，只能把他放到缓冲区，待当前请求处理完毕后，再从缓冲区中读取出来处理。

  如果不断有新的请求进来，它们会按照先后顺序放到缓冲区中，直到缓冲区满，该缓冲区就被成为请求队列。

  如果缓冲区满了，对于Linux，客户端会收到ECONNREFUSED 错误。

