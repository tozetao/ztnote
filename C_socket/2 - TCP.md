### TCP/IP

根据数据传输方式的不同，基于网络协议的套接字一般分为TCP套接字和UDP套接字，因为TCP是面向连接的，也被称为基于流的套接字。



TCP/IP协议栈

TCP/IP协议栈分为4层，也就是说数据的收发分为4个层次化过程，分别是应用层、TCP层、IP层和链路层，各个层次之间是互通的。

分层的好处：分层是为了制定标准，层与层之间依赖标准制定的接口而不关注具体实现，例如路由器是按照IP层的标准来实现的，那么只要符合IP层的标准，哪个厂商的路由器都是通用的。

- 链路层

  计算机与计算机连同的物理层面，它指定了LAN、WAN、MAN等标准。

- IP层

  决定向目标传输数据时要选择的路径。

  IP本身是面向消息的、不可靠的协议；每次传输时都会选择路径，但是不一致；如果传输过程中发生路径错误会重新选择其他路径，但是发生数据错误或丢失则无法解决。

- TCP层

  以IP层提供的路径来传输数据，因此也被叫做传输层。

  数据传输的基本单位叫做包，IP层只关注1个数据包的传输过程。也就是说多个数据包传输时，数据包传输的顺序和数量是否正确IP层是无法确定的。

  基于IP层按照TCP协议来传输数据包可以保证数据的正确性，在每次传输数据包的时候，发送放都会等待接收方回传信息来判断数据包是否传输正确，包括数据包是否完整接收，数据包的数量和发送次序是否正确。

  如果不正确将会发送方将会重传以此来保证数据的正确性。

- 应用层

  选择数据传输路径、数据确认的过程都被隐藏到套接字内部。

  我们只需要利用套接字来进行编程，根据程序特点决定服务器端和客户端之间的数据传输规则（规定），这便是应用层协议。

  网络编程大部分都是设计并实现应用层该协议。



#### TCP服务端

- socket()

- bind()

  为套接字绑定IP地址和端口

- listen(int sock, int backlog)

  进入等待连接请求状态，sock是创建的套接字描述符，backlog是连接请求等待的队列。

  所谓的进入等待连接请求状态，是指客户端在请求连接时，服务端在受理请求连接前会使请求处于等待状态，这些请求都会被放入连接请求等待队列中。

  服务端的套接字在这里相当于接收请求连接的一个门。

- accept(int sock, struct sockaddr *addr, socklen_t * addrlen)

  sock是服务器套接字文件描述符，addr指针用于保存连接请求的客户端地址信息，addrlen存储客户端地址长度。

  服务器端套接字相当于门卫，用于等待连接请求并存储连接请求到队列中；受理连接请求并与客户端连接请求进行交换数据需要另外一个套接字。

  accpet()函数负责处理请求，它会从连接请求队列中取出当前要处理的连接请求，创建用于数据I/O的套接字，I/O套接字是自动创建的，与客户端建立连接也是自动化的。

  注：如果连接请求队列为空，accept()函数是不会返回的，程序将会阻塞直到队列中有新的连接



#### TCP客户端

- socket()

  创建客户端套接字

  ​

- connect()

  connect()函数会使用创建的套接字向服务端发起请求，在服务端listen()调用创建请求连接等待队列后，客户端即可请求连接。

  connect()函数会在服务端接收连接请求后返回或者网络连接中断返回。这里的接收连接请求是指服务端将连接请求加入到等待队列中，因此connect()函数返回后并不会立即进行数据交换。

  真正进行数据交换是在服务端accept()函数执行之后，这时候客户端connect()函数也执行完毕，然后服务端和客户端相互进行I/O交互。

  ​

- read()/write()

- close()



客户端套接字的IP地址和端口是在调用connect()函数时自动分配的，无需调用bind()函数进行分配。TCP服务端和TCP客户端并不是独立的，俩者是相互关联的。

服务器在调用listen()函数进入等待连接请求状态时，TCP客户端才能通过connect()进行连接，同时要注意的是客户端调用connect()之前，服务端可能会进入accept()阶段，这时候会进入阻塞状态直到客户端调用connect()函数为止。





### TCP与应用层协议

TCP是面向连接的，传输数据是没有边界的，因此需要定义应用层协议。

应用层协议的制定是为了让服务端或客户端知道读取数据的边界，这样才能正确的通信。



TCP服务端和TCP客户端的write()和read()函数是对应的，

例如客户端先调用write()，再调用read()函数，服务端调用read()再调用write()函数，如果服务端read()调用后阻塞，客户端也会阻塞等待服务端传输数据。





### TCP的IO缓冲

TCP套接字是有I/O缓冲区的，即输入缓冲区和输出缓冲区。

I/O进行数据交互时，write()函数会将数据移动到输出缓冲区，在适当时候将数据传向对方的输入缓冲区(分批传送或一次性传送)，这时对方将调用read()函数从输入缓冲区读取数据，

注：write()函数并不会在向对方主机传输数据完成后返回，它是在将数据传输到输出缓冲区后返回。

I/O缓冲区特性有：

- 每个套接字都有I/O缓冲区
- I/O缓冲在创建套接字完成
- 即使关闭套接字也会继续传递输出缓冲区中遗留的数据
- 关闭套接字会丢失在输入缓冲区的数据

除了I/O缓冲，TCP协议还拥有Sliding Window协议，该协议可以控制数据流，即传输的数据不会超过输入缓冲区的大小。



### TCP原理

TCP套接字从创建到消失的过程分3步：

- 与对象套接字建立连接
- 与对方套接字进行数据交换
- 断开与对方套接字的连接





套接字的连接：

TCP在实际通信过程中也会经过3次对话过程，简称三次握手（Three-way handshaking）。套接字是以全双工（Full-duplex）方式工作的，也就是说它可以双向传递数据，因此收发数据前需要一些准备。

假设现在主机A向主机B发起连接，它的3次握手过程如下：

- [SYN] SEQ:1000,  ACK::-

  这是首次连接时使用的信息，又称SYN，表示收发数据前传输的同步消息。

  SEQ是1000，ACK为空。SEQ1000的意思是当前数据包的序号是1000，如果主机B接收无误的话，请通知我向您传递1001序号的数据包。

- [SYN+ACK] SEQ:2000, ACK:1001

  这是主机B对主机A首次传输的数据包的确认消息，ACK1001表示SEQ1000的数据包接收无误，请传递1001的数据包。

  SEQ2000是为主机B传输数据做准备的同步消息的捆绑发送，它表示现在传递的数据包序号是2000，如果接收无误请向我传递2001的数据包。

- [ACK] SEQ:1001, ACK:2001

  ACK2001表示收到2000序号的数据包，现在传递SEQ为2001序号的数据包，在这一步主机A和主机B建立了连接。





套接字的数据交换

假设有200字节的数据需要进行传输，传输过程中分2次（2个数据包），具体过程如下：

- SEQ 1200, 100byte data

  主机A向主机B传递100字节数据，数据包序列号是1200

- ACK 1301

  主机B为了确认收到数据，回传1301消息，这里1301的序号是为了确定接收到数据，并且确定下一次接收的数据包序号，计算公式是：ACK号 = SEQ号 + 传递的字节数 + 1

- SEQ 1301, 100byte data

- ACK 1402

如果在传递第二个数据包时发生数据包丢失，例如超时等原因，那么主机A在迟迟等不到主机B回传的ACK就会尝试数据包重传。

为了完成数据包重传，TCP套接字是会启动计时器以等待ACK的应答，若相对应的计时器发生超时则重传。



