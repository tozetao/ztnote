TCP是一种面向连接的、可靠的、基于字节流的通信协议，数据在传输时需要建立连接，传输完毕后要断开连接。



### TCP数据报结构

```c
struct tcp_package {
    short source_port;	//源端口
    short target_port;	//目标端口
    int seq;	//Sequence Number，序号，占32位
    int ack;	//Acknowledge Numb，确认号，占32位
    //6个标志位
    //其他略...
};
```

重点关注以下字段：

- seq

  Sequence Number，序号，占32位，用来标识从计算机A发送到计算机B的数据包的序号，在发送数据包时会对此进行标记。

- ack

  Acknowledge Number，确认号，32位，客户端和服务端都可以发送，ack = seq + 1

标志位有6个，每个标志位占1个字节，分别是：

-  URG：紧急指针（urgent pointer）有效。
-  ACK：确认序号有效。
-  PSH：接收方应该尽快将这个报文交给应用层。
-  RST：重置连接。
-  SYN：建立一个新连接。
-  FIN：断开一个连接。

SYN是Synchronous的缩写，表示同步的；FIN是Finish的缩写，表示完成；seq是Sequence的缩写，表示序列；ack是Acknowledge，表示确认。



### 三次握手

使用connect()建立连接时，客户端与服务端会相互发送3个数据包。

客户端调用socket()函数创建socket套接字后，因为没有建立连接，所以处于CLOSED状态；服务端调用listen()函数后，套接字进入LISTEN状态，开始监听客户端请求。

- 1）第一个数据包

  客户端调用connect()发起连接。

  TCP协议会组建一个数据包，并设置SYN标志位，同时随机生成一个数字1000填充到Seq字段，表示该数据包的序号，组建完后将数据包发出，这时客户端处于SYNC-SEND状态。

- 2）第二个数据包

  服务端收到数据包后进行解析，检测到只有SYN标志位，因此知道该数据包是建立请求的数据包。

  服务端也会组建一个数据包，它会设置数据包的SYN标志位和ACK标志位，ACK标志位用于确认收到了客户端数据包。

  接着服务端生成一个随机数2000填充到Seq字段，表示该数据包序号，同时将ACK字段设置为1000+1，组建完后就发数据包发出，这时服务端处于SYNC-SEND状态。

- 3）第三个数据包

  客户端收到数据包后，检测到有SYN标志位和ACK标志位，知道这是服务端发来的"确认包"，因此会检测ACK字段的值，判断是否等于1000+1，如果是就说明连接建立成功。
  接着客户端会继续组建数据包，并设置ACK标志位，表示收到了服务端发来的"确认包"。同时将服务端发来的数据包序号2000加1，使用2001数字填充ACK字段。

  客户端将数据包发出，处于ESTABLISED状态，表示连接建立成功。

- 4）

  服务端收到数据包，检测到有ACK标志位，知道这是客户端发来的"确认包"，服务端会检测ACK字段，判断是否等于2000+1，如果是说明连接建立成功，服务端进入ESTABLISED状态。

三次握手的关键是要确认对方收到了自己的数据包，这个目标是通过"确认号（Ack）"字段实现的。计算机会记录下自己发送的数据包序号Seq，待收到对方的数据包后，检测"确认号（Ack）"，看Ack = Seq + 1是否成立，如果成立说明对方收到自己的数据包。



### TCP数据的传输

假设主机A要分2个数据包向主机B传输200字节数据，那么会有以下过程：

- 发送方发送数据包

  主机A通过一个数据包发送100个字节的数据，数据包的Seq序号设置为1200

- 接收方响应ACK包

  主机B为了确保收到主机A的数据包会响应ACK数据包，并将ACK字段设为1301。

  ACK字段  = Seq + 传递的字节数 + 1，将传递的字节数计算在内是为了让发送端能够确保自己的数据发送成功，加1是告诉发送方下次传递的Seq序号

- 发送方继续发送数据包

  主机A收到ACK数据包，检测ACK字段是否为1301，如果是代表数据发送成功。然后会以1301作为序号发送下一个数据包。



发送方是如何确保接收方收到数据的?

为了保证数据准确到达，目标机器在收到数据包（SYN包、FIN包、普通数据包等）都需要回传ACK包，这样发送方才能确保接收方有收到数据包。



超时重传

如果发送的数据包丢失或者中途发生错误，例如在一定时间内没有收到目标机器相应的ACK包，或者ACK包数据长度验证失败，那么TCP协议会对数据包进行 重传。

为了完成数据包的重传，TCP套接字在每次发送数据包的时候都会启动定时器，如果在一定时间内没有收到目标服务器的ACK包，那么定时器超时，数据包会重传。

- 重传超时时间 

  重传的超时时间理论上最好的是网络RTT时间，RTT指的是从发送端发送数据包开始，到发送端收到来自接收端的ACK确认包，总共经历的时间。





### TCP连接的断开

建立一个连接要三次握手，而断开一个连接要经过四次握手。

- 1）第一个数据包

  当建立连接后，客户端与服务端都处于ESTABLISED状态，这时客户端发起断开连接的请求。

  客户端设置FIN标志位组建数据包，Seq序号为5000，然后发送FIN数据包，处于FIN_WAIT_1状态。

- 2）第二个数据包

  服务端接收数据包，发现FIN标志位，知道客户端要断开连接，于是组建ACK数据包，设置ACK标志位，Seq序号为7000，ACK字段为5001.

  注：这时服务端并不会断开连接，而是做一些准备工作，服务端处于CLOSE_WAIT状态。客户端接收到ACK包后进入FIN_WAIT_2状态，等待服务端再次发送数据包。

- 3）第三个数据包

  服务端在准备完毕后再次发送FIN数据包，Seq序号是7001，ACK字段仍然是5001，服务端进入LAST_ACK状态。

- 4）第四个数据包

  客户端在收到FIN包后，再次发送ACK包，ACK字段是7002，Seq序号是5001，客户端进入TIME_WAIT状态。

  服务端在收到ACK包后就关闭连接，进入CLOSE状态。



关于TIME_WAIT

TCP是面向连接的，必须保证数据能够正确的到达目标机器。而网络是不稳定的， 为了确保数据传达，发送端在传送一个数据包时，都需要接收端回传ACK包，告诉发送方我已经收到数据了。

如果接收方没有回传ACK包，发送方会重传数据包，直到接收方回传ACK包。



所以在关闭连接传递最后一个数据包的时候，客户端不能直接进入CLOSE状态，







