系统层面上的锁，由操作系统提供加锁

语言层面上的锁，例如php的文件锁、java的锁



关于锁的操作

获取锁来得到对数据进行排他性访问的能力，然后才能对数据执行一系列的操作，最后还需要将锁释放给其他程序使用。

对于能够对多个线程访问的共享内存数据结构，这种先获取锁，然后执行，最后释放锁的动作很常见。



watch命令

redis使用watch命令代替数据进行加锁，因为watch只会在数据被其他客户端抢先修改了的情况下通知执行该命令的用户，而不会阻止其他客户端对数据进行修改，所以该命令被称为乐观锁。

watch命令监视的key，如果该key被频繁的改变可能会引起性能问题的。程序在完成一个事物的时候，可能会因为watch监视的key发生变动而执行失败，这样会导致事务反复的重试。



分布式锁

分布式所也有类似的先获取锁，执行操作，最后释放锁的过程，但是它的范围并不是针对同一个进行的多个线程使用，也不是同一台机器上的多个进程使用，而是由不同redis客户端进行获取和释放的。



实现目标

要求有超时限制特性：如果获得锁的进行在指定的时限内未能完成操作，那么锁将会自动释放。



锁会引发的问题

- 持有锁并打算执行长时间操作的进程已经奔溃，但是其他进程不知道，只能白白等待
- 在一个进程持有的锁过期之后，其他多个进程同时尝试获得了锁，并且都获得了锁。





使用set命令的NX选项来实现锁，即只有在key 不存在的情况下为key设置值。

