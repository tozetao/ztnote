系统层面上的锁，由操作系统提供加锁

语言层面上的锁，例如php的文件锁、java的锁



关于锁的操作

获取锁来得到对数据进行排他性访问的能力，然后才能对数据执行一系列的操作，最后还需要将锁释放给其他程序使用。

对于能够对多个线程访问的共享内存数据结构，这种先获取锁，然后执行，最后释放锁的动作很常见。



watch命令

redis使用watch命令代替数据进行加锁，因为watch只会在数据被其他客户端抢先修改了的情况下通知执行该命令的用户，而不会阻止其他客户端对数据进行修改，所以该命令被称为乐观锁。

watch命令监视的key，如果该key被频繁的改变可能会引起性能问题的。程序在完成一个事物的时候，可能会因为watch监视的key发生变动而执行失败，这样会导致事务反复的重试。



分布式锁

分布式所也有类似的先获取锁，执行操作，最后释放锁的过程，但是它的范围并不是针对同一个进行的多个线程使用，也不是同一台机器上的多个进程使用，而是由不同redis客户端进行获取和释放的。



实现目标

要求有超时限制特性：如果获得锁的进行在指定的时限内未能完成操作，那么锁将会自动释放。



锁会引发的问题

- 持有锁并打算执行长时间操作的进程已经奔溃，但是其他进程不知道，只能白白等待
- 在一个进程持有的锁过期之后，其他多个进程同时尝试获得了锁，并且都获得了锁。





实现

- 加锁实现

  使用set NX命令设置一个要key，值为128位的uuid，如果设置失败将会在一定时间内尝试，直到设置成功或者时间过期；如果加锁成功将会返回该key的值，即uuid。

- 解锁

  使用watch命令监视代表锁的key，然后检查加锁的key的值与与解锁传递进来的值是否一致，确认值没有变化则删除，这一步可以防止程序错误的是否同一个锁多次。



更细粒度的锁

锁应该锁住数据结构中的一小部分或者锁住整个数据结构，这个便是粒度的不同。

