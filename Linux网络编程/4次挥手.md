四次挥手

- 首先有一方应用程序调用close，我们称该方为主动关闭方。该方的TCP发送一个FIN包，表示关闭连接。之后主动关闭方进入FIN_WAIT_1状态。
- 接着收到FIN包的对端执行被动关闭。这个FIN由TCP协议栈处理，TCP协议栈会为FIN包插入一个EOF到接收缓冲区中，这个EOF是放在接收缓冲区已收到的数据之后的。这是被动方进入CLOSE_WAIT状态。
- 接下来被动方读取到EOF，主动close套接字。这回导致TCP发送一个FIN包，这样被动方进入LAST_ACK状态。
- 最终主动关闭方接收到对方的FIN包，并确认这个FIN包。主动方进入TIME_WAIT状态，并向被动方发送ACK包。而收到ACK包的被动方则进入CLOSED状态。在经过2MSL时间之后，主动关闭方也进入CLOSED状态。

可以看到每个方向都需要一个FIN和一个ACK，因此称为4次挥手。



### MSL

MSL是任何IP数据包在因特网存活的最长时间。RFC793规定MSL的时间为2分钟，Linux实际将其设置为30秒。



### TTL

在每个IP数据包里会有一个8位的TTL（time to live），它的最大值是255。TTL是由源主机设置的，它表示的是IP数据包能够在网络中的最大跳跃数。

比如每经过一个路由器就相当于经过了一跳，它的值就减1，当减为0时，所在的路由器就会将其丢失，同时发送ICMP报文通知源主机。



注：TTL为255的tcp报文在网络上生存时间不能超过MSL的。



### lost duplicate

lost duplicate称为迷失报文。

lost duplidate在网络中很常见，经常是由于路由器产生故障，路径无法收敛，导致一个包在路由器A、B、C之间做类似死循环的跳转。 IP头部有一个TTL的字段，限制了一个包在网络中的跳跃次数，因此这个包要么在TTL次数到达0的时候被丢弃，要么TTL在变为0之前路由器路径收敛，凭借剩余的TLL次数到达目的地。

但是一般TCP重传机制在早些的时候就传了一个跟它一样的包，并先于它到达目的地，所以这个包最终是会被TCP协议栈丢弃。









### TIME_WAIT

TIME_WAIT状态是TPC四次挥手过程中的一个状态，只有发起终止连接的一段会进入TIME_WAIT状态。

主动关闭端停留在TIME_WATI的时间是固定的，是MSL的俩倍，称为2MSL。

- Linux有一个硬编码的字段TCP_TIMEWAIT_LEN，其值为60秒。也就是说Linux系统停留在TIME_WAIT的时间为60秒。



#### TIME_WAIT的作用

有俩个原因：

第一个理由是为了确保最后的ACK能让被动关闭方接收，从而帮助其正常关闭。

假设主动关闭方在发出ACK包直接进入CLOSED状态，当ACK包在中途丢失了，TCP协议会让对端重传FIN包，这时主动方在失去当前连接的上下文，只能回复一个RST操作，从而导致被动关闭方出现错误。所以主动关闭方保持一个2MSL的TIME_WAIT则有更大机会把丢失的ACK再次发送出去。

第二个是为了处理迷失重复报文或老的重复数据包。

这里要知道incarnation connection，一般称为连接化身，它指的是跟上次socket相同的新连接（即相同的TCP连接四元组），连接化身和迷失报文会给新连接带来严重错误。

我们知道TCP是流式的，所有包到达的顺序是不一致的。依靠序列号由TCP协议栈来重组。假设一个连接化身这是收到的seq是1000，来了一个迷失报文seq是1000，len是1000，那么TCP会分为这个报文是合法的，会将丢失报文的数据放入到接收缓冲区，这就导致传输出现了错误。

通过一个2MSL状态，可以确保所有迷失报文都会消失，避免新连接的错误。





- 为什么是2MSL？

  之所以是2MSL，是由于一个MSL是一个数据包在网络中单向发出到认定丢失的时间，一个数据包极有可能在发送途中或响应途中称为迷失数据包，确认一个数据包以及响应的数据包在网络中丢弃就需要俩倍的MSL。

- tcp连接四元组，<ClientIP, ClientPort, ServerIP, ServerPort>

  正常发起对服务器的连接只设置了ServerIP和ServerPort，而ClientIP和ClientPort在创建连接时，由系统内核自动选择。

- TIME_WAIT的计时

  TIME_WAIT是从主动关闭方接收到对端的FIN包并发送ACK开始计时的。这是为了保证俩段的数据包在网络中消失。





#### TIME_WAIT的危害

一个TCP连接至少要消耗一个本地端口（指连接发起方），要知道本地端口资源也是有限的，而TCP不允许从处于TIME_WAIT状态下的socket创建一个新连接，也就是ClientPort相同的连接。

随着TIME_WAIT状态过多，会导致无法创建新连接。





#### 解决方案

```
net.ipv4.tcp_tw_reuse
```

该选项是系统内核选项。指的是如果从协议的角度来看是安全可控的，可以复用处于TIME_WAIT的套接字为新的连接所用。

什么是从协议角度理解的安全可控呢？主要俩点：

- 只适用于连接发起方（C/S模型中的客户端）。
- 对应的TIME_WAIT状态的连接存在时间超过1秒才可以被复用。

使用这个选项还有一个前提，需要打开对TCP时间戳的支持，即net.ipv4.tcp_timestamps=1（默认为1）。

要注意的是，tcp_tw_reuse是内核选项，主要用于连接的发起方。TIME_WAIT状态的连接创建时间超过1秒后，新的连接才能可以呗复用，这里是连接的发起方。





```c
SO_REUSEADDR
```

该选项是TCP套接字选项，用于解决端口复用问题，即使是TIME_WAIT状态的套接字，也可以继续使用它作为新的套接字使用。

说明：端口被占用，但是TCP连接状态处于TIME_WAIT，可以重用端口；如果端口忙，而TCP处于其他状态，重用端口依旧会得到"Address already in use"的错误。

