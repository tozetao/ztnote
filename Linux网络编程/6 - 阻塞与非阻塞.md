### 阻塞

TCP套接字默认情况下是阻塞模式。

在阻塞模式下，调用read()读取socket的数据时，如果socket的缓冲区没有数据，程序将会阻塞在这里，直到soc接收缓冲区有数据且被复制到应用程序的缓冲区中，或者发生错误才返回。最常见的错误是系统调用被信号中断。

而调用write()发送数据时：

- 如果缓冲区的可用长度小于要发送的数据，那么write()会被阻塞。直到缓冲区中的数据被发送到目标机器，腾出足够的空间，才能唤醒write()函数继续写入数据。
- 如果TCP协议正在发送数据，那么输出缓冲区会被阻塞，直到输出所有数据write()才会被唤醒。

当应用程序的数据全部写入到内核输出缓冲区时，write()函数才会返回。

这便是TCP的默认阻塞方式，所谓阻塞就是上一步动作没有完成，下一步动物将暂停，直到上一步动作完成后才能继续，以保持同步性。

```c
socket();

bind();

listen();

int clnt_sock = accept();

//如果是阻塞模式，所连接的socket输入缓冲区没有数据的话将会阻塞在这里，一直等待对端传输数据过来
read(clnt_sock, buffer, size);		
```



### 非阻塞

非阻塞指的是，进程把一个socket设置成非阻塞，它在通知内核：当所请求的I/O操作非得把本进程投入到睡眠中才能完成时，不要把进程投入到睡眠中，而是返回一个错误（EWOULDBLOCK）。

```c
int clnt_sock = accept();

int opt = fcntl(clnt_sock, F_GETFL, 0);
fcntl(clnt_sock, F_SETFL, opt | O_NONBLOCK);

// 非阻塞模型下会直接返回一个错误，而不会一直阻塞等待读取数据
read(clnt_sock, buffer, size);
```

在非阻塞模式下无法确定什么时候能读取到数据，一般会通过一个循环来进行轮询（polling）。即应用进程持续轮询内核，以查看某个操作是否就绪，这样做会耗费大量CPU时间，所以非阻塞一般配合I/O复用进行使用。