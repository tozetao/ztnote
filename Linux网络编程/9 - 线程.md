线程被称为轻权进程（lightweight process），线程的创建可能比进程的创建快10-100倍。

同一进程内的所有线程共享相同的全局内存。这使得线程共享数据非常简单，然而会带来同步问题。



同一进程内的所有线程可共享的内容有：

- 全局变量
- 进程指令
- 打开的文件描述符
- 信号处理函数和信号设置
- 当前工作目录
- 用户ID和组ID

不过每个线程有各自的：

- 线程ID
- 寄存器集合，包括程序计数器和栈指针
- 栈空间（存放局部变量和返回地址）
- errno
- 信号掩码
- 优先级



### 线程的初始化

当一个程序由exec启动执行时，称为初始线程或主线程的单个线程就创建了，其余的线程都是通过pthread_create创建的。

创建一个线程时我们会指定要执行的函数及其参数，线程会通过调用该函数开始执行，该函数执行完毕后线程终止，也可以通过调用pthread_exit显示的终止线程。

```c
#include <pthread.h>

int pthread_create(pthread_t *tid, pthread_attr_t *attr, void *(* func)(void *), void *arg)
```

- tid

  每个线程由tid标识，如果线程创建成功，其ID就通过tid指针返回。

- attr

  线程是有属性的：优先级、初始栈大小，是否应该成为一个守护线程等等。attr参数用于指定初始化线程时的属性。

- void \*(\* func)(void *)

  该参数是一个参数为void指针，返回值为void指针的函数指针。

  该函数一般是线程的执行逻辑。

- arg

  arg参数是第三个参数函数指针的参数，通过arg参数可以指定函数指针参数的数据。

pthread_create()执行成功返回0，失败返回一个非0的错误值。



```c
#include <pthread.h>

int pthread_join(pthread_t *tid, void **status);
```

pthread_join用于等待一个给定线程停止，类似waitpid系统调用。但是Pthread必须指定要等待的线程，无法等待任意结束的线程。

- status

  一个指向某个对象的指针，如果status非空，来自所等待线程的返回值将存入由status指向的位置。



### 可汇合与脱离

当一个可汇合的线程终止时，它的线程ID和退出状态将留存到另一个线程对它调用pthread_join。而一个线程如果时脱离的状态，它就像守护进程，当它终止时，所有相关资源都被释放，我们不能等待它们终止。

```c
int pthread_detach(pthread_t tid);
```

成功返回0，失败返回错误为正的值。







### 线程安全

POSIX.1要求由POSIX.1和ANSI C标准定义的所有函数都是线程安全的。

如果一个函数没有使用到静态变量或全局变量，该函数使用的变量都是自己定义的，这些变量是在该函数栈空间创建的，因此它是线程安全的。

如果一个函数有使用静态变量，或者参数是指向外部的指针，当同一进程内的不同线程（信号处理函数也被视为线程）调用该函数时就会有问题发生，这种函数是非线程安全的。





### 线程特定数据

每个进程都支持有限数量的线程特定数据元素，POSIX中要求数量最少为128。

系统或者是线程库维护着一个我们称之为Key结构的结构数组，该结构可能如下实现：

```c
struct Key {
    int flag;	//标志，当前元素是否被使用
    void (* destructor)(void *value);	//析构函数指针，一般用于释放线程资源
};
```

同时系统会为进程内的每个线程维护着一个PThread数组，我们称之为pkey数组，每个线程的pkey数组是相互独立的且每个元素默认初始化为NULL。



总结：pkey数组与Key结构数组是逐一关联的，在使用时，会获取Key结构数组中第一个未被使用元素的索引，使用该索引作为pkey数组的下标来访问和存储元素的数据。



简单的说，每个线程都有一个对应的数组可以用于存储数据，而系统帮我们维护一个结构数组，该结构数据决定了使用线程数据数组中哪个下标。



```c
int pthread_key_create(pthread_key_t *keyptr, void (* destructor)(void *value));
```

创建一个新的线程的特定数据元素，系统会搜索其Key数据结构上第一个不在使用的元素，返回给线程调用者，所找到的key会当作pkey的索引，配合其他函数在pkey索引上存储我们设置的值（指针）。

- keyptr

  特定数组元素的索引（key）。

- destructor

  该函数指针用于释放对应线程资源。

  pthread_key_create()创建某个线程的特定数据元素时，所指定的参数之一是指向某个函数指针。当该线程终止时，系统会扫描该线程pkey数组，为每个非空的pkey指针调用相应的析构函数。



```c
int pthread_once(pthread_once_t *onceptr, void (*init)(void));
```

使用初始值为PTHREAD_ONCE_INIT的onceptr变量，保证init指向的函数只被执行一次。

Linux Threads使用互斥锁和条件变量保证由pthread_once指定的函数仅执行一次，而onceptr变量表示是否执行过。

- onceptr

  onceptr变量表示pthread_once指定的函数是否执行过。

  实际上"一次性函数"的执行状态有三种：NAVER(0)、IN_PROGRESS(1)、DONE(2)，如果onceptr初始值为1，则由于所有的pthread_once必须等待其中一个激发已执行一次信号，因此所有pthread_once都会陷入永久的等待中；如果为2，则表示函数已执行过一次，从而所有pthread_once()都会立即返回0。

- init

  函数指针，表示待执行的函数。

example：

```c
static pthread_once_t onceptr = PTHREAD_ONCE_INIT;

void once()
{
    printf("only once!\n");
}

void *exec(void *arg)
{
    printf("thread id: %ld\n", pthread_self());
    pthread_once(&onceptr, once);
    return NULL;
}
```



```c
int pthread_getspecific(pthread_key_t key);
// 返回线程特定数据的指针（可能为NULL）

int pthread_setspecific(pthread_key_t key, const void *value);
// 成功返回0，失败返回正的错误值
```



example：

在进程范围内对于一个给定的键，pthread_key_create只能被调用一次，所创建的键通过keyptr返回，如果destructor参数不为空，并且给定的键在线程中有对应的值，那么destructor指向的函数指针会在线程终止时调用。



### 互斥锁

多线程并发情况下去读写一个同一个变量，会得到不可预料的结果。

互斥锁可以保护一个共享变量，访问该变量的前提条件是持有该互斥锁。按照PThread规定，互斥锁是类型为pthread_mutex_t的变量。

```c
int pthread_mutex_lock(pthread_mutex_t *mptr);
int pthread_mutex_unlock(pthread_mutex_t *mptr);
// 成功返回0，失败返回正数的错误值
```

通过上面的函数来实现加锁和解锁，如果试图上锁是已被另外某个线程锁住的一个互斥锁，本线程将被阻塞，直到该互斥锁被解锁。

如果某个互斥锁变量是静态分配的，我们就必须把它初始化为常值PTHREAD_MUTEX_INITIALIZER。如果是在共享内存区中分配一个互斥锁，那么必须通过调用pthread_mutex_init函数在运行时把它初始化。

```c
pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_r *restrict attr);
```

函数以动态方式创建互斥锁，参数attr指定了互斥锁的属性。如果参数为NULL，默认使用快速互斥锁。函数执行成功后，互斥锁被初始化为未锁住态。



### 条件变量

条件变量提供了一种信号机制，它是一种能够让程序在等待某个条件发生期间让程序进入睡眠的机制。

```c
int pthread_cond_wait(pthread_cond_t *cptr, pthread_mutex_t *mptr);
// 成功返回0，失败返回一个正数的错误
```

让某个线程等待指定条件变量的条件成立而挂起，同时释放掉mptr指向的互斥锁，而当在条件成立收到信号后，会再次持有该互斥锁。

- cptr

  要等待条件成立的条件变量

- mptr

  条件变量所对应的互斥锁

条件变量必须关联一个互斥锁。

因为条件变量通常是线程之间共享的某个变量的值，允许不同线程设置和检测该变量的条件，所以要求有一个与该变量关联的互斥锁。

example：

```c
// 加锁
pthread_mutex_lock(&mutex);

while (ndone == 0) {
    // 该函数把调用线程投入睡眠并释放调用线程持有的互斥锁；cond是条件变量，mutex是互斥锁
    pthread_cond_wait(&cond, &mutex);
}

// do something

// 释放锁
pthread_mutex_unlock(&mutex);
```

在上述的代码中，如果没有使用互斥锁，假设代码在主线程执行到ndone == 0之后pthread_cond_wait之前其他线程递增了ndone，那么该信号就丢失了。



```c
int pthread_cond_signal(pthread_cond_t *cptr);
```

发送一个信号给另外一个正处于阻塞等待状态的线程，使其脱离阻塞状态继续执行。如果没有线程处于在阻塞等待状态，函数也会返回成功。

pthread_cond_signal不会有惊群现象，它最多只给一个线程发送信号。如果有多个线程在阻塞，会根据线程优先级的高低来决定哪个线程收到信号；如果优先级相同，则根据各线程等待时间的长度来确定哪个线程获得信号。

- cptr

  条件标量

example：演示如何将开启的线程进行回收

```c
#include <stdio.h>                                                                     #include <stdlib.h>                                                                     #include <pthread.h>                                                                   #include <unistd.h>                                                                     #include <string.h>

#define THREAD_LIMIT 3
#define THREAD_DONE 1
#define THREAD_COLLECTION 2                                                             

static int ndone = 3;

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t  cond  = PTHREAD_COND_INITIALIZER;

struct thread_instance {                   
    pthread_t tid;                        
    int flag;
};                                                                                     void *exec(void *);

// 创建3个线程，当子线程执行完毕后通知主线程进行回收                   
int main()                                    
{                     
    int i, ret;                                 
    struct thread_instance threads[THREAD_LIMIT];
    
    // 创建3个线程
    for(i = 0; i < THREAD_LIMIT; i++) {        
        threads[i].flag = 0;
        pthread_create(&threads[i].tid, NULL, exec, &threads[i]);
    }
    
    while (ndone > 0) {                            
        // 监听条件变量                          
        pthread_mutex_lock(&mutex);
        pthread_cond_wait(&cond, &mutex);
        
        for(i = 0; i < THREAD_LIMIT; i++) {
            if (threads[i].flag & THREAD_DONE) {
                ret = pthread_join(threads[i].tid, NULL);
                ndone--;
                threads[i].flag = THREAD_COLLECTION;                              
                printf("%ld desotry, ret = %d, ndone = %d\n", threads[i].tid, ret, ndone);                            
            }                            
        }
        
        pthread_mutex_unlock(&mutex);                               
    }
    return 0;                                    
}

// 睡眠任意秒数，然后通知主线程           
void *exec(void *var)                  
{
    struct thread_instance *ins = (struct thread_instance *)var;
    int random = rand() % 3;
    sleep(random);
    
    pthread_mutex_lock(&mutex);
    
    ins->flag = THREAD_DONE;      
    pthread_cond_signal(&cond);                                
    printf("%ld sleep for %d seconds\n", pthread_self(), random);
    
    pthread_mutex_unlock(&mutex);                     
    return NULL;
}
```

