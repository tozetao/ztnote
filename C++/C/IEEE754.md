
### IEEE754标准
IEEE754规定，对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M，
假设浮点数是V，则 V = s + 2^E + M 组成；

- 符号位：表示浮点数的正负，0表示整数，1表示负数
- 阶码：表示指数位，以2为底的8位整数幂
- 尾数：表示有效数字，23位

关于有效数字M：
1<=M<2，M可以写成1.xxxxx的形式，其中xxxx表示小数部分，IEEE规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以省去，只保存后面的xxxx部分，目的是为了节省1位有效数字，等于能保存24位有效数字。

关于指数E：
指数E作为一个无符号整数，如果是8位，取值范围则是0-255，但是科学计数法的指数是有负数的，所以需要减去一个中间数来表示当E处于负数的情况，8位的E中间数是127，11位的E中间数是2^10-1。

比如2^10的E是10，保存成32位浮点数时是10+127，即10001001，解析时10001001需要减去127，才能得到争取的指数E。

指数E也可以分为3种情况：
- E不全为0或不全为1：这种情况浮点数就采用上面的规则，指数E减去127，得到真实值，再将有效数位M前加上第一位的1.
- E全为0：浮点数的指数E等于1-127，同时有效数字M不再加上第一位的1，而是还原为0.xxxx的小数，这样做是为了表示+-0，以及接近0的很小的数字。
- E全是1：这时有效数字M全为0，表示正负无穷大(正负取决于符号位S)，如果有效数字M不全为0，表示这个数字不是一个有效数。



10进制小数的存储方式：
- 首先将10进制小数转换成二进制小数，再将二进制小数以科学计数法表示，最后以符合标准存储成二进制
- 例如10进制小数5.0，转换成二进制小数是101.0，用IEEE754表示的话是1.01 * 2^2，s(符号位)是0，M是1.01，指数E是2




总结：
数据保存在计算机内存中不是1就是0，而数据类型决定了如何解析这些0和1，例如：
```php
#include <stdio.h>
void main(void){
	int num = 9;			//声明一个整型变量9
	float* pfloat =& num;		//声明一个float指针，指向num变量的地址

	printf("pfloat值为: %f\n", pfloat);	//输出0.000000
	
}
```
整数9如何用2进制表示，转换成浮点数是多少？
10进制9在32位系统中的2进制表示是：0000 0000 0000 0000 0000 0000 0000 1001

当它要转换成浮点数时，第一位是符号位s=0，后面8位的指数E=000 0000 0，最后的23位有效数M=000 0000 0000 0000 0000 1001，

由于指数E全部为0，所以浮点数：V = (-1)^0 * 0.000 0000 0000 0000 0000 1001 * 2^(1-127)，由于V是一个很小的接近0的正数，所以用10进制小数就是0.000000。

浮点数9如何用2进制表示，转换成10进制整数是多少？
浮点数9转换成2进制小数是1001.0，即1.001 * 2^3，第一位符号位是0，指数E = 3 + 127，即1000 0010，有效数位M=001 0000 0000 0000 0000，

存储在二进制中是0 10000010 001 0000 0000 0000 0000 0000，转换成10进制整数等于1091567616。


### 进制与小数
10进制小数的计算方式，例如：
10.25 = 1 * 10^1 + 0 * 10^0 + 2 * 10^-1 + 5 * 10^-2

同理，二进制的小数计算也是取每位数的2的整数次幂，例如：
10.101 = 1 * 2