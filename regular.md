## 正则表达式 
正则表达式类似于一个字符串模板，通过这个模板来匹配字符，它主要由各种类型的元字符组成。

#### 定义

一般是/斜杠作为起始和结束来定义一个正则表达式，也可以是#字符。

```php
$regex = '/abc/i';	//匹配abc字符串的表达式
$regex = '/http:\/\/[\w.]+/';	//匹配一个域名
```

### 2. 模式修饰符
用于改变正则表达式的行为，一般位于正则表达式的最后，修饰符有：
- i，忽略字母大小写
- x，忽略空格


### 3. 限定符
限定符用于限制每个字符串出现的次数
- *，用于匹配0到多个字符。
- +，匹配1到多个字符。
- ?，匹配0到1个字符。
- {n}，匹配n个字符
- {n,}，匹配n到多个字符
- {n,m}，匹配n到m个字符

在贪婪模式中，限定符会尽可能的匹配多的字符。
```php
$regex = '/a{3,}/';
$content = 'aaaaabcdef';
preg_match($regex, $content, $arr);
var_dump($arr);		//输出aaaaa
```

对于?或*元字符，如果要匹配的字符处于字符串的中间，正则会解析成0个来匹配，如果匹配的字符位于字符串的开头，正则会尽可能多的去匹配，例如：
```php
$matches = array();
$regex = '/\d?/';		//匹配0个或1个数字
$content = 'abcdef 123 worlds 45 ho to';

preg_match($regex, $content, $matches);
var_dump($matches);		//输出空字符串
```

### 4. 匹配符
匹配符用于匹配某一类的字符，它是正则表达式预定义的字符集。
- \d，匹配一个数字字符。[0-9]
- \w，匹配0-9、a-z、A-Z任意中的一个字符，相当于[0-9a-zA-Z]
- \s，匹配空白字符，例如空格、换行符、制表符中任意一个
- \W，匹配一个非单词字符，相当于[^0-9a-zA-Z]
- \D，匹配一个非数字字符。[^0-9]
- \S，匹配一个非空表字符
- . 匹配任意一个非换行\n的字符。

### 5. 行定位符
- ^，定义一个表达式以什么字符开头
- $，定义表达式以什么字符结尾

### 6. 其他
- \b，匹配一个单词边界，字符串的起始、结束和空格称之为单词边界，它匹配的是单词的位置，并不会匹配到空格。
```php
$reg = '/\b(\w+)\b\s\1/i';
$content = 'hello hello hello abcd hello abcd hello';
preg_match($reg, $content, $matches);
var_dump($matches);	//输出hello hello

$reg = '/\b(\w+)\b\1/i';
# 这样写是错的，规则的逻辑有问题
```





## 字符转义
在正则表达式当中，由于元字符是有特殊意义的，可有的时候需要匹配这些特殊字符，这是需要对其进行转义，例如：

```php
$regex = '/\*/';
# 匹配一个*字符

$regex = '/\./';
# 匹配一个.字符

$regex = '/\\\/';
# 匹配一个反斜杠

$content = 'abcd$efg';
$regex = '/\\$/i';		//匹配一个$字符

# 除了\反斜杠，其他元字符匹配用一个\或俩个\都能匹配，
# 为什么要匹配元字符需要俩个反斜杠？例如要匹配$，它的正则表达式是\$，
# 可是这个表达式中\也需要转义，所以就变成了\\，最后的表达式是\\$。
```


在php中，对于元字符的匹配更好的解决方案是使用\Q\E来匹配元字符


## 字符域
像\d \w \b这些匹配符都会匹配对应的字符集合，例如\d只会匹配任意数字，\w匹配任意字符和任意数字，有的时候想要匹配自定义的字符集合，可用通过 [] 字符域符号来定义。

- []：匹配字符集合中的某个字符，例如：

```php
$reg = '/[abcde]/';
# 匹配abcde其中一个字符

$reg = '/[0-9]/';
# 匹配0-9中的一个数字，等同于\d
```

在字符域([])中，大多数的特殊字符是作为普通字符对待的，只有像单双引号，斜杠和反斜杠需要转义，例如：
```php
$reg = '/[.?!*]/';
# 匹配其中一个字符

$reg = '/[ ]/';
# 匹配一个空格

$reg = '/[\'\"]/';
# 匹配单引号或双引号

$reg = '/[\/]/';
# 匹配一个斜杠

$reg = '/[\\\]/';
# 匹配一个反斜杠

$reg = '/[|]/';
# 匹配一个或|字符
```

### 1. 字符域和限定符
单独的字符域代表着匹配某个字符集合，当与限定符配合使用时，表示匹配一定数量的某个字符集合，例如：
```php
$str = "abcd-)--)-)-))-";

$reg = "/[-)]+/";	
//匹配一个或多个 -字符 )字符

$reg = "/[+)]?/";
//匹配0个或多个 -字符 )字符

```

example：
```php
$regex = '/\d{3}[1\-)]?/i';	
//匹配3个数字，其后跟随1或-或)，-在字符域中与数字使用时，需要转义
$content = '123-1)fjkdjfl';
preg_match($regex, $content, $matches);
print_r($matches);

```

### 2. 反义
有时候需要查找不属于某个字符类的字符，或者不属于特定字符集的字符，就需要用到反义。
^字符用于在字符类中取反，例如：[^abc]表示匹配出abc意外的任意一个字符。

- [^abc]，匹配非abc的任意字符


## 分支条件，|
分支条件类似于逻辑或，匹配的时候分支条件会从左到右测试每个条件，如果其中一个满足条件了，其余的规则就不会匹配了。

```php
// 测试匹配条件
$matches = array();
$regex = '/123|456/';	//匹配123或456
$content = "abcdefg456123";

preg_match($regex, $content, $matches);
var_dump($matches);


$regex = '/0\d{2}-\d{8}|0\d{3}-\d{7}/i';	
//匹配3位区号，8位本地号或匹配4为区号，7为本地号
$n1 = '022-23423423';

preg_match($regex, $n1, $matches);
print_r($matches);
```

匹配某几个单词，由于|和(字符在字符域中是普通字符，需要使用小括号来限定范围，例如：
```php
$reg = "/[com|cn]/";	//错误认知，匹配的是com|cn的字符集

$reg = "/(com|cn)/";	//正确的，匹配com或cn单词


$str = "hello comcom qwer cn";
$reg = "/(com|cn)+/";	//匹配一个或多个com字符或cn字符
preg_match($reg, $str, $array);

echo '<pre/>';
var_dump($array);
//全局输出：comcom
//子表达式输出：com
```

## ()
()可用于对字符分组来做反向引用，改变分支条件作用域，改变限定符作用范围

- 改变分支条件作用域，例如：
```php
$reg = "/com|hello world/";		//匹配com或hello world
$reg = "/(com|hello) world/";		//改变范围，匹配com world或hello world


# 匹配以0开头的2位数组或3位数组，后面跟着-字符和4位数组
$reg = '/(0\d{2}|0\d{3})-\d{4}/i';

$content = '0210-4567';
$content = '010-4567';
preg_match($reg, $content, $matches);
var_dump($matches);
```

- 改变限定符作用范围
```php
$reg = "/hello+/";	//限定符+作用于字符o
$reg = "/(hello)+/";	//限定符作用于hello字符串


$reg = '/(\d{3}\.)+/i';	//匹配3个数字加.字符，重复1次或多次
$content = '123.456.789.';
preg_match($reg, $content, $matches);
var_dump($matches);
```

- 进行分组，便于反向使用，单章节说明

## 反向引用
使用()小括号指定一个子表达式后，匹配这个子表达式的文本，也就是分组捕获的内容可以在表达式中引用。
每个分组自动拥有组号，规则是从左向右,以分组的左括号为标识，第一个出现的分组的组号是1，第二个是2，以此类推。


### 1. 匹配顺序
```php
$str='abc1234fsdfds';
$reg='/abc\d(\d)(\d)/i';

$m = array();
preg_match_all($reg, $str, $m, PREG_PATTERN_ORDER);
var_dump($m);	//输出abc123，1，2

# 第一次匹配到abc123，子表达式在原表达式匹配到的内容上进行匹配，
# 第一个子表达式匹配到2，第二个子表达式匹配到3
```

### 2. 子表达式的引用
反向引用用于重复搜索前面某个分组匹配的文本，例如\1代表分组1匹配到的文本，
```php
$str = '我...我是是..一个个...帅帅帅帅...哥';
$regex = "/(.)\1*/";
```
其他关于引用的语法再看。



## 贪婪匹配与懒惰匹配
当正则表达式中包含能接受重复的限定符时，通常行为是尽可能多的匹配字符，在整个表达式能匹配到的情况下。
```php
$reg = '/a.*b/i';
# 匹配最长的a开始，以b结束的字符
$content = 'aaaabdfdfdfdfb';
```

### 懒惰匹配模式
上述的限定符，都能转化为懒惰模式，只需要在限定符后面加上?，该限定符就会尽可能少的匹配字符。
```php
$reg = '/a.*?b/';
$content = 'aabab';
preg_match($reg, $content, $matches);
var_dump($matches);		//输出aab

# 懒惰模式会匹配成功下尽可能少的匹配
```
- *?，重复任意次，但尽可能少重复
- +?，重复1次或多次，但尽可能少的重复
- ??，重复0次或多次，但尽可能少的重复
- {n,m}?，重复n到m次，但尽可能少重复
- {n,}?，重复n次以上，但尽可能少重复

## 平衡组/递归匹配





## PHP正则函数说明
- preg_match()：返回匹配成功的次数，可能是0，匹配结果在第三个匹配变量中，它是一个数组，索引0是全局匹配的结果，索引1是子表达式1的结果，以此类推。
注：preg_match()在匹配到第一个结果的情况下，就会停止匹配，要对字符串全局匹配，要使用preg_match_all()

- preg_match_all()：匹配全局字符串，返回匹配的次数，匹配结果在第三个匹配变量中，也是一个数组；
注：匹配变量的结果可以在第四个参数配置，具体看手册。